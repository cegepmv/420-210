var relearn_searchindex = [
  {
    "breadcrumb": "Programmation orientÃ©e objet",
    "content": "1. Quâ€™est-ce que Java ? Java est Ã  la fois un langage de programmation orientÃ© objet et une plateforme informatique. Sa philosophie principale est le WORA (Write Once, Run Anywhere) : Ã©crivez votre code une fois, et exÃ©cutez-le nâ€™importe oÃ¹ sans modification.\nLes trois piliers de Java : JDK, JRE et JVM Pour comprendre comment Java fonctionne, il faut distinguer ces trois composants essentiels :\nJDK (Java Development Kit) : Câ€™est la boÃ®te Ã  outils complÃ¨te pour le dÃ©veloppeur. Elle contient le compilateur (javac), les bibliothÃ¨ques de base et le JRE. JRE (Java Runtime Environment) : Câ€™est lâ€™environnement nÃ©cessaire pour exÃ©cuter un programme Java. Il contient les bibliothÃ¨ques de classes et la JVM. JVM (Java Virtual Machine) : Câ€™est le cÅ“ur du systÃ¨me. Elle interprÃ¨te le â€œBytecodeâ€ pour que lâ€™ordinateur puisse le comprendre. ğŸ”— Ressource complÃ©mentaire : Java : Les fondamentaux expliquÃ©s (JDK, JRE et JVM)\n2. CaractÃ©ristiques principales du langage OrientÃ© Objet (POO) : Tout est considÃ©rÃ© comme un â€œobjetâ€ (une entitÃ© avec des caractÃ©ristiques et des comportements). Gestion automatique de la mÃ©moire : GrÃ¢ce au Garbage Collector (Ramasse-miettes), Java libÃ¨re automatiquement la mÃ©moire inutilisÃ©e. SÃ©curitÃ© : ConÃ§u pour les environnements rÃ©seaux, il possÃ¨de des barriÃ¨res strictes contre les accÃ¨s mÃ©moire non autorisÃ©s. Multi-thread : Java permet dâ€™exÃ©cuter plusieurs parties dâ€™un programme simultanÃ©ment. 3. Installation, compilation et exÃ©cution Installation Vous devez installer un JDK (comme OpenJDK ou Oracle JDK). VÃ©rifiez lâ€™installation avec la commande : java -version\nCompilation et exÃ©cution dâ€™un programme Java Dâ€™abord, tu dois tâ€™assurer que Java est bien installÃ© sur ton ordinateur\nOuvre une invite de commandes (cmd) sous Windows (Terminal sous Mac/Linux). Tape la commande java -version. Cette commande devrait vous dire la version de Java qui est installÃ© sur votre ordinateur. Tape aussi la commande javac -version. Cette commande devrait te dire la version du compilateur de Java installÃ© sur ton ordinateur Note: Ces commandes fonctionnent seulement si Java et le compilateur de Java sont installÃ©s et que le chemin oÃ¹ le rÃ©pertoire de Java se trouve est mis dans le PATH des variables dâ€™environnement (Ã€ expliquer en classe pour que ce soit plus clair) ExÃ©cution du code dans le fichier Main.java Ouvre une invite de commandes (cmd) sous Windows (Terminal sous Mac/Linux). Navigue vers le dossier oÃ¹ se trouve votre fichier .java ExÃ©cute la commande java Main.java. Traditionnellement, Java fonctionne en deux Ã©tapes :\nCompilation : Le code source (.java) est transformÃ© en bytecode (.class) grÃ¢ce Ã  la commande :\njavac Main.java ExÃ©cution : Le bytecode est ensuite exÃ©cutÃ© avec la commande :\njava Main ğŸ’¡ Astuce : Depuis une version relativement rÃ©cente de Java, il est aussi possible dâ€™exÃ©cuter directement un fichier .java sans passer explicitement par lâ€™Ã©tape de compilation (javac).\njava Main.java Cela permet dâ€™exÃ©cuter rapidement un programme, mais Ã  noter :\nLe fichier .class est gÃ©nÃ©rÃ© temporairement. Il est ensuite supprimÃ© automatiquement aprÃ¨s lâ€™exÃ©cution. ğŸ“ Cette mÃ©thode est pratique pour tester du code rapidement, mais dans un projet structurÃ©, on utilise gÃ©nÃ©ralement javac suivi de java.\nCompilation et exÃ©cution sans le PATH configurÃ© Si vous recevez lâ€™erreur : 'javac' n'est pas reconnu en tant que commande interne..., cela signifie que votre systÃ¨me ne sait pas oÃ¹ se trouve le dossier bin du JDK. Vous devez alors utiliser le chemin absolu.\nCompiler le fichier: Il faut appeler lâ€™exÃ©cutable javac directement. Sur Windows : \"C:\\Program Files\\Java\\jdk-21\\bin\\javac\" Main.java Sur macOS / Linux : /usr/lib/jvm/jdk-21/bin/javac Main.java RÃ©sultat : Un fichier Main.class apparaÃ®t dans votre dossier.\nExÃ©cuter le programme : Il faut appeler lâ€™exÃ©cutable java (la JVM). Sur Windows : \"C:\\Program Files\\Java\\jdk-21\\bin\\java\" Main Sur macOS / Linux : /usr/lib/jvm/jdk-21/bin/java Main RÃ©soudre lâ€™erreur de Classpath (-cp) Câ€™est lâ€™erreur la plus frustrante pour les dÃ©butants : Could not find or load main class. Cela arrive quand la JVM ne sait pas oÃ¹ chercher vos fichiers .class.\nLâ€™option -cp (ou -classpath) Cette option force Java Ã  regarder dans des rÃ©pertoires prÃ©cis.\nChercher dans le dossier actuel (.) : java -cp . Main Chercher dans un dossier spÃ©cifique (ex: bin) : java -cp bin Main Chercher dans plusieurs dossiers ou JARs : Windows : java -cp \".;lib/mysql.jar\" Main (sÃ©parateur ;) Linux/Mac : java -cp .:lib/mysql.jar Main (sÃ©parateur :) 4. Les outils de dÃ©veloppement (IDE) Bien que vous puissiez Ã©crire du Java dans un simple bloc-notes, les dÃ©veloppeurs utilisent des IDE (Environnements de DÃ©veloppement IntÃ©grÃ©s) pour Ãªtre plus efficaces. Ces logiciels regroupent lâ€™Ã©dition de code, la compilation automatique et le dÃ©bogage.\nIDE Points forts IntelliJ IDEA DÃ©veloppÃ© par JetBrains. Câ€™est le plus moderne et le plus intelligent (recommandÃ© pour la productivitÃ©). Eclipse Historique, entiÃ¨rement gratuit et open-source. TrÃ¨s utilisÃ© dans les grandes entreprises. VS Code TrÃ¨s lÃ©ger et polyvalent. NÃ©cessite lâ€™installation du â€œJava Extension Packâ€ pour fonctionner.",
    "description": "1. Quâ€™est-ce que Java ? Java est Ã  la fois un langage de programmation orientÃ© objet et une plateforme informatique. Sa philosophie principale est le WORA (Write Once, Run Anywhere) : Ã©crivez votre code une fois, et exÃ©cutez-le nâ€™importe oÃ¹ sans modification.\nLes trois piliers de Java : JDK, JRE et JVM Pour comprendre comment Java fonctionne, il faut distinguer ces trois composants essentiels :",
    "tags": [],
    "title": "Introduction",
    "uri": "/420-210/intro/index.html"
  },
  {
    "breadcrumb": "Programmation orientÃ©e objet",
    "content": "ğŸ¯ Quâ€™est-ce quâ€™une variable? Une variable, câ€™est comme un casier dans votre vestiaire du cÃ©gep. Vous pouvez y mettre vos affaires, les changer, les oublier (oups), et mÃªme y mettre nâ€™importe quoi (tant que Ã§a rentre et que câ€™est du bon type).\nLâ€™identificateur (Le nom) : Câ€™est lâ€™Ã©tiquette sur le casier (ex: 304). Câ€™est ce qui permet au programme de retrouver lâ€™endroit exact en mÃ©moire.\nLa valeur (Le contenu) : Câ€™est ce que tu dÃ©poses Ã  lâ€™intÃ©rieur (ton manuel de programmation, ton ordinateur).\nLe type (Le format) : Câ€™est la taille et la configuration du casier. Un casier pour un vÃ©lo nâ€™a pas la mÃªme forme quâ€™un casier pour un manteau.\nAutre dÃ©finition: Une variable, câ€™est comme une boÃ®te dans laquelle on range une valeur. Elle a toujours trois Ã©lÃ©ments essentiels :\nğŸ‘‰ type nom = valeur;\nPar exemple :\nint var1 = 42; Ici :\nğŸ§¾ int â†’ le type de la variable (entier) ğŸ·ï¸ var1 â†’ le nom de la variable ğŸ 42 â†’ la valeur quâ€™elle contient Les types En Java, les types de donnÃ©es sont divisÃ©s en deux grandes familles :\nğŸ§± Les types primitifs (8 types) ğŸ§© Les types rÃ©fÃ©rences (classes comme String, Scanner, etc.) Les types primitifs sont les briques de base de tout programme Java. Ils permettent de reprÃ©senter les informations simples : nombres, caractÃ¨res, boolÃ©ens.\nğŸ§®a. Les nombres entiers Ils servent Ã  stocker des valeurs sans virgule, positives ou nÃ©gatives. Chaque type utilise un certain nombre dâ€™octets et a une plage de valeurs dÃ©finie :\nType Taille (bits / octets) Valeur minimale Valeur maximale Exemple byte 8 bits (1 octet) -128 127 byte b = 10; short 16 bits (2 octets) -32 768 32 767 short s = 1000; int 32 bits (4 octets) -2â€¯147â€¯483â€¯648 2â€¯147â€¯483â€¯647 int i = 42; long 64 bits (8 octets) -9â€¯223â€¯372â€¯036â€¯854â€¯775â€¯808 9â€¯223â€¯372â€¯036â€¯854â€¯775â€¯807 long l = 100L; Il existe des constantes utiles comme Integer.MAX_VALUE ou Long.MIN_VALUE pour obtenir ces limites sans les retenir. ğŸŒŠ b. Les nombres Ã  virgule (flottants) Ils permettent de reprÃ©senter des valeurs dÃ©cimales (â‰ˆ des rÃ©els), avec une approximation en base 2.\nType Taille (bits / octets) PrÃ©cision Valeur min / max Exemple float 32 bits (4 octets) ~7 chiffres significatifs Â±1.4Ã—10â»â´âµ â†’ Â±3.4Ã—10Â³â¸ float f = 3.14f; double 64 bits (8 octets) ~15-16 chiffres significatifs Â±4.9Ã—10â»Â³Â²â´ â†’ Â±1.8Ã—10Â³â°â¸ double d = 2.718; ğŸ’¡ En Java, les littÃ©raux dÃ©cimaux sont des double par dÃ©faut. Pour un float, on ajoute un f Ã  la fin.\nğŸ”¤ c. Le caractÃ¨re Le type char reprÃ©sente un seul caractÃ¨re Unicode (lettre, symbole, emoji, etc.) :\nType Taille (bits) Plage Unicode Exemple char 16 bits 0 Ã  65 535 (U+0000 Ã  U+FFFF) char c = 'A'; ğŸ¨ Les caractÃ¨res sont entourÃ©s de quotes simples ('A') et peuvent contenir aussi des caractÃ¨res spÃ©ciaux ou emojis :\nchar lettre = 'f'; ğŸ”˜ d. Le boolÃ©en Un boolean est un type logique qui reprÃ©sente vrai ou faux, souvent utilisÃ© dans les conditions :\nType Valeurs possibles Exemple boolean true ou false boolean actif = false; ğŸ’¬ TrÃ¨s utile pour reprÃ©senter des Ã©tats binaires : activÃ©/dÃ©sactivÃ©, visible/cachÃ©, connectÃ©/non connectÃ©â€¦\nboolean estPret = true; boolean estFini = false; âœ¨ RÃ©cap visuel CatÃ©gorie Types RÃ´le principal ğŸ§® Entiers byte, short, int, long Stocker des nombres sans virgule ğŸŒŠ Flottants float, double ReprÃ©senter des valeurs dÃ©cimales ğŸ”¤ CaractÃ¨res char ReprÃ©senter un caractÃ¨re Unicode ğŸ”˜ BoolÃ©ens boolean ReprÃ©senter une valeur vraie ou fausse Les chaÃ®nes de caractÃ¨res (String ) câ€™est quoi? ğŸ¥ Lien vers la classe String de lâ€™API Java\nEn Java, une chaÃ®ne de caractÃ¨res (ou String) est un objet qui reprÃ©sente une sÃ©quence de caractÃ¨res. Contrairement Ã  certains langages oÃ¹ les chaÃ®nes sont simplement des tableaux de caractÃ¨res (char[]), en Java, elles sont des objets de la classe String.\nExemple :\nString message = \"Bonjour !\"; Utilisation simple CrÃ©er une chaÃ®ne :\nString nom = \"Alice\"; //Afficher une chaÃ®ne : System.out.println(nom); ConnaÃ®tre la longueur :\nint longueur = nom.length(); // renvoie 5 ConcatÃ©nation La concatÃ©nation permet de combiner plusieurs chaÃ®nes en une seule.\nUtilisation de lâ€™opÃ©rateur + : String prenom = \"Alice\"; String message = \"Bonjour, \" + prenom + \" !\"; System.out.println(message); // Bonjour, Alice ! ConcatÃ©nation avec des nombres : int age = 20; String info = \"Elle a \" + age + \" ans.\"; System.out.println(info); // Elle a 20 ans. 1. MÃ©thodes Statistiques de la classe String Les mÃ©thodes statiques de la classe String ne nÃ©cessitent pas de crÃ©er une instance de String pour les utiliser. Vous les appelez directement sur la classe elle-mÃªme. Voici quelques exemples de mÃ©thodes statiques courantes :\nExemple 1 : String.format() Cette mÃ©thode statique permet de formater une chaÃ®ne de caractÃ¨res en utilisant des espaces rÃ©servÃ©s (placeholders).\npublic class ExempleStringStatic { public static void main(String[] args) { String name = \"Alice\"; int age = 30; String formattedString = String.format(\"Nom : %s, Ã‚ge : %d\", name, age); System.out.println(formattedString); } } Sortie attendue :\nNom : Alice, Ã‚ge : 30 2. MÃ©thodes Non Statiques de la classe String Les mÃ©thodes non-statiques nÃ©cessitent une instance de la classe String pour Ãªtre utilisÃ©es. Vous devez crÃ©er un objet String pour appeler ces mÃ©thodes. Voici quelques exemples :\nExemple 1 : length() Cette mÃ©thode retourne la longueur (nombre de caractÃ¨res) de la chaÃ®ne de caractÃ¨res.\npublic class ExempleStringNonStatic { public static void main(String[] args) { String message = \"Bonjour\"; int length = message.length(); // Appel de la mÃ©thode non statique System.out.println(\"La longueur de la chaÃ®ne est : \" + length); } } Sortie attendue :\nLa longueur de la chaÃ®ne est : 7 Exemple 2 : charAt() Cette mÃ©thode retourne le caractÃ¨re situÃ© Ã  une position spÃ©cifiÃ©e dans la chaÃ®ne.\npublic class ExempleStringNonStatic { public static void main(String[] args) { String message = \"Java\"; char character = message.charAt(2); // RÃ©cupÃ¨re le caractÃ¨re Ã  l'indice 2 System.out.println(\"Le caractÃ¨re Ã  l'indice 2 est : \" + character); } } Sortie attendue :\nLe caractÃ¨re Ã  l'indice 2 est : v Exemple 3 : substring() Cette mÃ©thode retourne une sous-chaÃ®ne de la chaÃ®ne principale en fonction des indices donnÃ©s.\npublic class ExempleStringNonStatic { public static void main(String[] args) { String message = \"Bienvenue\"; String substring = message.substring(3, 7); // Extrait de l'indice 3 Ã  6 System.out.println(\"Sous-chaÃ®ne : \" + substring); } } Sortie attendue :\nSous-chaÃ®ne : nven Exemple 4 : toLowerCase() et toUpperCase() Ces mÃ©thodes convertissent tous les caractÃ¨res de la chaÃ®ne en minuscules ou en majuscules.\npublic class ExempleStringNonStatic { public static void main(String[] args) { String message = \"Java Programming\"; String lower = message.toLowerCase(); // Convertir en minuscules String upper = message.toUpperCase(); // Convertir en majuscules System.out.println(\"En minuscules : \" + lower); System.out.println(\"En majuscules : \" + upper); } } Sortie attendue :\nEn minuscules : java programming En majuscules : JAVA PROGRAMMING Exemple 5 : contains() Cette mÃ©thode permet de vÃ©rifier si une chaÃ®ne contient une sous-chaÃ®ne spÃ©cifiÃ©e.\npublic class ExempleStringNonStatic { public static void main(String[] args) { String message = \"Java est gÃ©nial!\"; boolean contains = message.contains(\"gÃ©nial\"); // VÃ©rifie si \"gÃ©nial\" est dans la chaÃ®ne System.out.println(\"La chaÃ®ne contient 'gÃ©nial' ? \" + contains); } } Sortie attendue :\nLa chaÃ®ne contient 'gÃ©nial' ? true RÃ©sumÃ© des diffÃ©rences entre les mÃ©thodes statiques et non-statiques : MÃ©thodes statiques :\nAppelÃ©es sur la classe elle-mÃªme, pas besoin dâ€™instance. Exemples : String.valueOf(), String.format(), String.join(). MÃ©thodes non-statiques :\nAppelÃ©es sur une instance de la classe String. Exemples : length(), charAt(), substring(), toLowerCase(). ğŸ”„ Conversion implicite vs explicite en Java La conversion permet de changer le type dâ€™une donnÃ©e pour lâ€™adapter Ã  une autre variable ou expression.\na. Conversion implicite (promotion automatique) Java effectue automatiquement la conversion quand il nâ€™y a pas de risque de perte de donnÃ©es. Se produit souvent quand on passe dâ€™un type plus petit Ã  un type plus grand. Exemples classiques : De Vers Exemple int double double d = 5; byte int int x = 10; int a = 10; double b = a; // Conversion implicite b. Conversion explicite (casting) NÃ©cessaire quand il y a un risque de perte de donnÃ©es ou incompatibilitÃ©. Le programmeur doit forcer la conversion avec un cast (type). Exemples classiques : De Vers Exemple double int int x = (int) 9.99; long int int y = (int) 100000L; double x = 9.99; int y = (int) x; // Conversion explicite, dÃ©cimale perdue c. DiffÃ©rences clÃ©s Aspect Conversion implicite Conversion explicite NÃ©cessite une action ? Non, automatique Oui, cast obligatoire (type) Risque de perte Non Oui Sens Du plus petit au plus grand Du plus grand au plus petit Exemples int â†’ double double â†’ int d. En rÃ©sumÃ© Conversion implicite = sÃ»re, automatique, du type petit vers grand. Conversion explicite = risquÃ©e, forcÃ©e, du type grand vers petit. Utilise toujours le casting explicite pour Ã©viter les erreurs de compilation. ğŸ§  Ã€ retenir Java convertit tout seul quand câ€™est sÃ»r. Pour tout ce qui peut perdre des infos, il faut caster manuellement. Sois vigilant avec les conversions explicites, elles peuvent tronquer ou modifier la valeur. Conversion des types Le terme le plus utilisÃ© pour la technique de conversion est Â« Casting Â».\nCas 1 Conversion 1 : String vers les numÃ©riques Conversion 2 : Les numÃ©riques vers une String en utilisant la mÃ©thode valueOf() Conversion 3 : Les numÃ©riques vers une String en utilisant la mÃ©thode toString() Conversion 4 : String vers les primitifs Conversion 5 : Primitifs vers String Conversion 6 : Les primitifs vers une String en utilisant la mÃ©thode valueOf() Automatique vs manuelle Conversion automatique : il sâ€™agit dâ€™une conversion dâ€™un type plus petit en un type plus grand\nbyte -\u003e short -\u003e char -\u003e int -\u003e long -\u003e float -\u003e double\nCas 2 Conversion manuelle :\nil sâ€™agit de la conversion dâ€™un type plus grand en un type de taille plus petite. Il suffit de rajouter le casting du type voulu Ã  droite.\ndouble -\u003e float -\u003e long -\u003e int -\u003e char -\u003e short -\u003e byte double d = 2000.23; float f = (float)d; long l = (long) f;\nQuand on diminue la taille il y a parfois une perte dâ€™information comme si lâ€™on passe de float Ã  int:\nfloat a = 4.53F; System.out.println((int) a); //4 Pour rÃ©sumer : Dans le cas dâ€™une conversion de petit vers grand â” on ne fait rien. Dans le cas dâ€™une conversion dâ€™un grand vers un petit â” il faut Â« Caster Â» la partie droite en type du petit.",
    "description": "ğŸ¯ Quâ€™est-ce quâ€™une variable? Une variable, câ€™est comme un casier dans votre vestiaire du cÃ©gep. Vous pouvez y mettre vos affaires, les changer, les oublier (oups), et mÃªme y mettre nâ€™importe quoi (tant que Ã§a rentre et que câ€™est du bon type).\nLâ€™identificateur (Le nom) : Câ€™est lâ€™Ã©tiquette sur le casier (ex: 304). Câ€™est ce qui permet au programme de retrouver lâ€™endroit exact en mÃ©moire.",
    "tags": [],
    "title": "Variables",
    "uri": "/420-210/variables/index.html"
  },
  {
    "breadcrumb": "Programmation orientÃ©e objet",
    "content": "OpÃ©rateurs ArithmÃ©tiques en Java OpÃ©rateur Nom Description Exemple RÃ©sultat + Addition Somme de deux valeurs int x = 10 + 5; 15 - Soustraction DiffÃ©rence entre deux valeurs int x = 20 - 8; 12 * Multiplication Produit de deux valeurs double x = 5.5 * 2; 11.0 / Division Quotient de la division int x = 10 / 3; 3 (Entier) % Modulo Reste de la division entiÃ¨re int x = 10 % 3; 1 OpÃ©rateurs dâ€™incrÃ©mentation et de dÃ©crÃ©mentation OpÃ©rateur Nom Position Description Exemple RÃ©sultat (x) ++x PrÃ©-incrÃ©mentation Avant IncrÃ©mente, puis retourne la valeur int y = ++x; AugmentÃ© de 1 x++ Post-incrÃ©mentation AprÃ¨s Retourne la valeur, puis incrÃ©mente int y = x++; AugmentÃ© de 1 --x PrÃ©-dÃ©crÃ©mentation Avant DÃ©crÃ©mente, puis retourne la valeur int y = --x; DiminuÃ© de 1 x-- Post-dÃ©crÃ©mentation AprÃ¨s Retourne la valeur, puis dÃ©crÃ©mente int y = x--; DiminuÃ© de 1 Pourquoi la position est-elle importante ? La diffÃ©rence rÃ©side dans la valeur retournÃ©e par lâ€™expression au moment de lâ€™exÃ©cution :\nPrÃ© (++x) : Mise Ã  jour dâ€™abord, puis utilisation immÃ©diate. Post (x++) : Utilisation de la valeur actuelle, puis mise Ã  jour juste aprÃ¨s. Exemple de comparaison : int a = 10; int b = 10; int resultatA = ++a; // a devient 11, puis resultatA reÃ§oit 11 int resultatB = b++; // resultatB reÃ§oit 10, puis b devient 11 // Ã€ la fin : // a est 11, resultatA est 11 // b est 11, resultatB est 10 OpÃ©rateurs Logiques en Java Les opÃ©rateurs logiques permettent de tester plusieurs conditions Ã  la fois et retournent toujours une valeur boolÃ©enne (true ou false).\nOpÃ©rateur Nom Description Exemple \u0026\u0026 ET (AND) Retourne true si toutes les conditions sont vraies (age \u003e= 18 \u0026\u0026 aPermis) || OU (OR) Retourne true si au moins une condition est vraie (estSamedi || estDimanche) ! NON (NOT) Inverse la valeur logique !estConnecte ^ OU exclusif (XOR) Retourne true si une seule condition est vraie (optionA ^ optionB) Tables de vÃ©ritÃ© (RÃ©sumÃ©) A B A \u0026\u0026 B A || B A ^ B !A true true true true false false true false false true true false false true false true true true false false false false false true Le concept de â€œCourt-circuitâ€ (Short-circuit) Les opÃ©rateurs \u0026\u0026 et || sont dits Ã  court-circuit en Java :\nAvec \u0026\u0026 : Si la premiÃ¨re condition est fausse, la seconde nâ€™est pas Ã©valuÃ©e. Avec || : Si la premiÃ¨re condition est vraie, Java sâ€™arrÃªte immÃ©diatement. Astuce : Placez toujours la condition la plus risquÃ©e ou coÃ»teuse en deuxiÃ¨me position.\nOpÃ©rateurs logiques : Court-circuit vs Ã‰valuation complÃ¨te Type ET OU Comportement Court-circuit \u0026\u0026 || Ã‰value la 2e condition uniquement si nÃ©cessaire Ã‰valuation complÃ¨te \u0026 | Ã‰value toujours les deux conditions Pourquoi utiliser lâ€™Ã©valuation complÃ¨te (\u0026 et |) ? Ces opÃ©rateurs sont utilisÃ©s lorsque la deuxiÃ¨me condition contient un effet de bord qui doit absolument Ãªtre exÃ©cutÃ© (incrÃ©mentation, appel de mÃ©thode, etc.).\nExemple de diffÃ©rence int compteur = 0; boolean conditionFausse = false; // Cas 1 : Court-circuit (\u0026\u0026) if (conditionFausse \u0026\u0026 ++compteur \u003e 0) { } System.out.println(compteur); // Affiche 0 // Cas 2 : Ã‰valuation complÃ¨te (\u0026) if (conditionFausse \u0026 ++compteur \u003e 0) { } System.out.println(compteur); // Affiche 1 OpÃ©rateurs de comparaison en Java Les opÃ©rateurs de comparaison permettent de vÃ©rifier la relation entre deux expressions.\nLe rÃ©sultat est toujours une valeur boolÃ©enne (true ou false).\nOpÃ©rateur Nom Description Exemple RÃ©sultat == Ã‰galitÃ© true si les valeurs primitives sont identiques 5 == 5 true != InÃ©galitÃ© true si les valeurs sont diffÃ©rentes 5 != 3 true \u003e Plus grand que true si la valeur de gauche est strictement supÃ©rieure 10 \u003e 5 true \u003c Plus petit que true si la valeur de gauche est strictement infÃ©rieure 2 \u003c 1 false \u003e= Plus grand ou Ã©gal true si la valeur de gauche est supÃ©rieure ou Ã©gale 5 \u003e= 5 true \u003c= Plus petit ou Ã©gal true si la valeur de gauche est infÃ©rieure ou Ã©gale 4 \u003c= 3 false Confusion entre = et == Erreur frÃ©quente chez les dÃ©butants :\n= est lâ€™opÃ©rateur dâ€™assignation. == est lâ€™opÃ©rateur de comparaison. Comparaison de chaÃ®nes de caractÃ¨res (String) en Java âš ï¸ En Java, lâ€™opÃ©rateur == compare les rÃ©fÃ©rences, pas le contenu des chaÃ®nes. Pour comparer les valeurs des chaines de caractÃ¨res, il faut utiliser la fonction equals ou sa version ``equalsIgnoreCase`\nString nomUn = \"Bob\"; String nomDeux = \"bob\"; boolean sontEgaux = nomUn.equals(nomDeux); // false (sensible Ã  la casse) boolean sontEgauxNonSensible = nomUn.equals(nomDeux); // true (ignore les casses)",
    "description": "OpÃ©rateurs ArithmÃ©tiques en Java OpÃ©rateur Nom Description Exemple RÃ©sultat + Addition Somme de deux valeurs int x = 10 + 5; 15 - Soustraction DiffÃ©rence entre deux valeurs int x = 20 - 8; 12 * Multiplication Produit de deux valeurs double x = 5.5 * 2; 11.0 / Division Quotient de la division int x = 10 / 3; 3 (Entier) % Modulo Reste de la division entiÃ¨re int x = 10 % 3; 1 OpÃ©rateurs dâ€™incrÃ©mentation et de dÃ©crÃ©mentation OpÃ©rateur Nom Position Description Exemple RÃ©sultat (x) ++x PrÃ©-incrÃ©mentation Avant IncrÃ©mente, puis retourne la valeur int y = ++x; AugmentÃ© de 1 x++ Post-incrÃ©mentation AprÃ¨s Retourne la valeur, puis incrÃ©mente int y = x++; AugmentÃ© de 1 --x PrÃ©-dÃ©crÃ©mentation Avant DÃ©crÃ©mente, puis retourne la valeur int y = --x; DiminuÃ© de 1 x-- Post-dÃ©crÃ©mentation AprÃ¨s Retourne la valeur, puis dÃ©crÃ©mente int y = x--; DiminuÃ© de 1 Pourquoi la position est-elle importante ? La diffÃ©rence rÃ©side dans la valeur retournÃ©e par lâ€™expression au moment de lâ€™exÃ©cution :",
    "tags": [],
    "title": "OpÃ©rateurs",
    "uri": "/420-210/operateurs/index.html"
  },
  {
    "breadcrumb": "Programmation orientÃ©e objet",
    "content": "Les structures de contrÃ´le en Java Introduction Jusquâ€™Ã  prÃ©sent, vos programmes sâ€™exÃ©cutaient ligne par ligne, de haut en bas, comme une recette suivie Ã  la lettre.\nLes structures de contrÃ´le permettent de prendre des dÃ©cisions et de rÃ©pÃ©ter des actions.\nğŸ‘‰ GrÃ¢ce Ã  elles, un programme devient intelligent, dynamique et utile dans la vraie vie.\nOn distingue trois grandes familles :\nLes structures conditionnelles (faire un choix) Les structures rÃ©pÃ©titives (rÃ©pÃ©ter une action) Les structures de contrÃ´le de flux (modifier le dÃ©roulement) 1. Les structures conditionnelles Les structures conditionnelles permettent dâ€™exÃ©cuter du code seulement si une condition est vraie.\n1.1 La structure if Syntaxe if (condition) { // instructions exÃ©cutÃ©es si la condition est vraie } RÃ¨gle importante :\nLa condition doit toujours Ãªtre une expression boolÃ©enne, câ€™est-Ã -dire une expression qui retourne true ou false.\n1.1 La structure if Syntaxe if (condition) { // instructions exÃ©cutÃ©es si la condition est vraie } La condition est Ã©valuÃ©e :\nsi elle est true, le bloc est exÃ©cutÃ©\nsi elle est false, le bloc est ignorÃ©\nExemple int age = 18; if (age \u003e= 18) { System.out.println(\"AccÃ¨s autorisÃ©\"); } 1.2 La structure if / else Permet de choisir entre deux chemins possibles.\nSyntaxe if (condition) { // exÃ©cutÃ© si la condition est vraie } else { // exÃ©cutÃ© si la condition est fausse } Exemple int temperature = 15; if (temperature \u003e= 20) { System.out.println(\"Il fait chaud\"); } else { System.out.println(\"Il fait frais\"); } Un seul des deux blocs sera exÃ©cutÃ©.\nâ“ Lâ€™opÃ©rateur ternaire en Java Lâ€™opÃ©rateur ternaire est une forme abrÃ©gÃ©e du if...else, qui permet dâ€™Ã©crire des conditions simples en une seule ligne.\nIl est souvent utilisÃ© pour rendre le code plus concis, surtout lorsquâ€™on veut affecter une valeur selon une condition.\nğŸ§° Syntaxe de base (condition) ? valeurSiVrai : valeurSiFaux; Câ€™est comme dire : â€œSi la condition est vraie, retourne ceci ; sinon, retourne cela.â€\nğŸ“¦ Exemple simple int Ã¢ge = 20; String statut = (Ã¢ge \u003e= 18) ? \"Majeur\" : \"Mineur\"; System.out.println(statut); // Affiche : Majeur âœ³ï¸ Câ€™est Ã©quivalent Ã  :\nString statut; if (Ã¢ge \u003e= 18) { statut = \"Majeur\"; } else { statut = \"Mineur\"; } âš™ï¸ Utilisation typique Lâ€™opÃ©rateur ternaire est trÃ¨s utilisÃ© pour affecter une valeur selon une condition :\ndouble note = 85; String rÃ©sultat = (note \u003e= 60) ? \"RÃ©ussi\" : \"Ã‰chouÃ©\"; On peut aussi lâ€™utiliser directement dans un System.out.println() :\nSystem.out.println((note \u003e= 90) ? \"Excellent\" : \"Ã€ amÃ©liorer\"); ğŸ›‘ Ã€ Ã©viter pour les cas complexes MÃªme si lâ€™opÃ©rateur ternaire est pratique, il devient illisible si la condition ou les valeurs sont longues :\n// Trop compliquÃ© ! String grade = (score \u003e= 90) ? \"A\" : (score \u003e= 75) ? \"B\" : \"C\"; // ğŸ¤¯ Difficile Ã  lire et Ã  maintenir â¡ï¸ Dans ces cas-lÃ , prÃ©fÃ¨re une structure if...else classique.\nğŸ”¥ Ã€ retenir Lâ€™opÃ©rateur ternaire est une forme courte de if...else. Il sâ€™Ã©crit : (condition) ? valeurSiVrai : valeurSiFaux; TrÃ¨s utile pour initialiser une variable selon une condition. Ã€ Ã©viter si la logique devient trop complexe ou trop imbriquÃ©e. Rends le code plus compact, mais pas toujours plus clair. 1.3 La structure if / else if / else UtilisÃ©e lorsquâ€™il y a plusieurs choix possibles.\nSyntaxe if (condition1) { // cas 1 } else if (condition2) { // cas 2 } else { // cas par dÃ©faut } Exemple int note = 72; if (note \u003e= 90) { System.out.println(\"Excellent\"); } else if (note \u003e= 60) { System.out.println(\"RÃ©ussi\"); } else { System.out.println(\"Ã‰chec\"); } Les conditions sont testÃ©es dans lâ€™ordre, et Java sâ€™arrÃªte dÃ¨s quâ€™une condition est vraie.\n1.4 Erreurs frÃ©quentes avec les conditions Confusion entre = et ==\nif (x = 5) { } // ERREUR if (x == 5) { } // CORRECT Oubli des accolades\nif (x \u003e 0) System.out.println(\"Positif\"); System.out.println(\"Fin\"); Dans ce cas, â€œFinâ€ sâ€™affiche toujours.\nğŸ›ï¸ Les instructions switch en Java Lâ€™instruction switch permet de tester la valeur dâ€™une variable et dâ€™exÃ©cuter diffÃ©rents blocs de code selon son contenu exact.\nCâ€™est une alternative plus claire aux chaÃ®nes de if...else if quand on compare une mÃªme variable Ã  plusieurs valeurs possibles.\nğŸ§° Syntaxe de base switch (variable) { case valeur1: // Code si variable == valeur1 break; case valeur2: // Code si variable == valeur2 break; default: // Code si aucune des valeurs ne correspond } ğŸ§± Ã‰lÃ©ments clÃ©s : Mot-clÃ© RÃ´le case SpÃ©cifie une valeur Ã  tester break Termine le switch, Ã©vite les â€œchutesâ€ default (optionnel) Bloc exÃ©cutÃ© par dÃ©faut ğŸ“¦ Exemple simple int jour = 3; switch (jour) { case 1: System.out.println(\"Lundi\"); break; case 2: System.out.println(\"Mardi\"); break; case 3: System.out.println(\"Mercredi\"); break; default: System.out.println(\"Jour inconnu\"); } â¡ï¸ Affichera : Mercredi\nâš ï¸ Le break est important ! Sans le break, le programme continue dans les cases suivantes, mÃªme si elles ne correspondent pas :\nint x = 2; switch (x) { case 1: System.out.println(\"Un\"); case 2: System.out.println(\"Deux\"); case 3: System.out.println(\"Trois\"); } â¡ï¸ Affichera :\nDeux Trois ğŸ§  Le bloc default Le mot-clÃ© default permet de gÃ©rer les cas non prÃ©vus :\nchar lettre = 'z'; switch (lettre) { case 'a': System.out.println(\"Voyelle A\"); break; case 'e': System.out.println(\"Voyelle E\"); break; default: System.out.println(\"Autre lettre\"); } ğŸ” CompatibilitÃ© du switch En Java, tu peux utiliser switch avec les types suivants :\nType autorisÃ© Exemples int, short, byte, char switch (entier) String (depuis Java 7) switch (nom) enum switch (couleur) âŒ Pas compatible avec float, double, boolean, ni avec des expressions complexes.\nğŸ”¥ Ã€ retenir switch est pratique pour tester des cas prÃ©cis. Utilise break pour Ã©viter les exÃ©cutions non dÃ©sirÃ©es. Le bloc default est optionnel mais utile. Compatible avec int, char, String, enum, etc. Plus lisible que plusieurs else if quand on compare la mÃªme variable. 2. Les structures rÃ©pÃ©titives (boucles) Les boucles permettent de rÃ©pÃ©ter un bloc de code tant quâ€™une condition est respectÃ©e.\n2.1 La boucle while La condition est testÃ©e avant chaque rÃ©pÃ©tition.\nSyntaxe while (condition) { // instructions rÃ©pÃ©tÃ©es } Exemple int compteur = 1; while (compteur \u003c= 5) { System.out.println(compteur); compteur++; } 2.2 La boucle do / while Le bloc sâ€™exÃ©cute au moins une fois, puis la condition est testÃ©e.\nSyntaxe do { // instructions } while (condition); Exemple int choix; do { System.out.println(\"Menu affichÃ©\"); choix = 0; } while (choix != 0); 2.3 La boucle for UtilisÃ©e lorsque le nombre de rÃ©pÃ©titions est connu Ã  lâ€™avance.\nSyntaxe for (initialisation; condition; incrÃ©mentation) { // instructions } Exemple for (int i = 0; i \u003c 5; i++) { System.out.println(i); } 2.4 Comparaison des boucles Boucle Utilisation recommandÃ©e while Nombre de rÃ©pÃ©titions inconnu do/while Au moins une exÃ©cution nÃ©cessaire for Nombre de rÃ©pÃ©titions connu 3. Les structures de contrÃ´le du flux 3.1 Lâ€™instruction break Permet de sortir immÃ©diatement dâ€™une boucle.\nfor (int i = 1; i \u003c= 10; i++) { if (i == 5) { break; } System.out.println(i); } 3.2 Lâ€™instruction continue Permet de passer directement Ã  lâ€™itÃ©ration suivante.\nfor (int i = 1; i \u003c= 5; i++) { if (i == 3) { continue; } System.out.println(i); }",
    "description": "Les structures de contrÃ´le en Java Introduction Jusquâ€™Ã  prÃ©sent, vos programmes sâ€™exÃ©cutaient ligne par ligne, de haut en bas, comme une recette suivie Ã  la lettre.\nLes structures de contrÃ´le permettent de prendre des dÃ©cisions et de rÃ©pÃ©ter des actions.\nğŸ‘‰ GrÃ¢ce Ã  elles, un programme devient intelligent, dynamique et utile dans la vraie vie.",
    "tags": [],
    "title": "Structures de contrÃ´le",
    "uri": "/420-210/structures/index.html"
  },
  {
    "breadcrumb": "Programmation orientÃ©e objet",
    "content": "ğŸ› ï¸ Les MÃ©thodes en Java : Segmenter pour mieux rÃ©gner En programmation, une mÃ©thode est un bloc de code nommÃ© qui contient une sÃ©quence dâ€™instructions. Au lieu dâ€™Ã©crire tout votre code dans le bloc principal (main), vous crÃ©ez des unitÃ©s de travail spÃ©cialisÃ©es que vous pouvez appeler au besoin.\nLâ€™analogie de la boÃ®te : Imaginez une mÃ©thode comme une boÃ®te fermÃ©e. Vous ne voyez pas forcÃ©ment lâ€™engrenage Ã  lâ€™intÃ©rieur, mais vous savez comment lâ€™utiliser en appuyant sur un bouton ou en y insÃ©rant des donnÃ©es.\n1. La boÃ®te dâ€™action simple (void sans paramÃ¨tre) Il sâ€™agit du type de mÃ©thode le plus Ã©lÃ©mentaire. Elle ne demande aucune information et ne renvoie aucune donnÃ©e. Elle exÃ©cute simplement une tÃ¢che prÃ©dÃ©finie.\nvoid : Ce mot-clÃ© signifie â€œvideâ€. Il indique que la mÃ©thode ne rend rien au programme. () : Les parenthÃ¨ses vides indiquent que la boÃ®te ne nÃ©cessite aucune donnÃ©e dâ€™entrÃ©e pour fonctionner. public static void afficherEntete() { System.out.println(\"******************************\"); System.out.println(\" BIENVENUE AU SYSTÃˆME \"); System.out.println(\"******************************\"); } 2. La boÃ®te avec instructions (void avec paramÃ¨tres) Cette mÃ©thode a besoin dâ€™informations pour fonctionner (des paramÃ¨tres), mais elle ne renvoie toujours pas de rÃ©sultat au programme. Elle utilise les entrÃ©es pour effectuer une action, comme un affichage personnalisÃ©.\nParamÃ¨tres : Ce sont les variables dÃ©clarÃ©es entre les parenthÃ¨ses. Elles servent de â€œfiches dâ€™instructionsâ€ pour la mÃ©thode. public static void saluerUtilisateur(String prenom, int age) { System.out.println(\"Bonjour \" + prenom + \" !\"); System.out.println(\"Vous avez \" + age + \" ans.\"); } 3. La boÃ®te de calcul (Avec paramÃ¨tres et retour) Câ€™est lâ€™analogie complÃ¨te de la machine distributrice :\nVous insÃ©rez des donnÃ©es (lâ€™argent) : ce sont les ParamÃ¨tres. La machine transforme lâ€™entrÃ©e : câ€™est le Traitement. Elle vous Ã©jecte un produit (le bonbon) : câ€™est le Retour. Type de retour : On remplace void par le type de la donnÃ©e qui sortira de la boÃ®te (ex: int, double, String). Instruction return : Câ€™est le mÃ©canisme qui permet dâ€™expulser la valeur finale hors de la mÃ©thode. public static double calculerTaxe(double montantBrut) { double taxe = montantBrut * 0.15; // Calcul de la taxe de 15% return taxe; // On Ã©jecte le rÃ©sultat vers l'appelant } 4. SynthÃ¨se : Quel type de boÃ®te choisir ? Pour dÃ©terminer la structure de votre mÃ©thode, vous devez vous poser deux questions fondamentales avant mÃªme de commencer Ã  coder.\nLe guide de dÃ©cision EntrÃ©e (ParamÃ¨tres) : Est-ce que ma machine a besoin de donnÃ©es extÃ©rieures pour fonctionner ? Sortie (Retour) : Est-ce que ma machine doit fournir une rÃ©ponse que je vais rÃ©utiliser plus tard dans mon code ? Tableau rÃ©capitulatif des structures Type de mÃ©thode Type de retour ParamÃ¨tres Analogie de la boÃ®te Action pure void Aucun () Le bouton â€œAlarmeâ€ : on appuie, le son sort, aucune information nâ€™est demandÃ©e. Action paramÃ©trÃ©e void PrÃ©sents Le haut-parleur : on lui donne un texte, il le diffuse, mais il ne nous redonne rien en main. Calculatrice int, double, etc. PrÃ©sents La machine distributrice : on insÃ¨re de lâ€™argent, la machine traite, et nous redonne un produit. ğŸ’¡ La rÃ¨gle dâ€™or : â€œUne tÃ¢che, une boÃ®teâ€ Une erreur frÃ©quente est de vouloir crÃ©er une boÃ®te qui fait trop de choses (ex: calculer, afficher, et sauvegarder).\nMauvaise pratique : Une mÃ©thode gÃ©ante difficile Ã  corriger. Bonne pratique : Plusieurs petites mÃ©thodes simples qui sâ€™appellent entre elles. Cela rend votre code modulaire et beaucoup plus facile Ã  dÃ©boguer pour vos travaux pratiques. 5. Exemples supplÃ©mentaires par mise en situation A. La boÃ®te â€œVÃ©rificatriceâ€ (Type boolean) Cette boÃ®te reÃ§oit une information et rÃ©pond simplement par Vrai ou Faux. Câ€™est trÃ¨s utile pour valider des conditions de jeu.\nEntrÃ©e : Lâ€™Ã¢ge de lâ€™utilisateur. Sortie : Un signal (Vrai/Faux) indiquant si lâ€™accÃ¨s est permis. public static boolean estMajeur(int age) { if (age \u003e= 18) { return true; } else { return false; } }",
    "description": "ğŸ› ï¸ Les MÃ©thodes en Java : Segmenter pour mieux rÃ©gner En programmation, une mÃ©thode est un bloc de code nommÃ© qui contient une sÃ©quence dâ€™instructions. Au lieu dâ€™Ã©crire tout votre code dans le bloc principal (main), vous crÃ©ez des unitÃ©s de travail spÃ©cialisÃ©es que vous pouvez appeler au besoin.\nLâ€™analogie de la boÃ®te : Imaginez une mÃ©thode comme une boÃ®te fermÃ©e. Vous ne voyez pas forcÃ©ment lâ€™engrenage Ã  lâ€™intÃ©rieur, mais vous savez comment lâ€™utiliser en appuyant sur un bouton ou en y insÃ©rant des donnÃ©es.",
    "tags": [],
    "title": "MÃ©thodes",
    "uri": "/420-210/methodes/index.html"
  },
  {
    "breadcrumb": "Programmation orientÃ©e objet",
    "content": "ğŸ“¦ Les tableaux 1D en Java Un tableau (array) permet de stocker plusieurs valeurs dans une mÃªme variable, toutes du mÃªme type (int, double, etc.).\nLes tableaux Ã  une dimension (1D) sont comme une liste ordonnÃ©e de valeurs, accessibles grÃ¢ce Ã  leur indice.\nğŸ—ï¸ DÃ©claration et crÃ©ation âœï¸ DÃ©clarer un tableau int[] notes; // dÃ©claration ğŸ› ï¸ CrÃ©er un tableau notes = new int[5]; // tableau de 5 entiers (tous Ã  0) Ou, prÃ©fÃ©rablement, tout en une ligne :\nint[] notes = new int[5]; ğŸ’¡ Tous les Ã©lÃ©ments sont automatiquement initialisÃ©s :\nType Valeur par dÃ©faut int 0 double 0.0 boolean false String null ğŸ§Š AccÃ¨s aux Ã©lÃ©ments Un tableau utilise des indices qui commencent Ã  0 !\nnotes[0] = 17; // affecte 17 au premier Ã©lÃ©ment System.out.println(notes[0]); // affiche 17 ğŸ’¥ AccÃ©der Ã  un indice hors-limites provoque une erreur :\nnotes[5] = 20; // âŒ Erreur : IndexOutOfBoundsException ğŸª Initialisation rapide On peut directement donner des valeurs au moment de la crÃ©ation :\nint[] jours = {31, 28, 31, 30, 31, 30}; ğŸ“ La propriÃ©tÃ© .length Chaque tableau possÃ¨de une propriÃ©tÃ© spÃ©ciale :\nint taille = notes.length; // ici : 5 â— Ce nâ€™est pas une mÃ©thode (pas de parenthÃ¨ses !)\nğŸ§ª Exemples simples int[] valeurs = {10, 20, 30}; System.out.println(valeurs[1]); // 20 System.out.println(valeurs.length); // 3 valeurs[2] = 40; System.out.println(valeurs[2]); // 40 ğŸ§  Ã€ retenir Un tableau stocke plusieurs valeurs du mÃªme type. Les indices commencent Ã  0. .length donne le nombre dâ€™Ã©lÃ©ments du tableau. Ne jamais dÃ©passer les bornes du tableau !",
    "description": "ğŸ“¦ Les tableaux 1D en Java Un tableau (array) permet de stocker plusieurs valeurs dans une mÃªme variable, toutes du mÃªme type (int, double, etc.).\nLes tableaux Ã  une dimension (1D) sont comme une liste ordonnÃ©e de valeurs, accessibles grÃ¢ce Ã  leur indice.\nğŸ—ï¸ DÃ©claration et crÃ©ation âœï¸ DÃ©clarer un tableau int[] notes; // dÃ©claration ğŸ› ï¸ CrÃ©er un tableau notes = new int[5]; // tableau de 5 entiers (tous Ã  0) Ou, prÃ©fÃ©rablement, tout en une ligne :",
    "tags": [],
    "title": "Tableaux",
    "uri": "/420-210/tableaux/index.html"
  },
  {
    "breadcrumb": "Programmation orientÃ©e objet",
    "content": "Exercices de rÃ©vision ğŸ® Projet 1 : SystÃ¨me de Gestion de Notes Scolaires ğŸ“‹ Contexte Vous devez crÃ©er un systÃ¨me pour gÃ©rer et analyser les notes dâ€™une classe dâ€™Ã©tudiants. Le systÃ¨me permettra de calculer des statistiques, dâ€™attribuer des mentions et de gÃ©nÃ©rer des rapports.\nğŸ¯ Objectifs pÃ©dagogiques Manipulation de tableaux Calculs statistiques (moyenne, min, max) Structures conditionnelles pour la classification Boucles pour parcourir des donnÃ©es MÃ©thodes avec paramÃ¨tres et valeurs de retour ğŸ“ Instructions CrÃ©ez une classe GestionNotes avec les mÃ©thodes suivantes :\n1. MÃ©thode calculerMoyenne But : Calculer la moyenne arithmÃ©tique dâ€™un tableau de notes.\nParamÃ¨tres :\nnotes : un tableau de double contenant les notes Retour : La moyenne sous forme de double\nAlgorithme :\nParcourir toutes les notes du tableau Additionner toutes les notes Diviser la somme par le nombre de notes Retourner le rÃ©sultat Exemple : Pour les notes [15.5, 12.0, 18.0], la moyenne est (15.5 + 12.0 + 18.0) / 3 = 15.17\n2. MÃ©thode trouverMaximum But : Trouver la note la plus Ã©levÃ©e dans le tableau.\nParamÃ¨tres :\nnotes : un tableau de double Retour : La note maximale (double)\nAlgorithme :\nInitialiser une variable avec la premiÃ¨re note Parcourir toutes les autres notes Si une note est supÃ©rieure au maximum actuel, la remplacer Retourner le maximum trouvÃ© 3. MÃ©thode trouverMinimum But : Trouver la note la plus basse dans le tableau.\nParamÃ¨tres :\nnotes : un tableau de double Retour : La note minimale (double)\nAlgorithme : Similaire Ã  trouverMaximum, mais en cherchant la plus petite valeur.\n4. MÃ©thode compterReussites But : Compter combien dâ€™Ã©tudiants ont une note supÃ©rieure ou Ã©gale Ã  10 (seuil de rÃ©ussite).\nParamÃ¨tres :\nnotes : un tableau de double Retour : Le nombre dâ€™Ã©tudiants ayant rÃ©ussi (int)\nAlgorithme :\nInitialiser un compteur Ã  0 Parcourir toutes les notes Pour chaque note \u003e= 10, incrÃ©menter le compteur Retourner le compteur 5. MÃ©thode obtenirMention But : DÃ©terminer la mention obtenue selon la moyenne dâ€™un Ã©tudiant.\nParamÃ¨tres :\nmoyenne : la moyenne de lâ€™Ã©tudiant (double) Retour : Une chaÃ®ne de caractÃ¨res (String) reprÃ©sentant la mention\nRÃ¨gles de mentions :\nmoyenne \u003e= 16 : â€œTrÃ¨s Bienâ€ moyenne \u003e= 14 : â€œBienâ€ moyenne \u003e= 12 : â€œAssez Bienâ€ moyenne \u003e= 10 : â€œPassableâ€ moyenne \u003c 10 : â€œÃ‰checâ€ Algorithme :\nUtiliser une sÃ©rie de conditions if/else if/else Comparer la moyenne aux seuils (du plus Ã©levÃ© au plus bas) Retourner la mention correspondante 6. MÃ©thode afficherRapport But : GÃ©nÃ©rer et afficher un rapport complet des statistiques de la classe.\nParamÃ¨tres :\nnotes : un tableau de double Retour : void (la mÃ©thode affiche directement Ã  lâ€™Ã©cran)\nInformations Ã  afficher :\nNombre total dâ€™Ã©tudiants (taille du tableau) Moyenne gÃ©nÃ©rale de la classe (utiliser calculerMoyenne) Note maximale et minimale (utiliser les mÃ©thodes correspondantes) Taux de rÃ©ussite en pourcentage : (nombre de rÃ©ussites / total) Ã— 100 Distribution des mentions : Compter combien dâ€™Ã©tudiants ont chaque mention Pour cela, parcourir toutes les notes, calculer la mention de chaque note, et compter Format dâ€™affichage attendu :\n===== RAPPORT DE NOTES ===== Nombre d'Ã©tudiants : 10 Moyenne gÃ©nÃ©rale : 12.60 Note maximale : 18.00 Note minimale : 7.50 Taux de rÃ©ussite : 70.00% Distribution des mentions : - TrÃ¨s Bien : 2 - Bien : 2 - Assez Bien : 2 - Passable : 1 - Ã‰chec : 3 7. MÃ©thode main But : Tester toutes les fonctionnalitÃ©s du systÃ¨me.\nInstructions :\nCrÃ©er un tableau de notes de test : {15.5, 8.0, 12.5, 18.0, 9.5, 14.0, 16.5, 11.0, 7.5, 13.5} Appeler la mÃ©thode afficherRapport avec ce tableau Tester Ã©galement les mÃ©thodes individuellement pour vÃ©rifier leur bon fonctionnement âœ… CritÃ¨res de validation Toutes les mÃ©thodes sont crÃ©Ã©es avec les bons paramÃ¨tres et types de retour La moyenne est calculÃ©e correctement Le maximum et minimum sont trouvÃ©s correctement Le comptage des rÃ©ussites fonctionne Les mentions sont attribuÃ©es selon les bons seuils Le rapport affiche toutes les informations demandÃ©es Le code est lisible avec des noms de variables significatifs ğŸ’¡ Conseils Testez chaque mÃ©thode individuellement avant de crÃ©er le rapport complet Utilisez System.out.printf(\"%.2f\", nombre) pour formater les nombres avec 2 dÃ©cimales Pour calculer un pourcentage : (partieDouble / totalDouble) * 100.0 ğŸ’° Projet 2 : Calculateur de Salaire et ImpÃ´ts ğŸ“‹ Contexte DÃ©veloppez un systÃ¨me de calcul de salaire net avec diffÃ©rentes dÃ©ductions, heures supplÃ©mentaires, bonus et impÃ´ts. Ce systÃ¨me doit gÃ©nÃ©rer une fiche de paie complÃ¨te.\nğŸ¯ Objectifs pÃ©dagogiques Calculs arithmÃ©tiques complexes Conditions imbriquÃ©es pour les tranches dâ€™imposition Formules mathÃ©matiques appliquÃ©es Organisation de code en mÃ©thodes rÃ©utilisables ğŸ“ Instructions CrÃ©ez une classe CalculateurSalaire avec les mÃ©thodes suivantes :\n1. MÃ©thode calculerSalaireBrut But : Calculer le salaire brut mensuel en prenant en compte les heures supplÃ©mentaires.\nParamÃ¨tres :\ntauxHoraire : taux horaire en euros (double) heuresTravaillees : nombre dâ€™heures travaillÃ©es dans le mois (int) Retour : Le salaire brut (double)\nRÃ¨gles :\nLe nombre dâ€™heures normales par mois est 151.67 heures Les heures au-delÃ  sont des heures supplÃ©mentaires Les heures supplÃ©mentaires sont payÃ©es avec un bonus de 25% Algorithme :\nSi heuresTravaillees \u003c= 151.67 : salaire = tauxHoraire Ã— heuresTravaillees Sinon : Calculer le salaire des heures normales : 151.67 Ã— tauxHoraire Calculer les heures supplÃ©mentaires : heuresTravaillees - 151.67 Calculer le salaire des heures sup : heuresSup Ã— tauxHoraire Ã— 1.25 Additionner les deux montants Exemple : Si tauxHoraire = 15$ et heures = 170\nHeures normales : 151.67 Ã— 15 = 2275.05$ Heures supplÃ©mentaires : 18.33 Ã— 15 Ã— 1.25 = 343.69$ Total brut : 2618.74$ 2. MÃ©thode calculerCotisations But : Calculer le montant des cotisations sociales.\nParamÃ¨tres :\nsalaireBrut : salaire brut mensuel (double) Retour : Montant des cotisations (double)\nRÃ¨gle : Les cotisations reprÃ©sentent 22% du salaire brut\nFormule : salaireBrut * 0.22\n3. MÃ©thode calculerImpot But : Calculer lâ€™impÃ´t sur le revenu annuel selon le systÃ¨me de tranches progressives.\nParamÃ¨tres :\nsalaireAnnuelNet : salaire net annuel aprÃ¨s cotisations (double) Retour : Montant total de lâ€™impÃ´t annuel (double)\nTranches dâ€™imposition :\n0 Ã  10 000$ : 0% 10 001$ Ã  25 000$ : 11% 25 001$ Ã  50 000$ : 30% Au-delÃ  de 50 000$ : 41% Algorithme (systÃ¨me de tranches) :\nLâ€™impÃ´t se calcule tranche par tranche Exemple pour un salaire de 30 000$ : Tranche 1 (0-10000) : 10000 Ã— 0% = 0$ Tranche 2 (10001-25000) : 15000 Ã— 11% = 1650$ Tranche 3 (25001-30000) : 5000 Ã— 30% = 1500$ Total impÃ´t : 3150$ Pseudo-code :\nimpot = 0 reste = salaireAnnuelNet Si reste \u003e 10000: impot += (min(reste, 25000) - 10000) Ã— 0.11 Si reste \u003e 25000: impot += (min(reste, 50000) - 25000) Ã— 0.30 Si reste \u003e 50000: impot += (reste - 50000) Ã— 0.41 4. MÃ©thode calculerBonus But : Calculer le bonus annuel selon lâ€™anciennetÃ© et la performance.\nParamÃ¨tres :\nsalaireBrut : salaire brut mensuel (double) anciennete : annÃ©es dâ€™anciennetÃ© (int) performance : note de performance de 0 Ã  10 (int) Retour : Montant du bonus mensuel (double)\nRÃ¨gles :\nSi performance \u003c 7 : aucun bonus (retourner 0) Si performance \u003e= 7 : Bonus de base : 5% du salaire brut Bonus dâ€™anciennetÃ© : +1% par annÃ©e dâ€™anciennetÃ© (maximum +10%) Le bonus total ne peut pas dÃ©passer 15% du salaire brut Exemple :\nSalaire brut = 2000$, anciennetÃ© = 8 ans, performance = 8 Bonus de base : 2000 Ã— 5% = 100$ Bonus anciennetÃ© : 2000 Ã— 8% = 160$ (limitÃ© Ã  10% = 200$) Total bonus : 100 + 160 = 260$ 5. MÃ©thode genererFichePaie But : GÃ©nÃ©rer et afficher une fiche de paie complÃ¨te.\nParamÃ¨tres :\nnom : nom de lâ€™employÃ© (String) tauxHoraire : taux horaire (double) heuresTravaillees : heures travaillÃ©es (int) anciennete : annÃ©es dâ€™anciennetÃ© (int) performance : note de performance (int) Retour : void\nCalculs Ã  effectuer et afficher :\nCalculer le salaire brut (utiliser calculerSalaireBrut) Calculer le nombre dâ€™heures supplÃ©mentaires : max(0, heuresTravaillees - 151.67) Calculer les cotisations (utiliser calculerCotisations) Calculer le salaire net avant impÃ´t : salaireBrut - cotisations Calculer le bonus mensuel (utiliser calculerBonus) Calculer le salaire annuel net : (salaire net + bonus) Ã— 12 Calculer lâ€™impÃ´t annuel estimÃ© (utiliser calculerImpot) Calculer lâ€™impÃ´t mensuel : impÃ´t annuel / 12 Calculer le salaire net mensuel final : salaire net + bonus - impÃ´t mensuel Format dâ€™affichage :\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•— â•‘ FICHE DE PAIE â•‘ â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• EmployÃ© : Jean Dupont PÃ©riode : Janvier 2026 --- DÃ‰TAILS DES HEURES --- Heures travaillÃ©es : 170h Heures supplÃ©mentaires : 18.33h Taux horaire : 15.50$ --- CALCUL DU SALAIRE --- Salaire brut : 2618.74$ Cotisations sociales (22%) : 576.12$ Salaire net avant impÃ´t : 2042.62$ Bonus de performance : 131.00$ Salaire net avant impÃ´t : 2173.62$ --- IMPÃ”TS (estimation annuelle) --- Salaire annuel net : 26083.44$ ImpÃ´t annuel estimÃ© : 1765.17$ ImpÃ´t mensuel : 147.10$ --- NET Ã€ PAYER --- Salaire net mensuel : 2026.52$ 6. MÃ©thode main But : Tester le systÃ¨me avec plusieurs cas.\nTests Ã  effectuer :\nCas 1 : EmployÃ© standard sans heures sup Cas 2 : EmployÃ© avec heures supplÃ©mentaires Cas 3 : EmployÃ© avec haute performance et anciennetÃ© Cas 4 : EmployÃ© avec basse performance (pas de bonus) âœ… CritÃ¨res de validation Les heures supplÃ©mentaires sont calculÃ©es avec le bon taux (25%) Les cotisations sont correctement appliquÃ©es (22%) Le systÃ¨me de tranches dâ€™imposition fonctionne correctement Le bonus est calculÃ© selon les rÃ¨gles (performance et anciennetÃ©) La fiche de paie affiche tous les Ã©lÃ©ments demandÃ©s Les montants sont arrondis Ã  2 dÃ©cimales ğŸ’¡ Conseils Testez chaque mÃ©thode sÃ©parÃ©ment avec des valeurs simples Utilisez System.out.printf(\"%.2f$%n\", montant) pour lâ€™affichage Faites attention aux conversions int/double dans les calculs VÃ©rifiez les cas limites (0 heures sup, performance minimale, etc.) ğŸ² Projet 3 : Jeu de Devinette AvancÃ© ğŸ“‹ Contexte CrÃ©ez un jeu oÃ¹ lâ€™ordinateur gÃ©nÃ¨re un nombre alÃ©atoire et le joueur doit le deviner. Le jeu donne des indices de proximitÃ© et calcule un score selon la performance.\nğŸ¯ Objectifs pÃ©dagogiques Utilisation de la classe Random Boucles while pour le jeu Conditions multiples pour les indices Interaction avec lâ€™utilisateur (Scanner) Calcul de scores ğŸ“ Instructions CrÃ©ez une classe JeuDevinette avec les mÃ©thodes suivantes :\n1. MÃ©thode genererNombre But : GÃ©nÃ©rer un nombre alÃ©atoire dans un intervalle.\nParamÃ¨tres :\nmin : valeur minimale (int) max : valeur maximale (int) Retour : Nombre alÃ©atoire entre min et max inclus (int)\nAlgorithme :\nRandom random = new Random(); // GÃ©nÃ©rer un nombre entre 0 et (max-min) // Ajouter min pour obtenir un nombre entre min et max Formule : random.nextInt(max - min + 1) + min\n2. MÃ©thode calculerDifference But : Calculer la diffÃ©rence absolue entre deux nombres.\nParamÃ¨tres :\nnombre1 : premier nombre (int) nombre2 : deuxiÃ¨me nombre (int) Retour : DiffÃ©rence absolue (int)\nFormule : Math.abs(nombre1 - nombre2)\n3. MÃ©thode donnerIndice But : Fournir un indice textuel selon la proximitÃ© de la proposition.\nParamÃ¨tres :\nproposition : nombre proposÃ© par le joueur (int) secret : nombre Ã  deviner (int) Retour : Message dâ€™indice (String)\nRÃ¨gles :\nCalculer la diffÃ©rence avec calculerDifference Selon la diffÃ©rence : \u003c= 5 : â€œğŸ”¥ BrÃ»lant ! Vous Ãªtes trÃ¨s proche !â€ \u003c= 10 : â€œâ™¨ï¸ Chaud ! Vous approchez !â€ \u003c= 20 : â€œğŸŒ¡ï¸ TiÃ¨deâ€¦ continuez dans cette directionâ€ 20 : â€œâ„ï¸ Froid ! Vous Ãªtes loinâ€\nBonus : Ajouter aussi si le nombre est trop grand ou trop petit :\nâ€œLe nombre secret est plus petitâ€ â€œLe nombre secret est plus grandâ€ 4. MÃ©thode calculerScore But : Calculer le score final selon le nombre dâ€™essais et la difficultÃ©.\nParamÃ¨tres :\nnombreEssais : nombre de tentatives utilisÃ©es (int) difficulte : niveau choisi : â€œFacileâ€, â€œMoyenâ€ ou â€œDifficileâ€ (String) Retour : Score (entre 0 et 1000+) (int)\nFormule de base : 1000 - (nombreEssais Ã— 50)\nMultiplicateurs de difficultÃ© :\nâ€œFacileâ€ : Ã—1 (pas de bonus) â€œMoyenâ€ : Ã—1.5 â€œDifficileâ€ : Ã—2 Score minimum : 0 (ne peut pas Ãªtre nÃ©gatif)\nExemple :\n8 essais en mode Difficile Score de base : 1000 - (8 Ã— 50) = 600 Avec multiplicateur Ã—2 : 600 Ã— 2 = 1200 Algorithme :\nscoreBase = 1000 - (nombreEssais Ã— 50) Si scoreBase \u003c 0 alors scoreBase = 0 Selon difficulte: \"Facile\" : multiplicateur = 1.0 \"Moyen\" : multiplicateur = 1.5 \"Difficile\" : multiplicateur = 2.0 scoreFinal = scoreBase Ã— multiplicateur 5. MÃ©thode jouerPartie But : GÃ©rer une partie complÃ¨te du jeu.\nParamÃ¨tres :\ndifficulte : niveau choisi (â€œFacileâ€, â€œMoyenâ€, â€œDifficileâ€) (String) Retour : Score obtenu (int)\nRÃ¨gles selon la difficultÃ© :\nFacile : nombre entre 1 et 50 Moyen : nombre entre 1 et 100 Difficile : nombre entre 1 et 200 Algorithme :\nDÃ©terminer min et max selon la difficultÃ©\nGÃ©nÃ©rer le nombre secret avec genererNombre\nInitialiser le compteur dâ€™essais Ã  0\nCrÃ©er un Scanner pour lire les entrÃ©es\nBoucle de jeu (tant que pas trouvÃ©) :\nIncrÃ©menter le compteur dâ€™essais\nAfficher â€œEssai #X - Entrez un nombre :â€\nLire la proposition du joueur\nSi proposition == secret :\nAfficher â€œğŸ‰ Bravo ! Vous avez trouvÃ© en X essais !â€ Sortir de la boucle Sinon :\nAppeler donnerIndice et afficher le message Continuer la boucle Calculer le score avec calculerScore\nAfficher â€œScore obtenu : X pointsâ€\nRetourner le score\n6. MÃ©thode afficherMenu But : Afficher le menu de sÃ©lection de difficultÃ©.\nRetour : void\nAffichage :\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•— â•‘ JEU DE DEVINETTE ğŸ² â•‘ â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• Choisissez votre difficultÃ© : 1. ğŸ˜Š Facile (1-50) 2. ğŸ¤” Moyen (1-100) 3. ğŸ˜ˆ Difficile (1-200) 4. ğŸšª Quitter Votre choix : 7. MÃ©thode main But : GÃ©rer le programme principal avec menu et statistiques.\nAlgorithme :\nInitialiser : - scoreTotal = 0 - nombreParties = 0 - Scanner scanner Boucle principale (continuer = true) : 1. Afficher le menu 2. Lire le choix du joueur 3. Selon le choix : - 1 : jouer en mode Facile - 2 : jouer en mode Moyen - 3 : jouer en mode Difficile - 4 : sortir de la boucle - Autre : afficher \"Choix invalide\" 4. Si une partie a Ã©tÃ© jouÃ©e : - Ajouter le score Ã  scoreTotal - IncrÃ©menter nombreParties - Demander \"Voulez-vous rejouer ? (o/n)\" - Lire la rÃ©ponse - Si \"n\" : continuer = false AprÃ¨s la boucle : Afficher les statistiques finales : - Nombre de parties jouÃ©es - Score total - Score moyen (si parties \u003e 0) - Meilleur type de partie jouÃ©e âœ… CritÃ¨res de validation Le nombre secret est bien gÃ©nÃ©rÃ© alÃ©atoirement Les indices de proximitÃ© sont corrects Le score est calculÃ© selon la formule avec multiplicateur Le jeu se termine quand le joueur trouve Les statistiques finales sont correctes Le menu fonctionne avec tous les choix Le joueur peut rejouer ou quitter ğŸ’¡ Conseils Testez dâ€™abord avec un nombre fixe au lieu dâ€™alÃ©atoire pour dÃ©boguer Ajoutez des System.out.println pour suivre la progression GÃ©rez les cas oÃ¹ lâ€™utilisateur entre des lettres au lieu de nombres (try-catch) AmÃ©liorez lâ€™expÃ©rience avec des emojis et des couleurs ANSI ğŸ Extensions possibles Ajouter un nombre maximum de tentatives CrÃ©er un mode â€œduelâ€ (2 joueurs) Sauvegarder les meilleurs scores dans un fichier Ajouter un mode â€œExpertâ€ avec intervalle trÃ¨s large ğŸ“… Projet 4 : Calculateur de Dates ğŸ“‹ Contexte CrÃ©ez un systÃ¨me complet de manipulation de dates sans utiliser les classes Java de dates (LocalDate, etc.). Tout doit Ãªtre calculÃ© manuellement avec des algorithmes.\nğŸ¯ Objectifs pÃ©dagogiques Algorithmes mathÃ©matiques Conditions complexes imbriquÃ©es Manipulation de nombres Validation de donnÃ©es ğŸ“ Instructions CrÃ©ez une classe CalculateurDates avec les mÃ©thodes suivantes :\n1. MÃ©thode estBissextile But : DÃ©terminer si une annÃ©e est bissextile.\nParamÃ¨tres :\nannee : annÃ©e Ã  tester (int) Retour : true si bissextile, false sinon (boolean)\nRÃ¨gle officielle : Une annÃ©e est bissextile si :\nElle est divisible par 4 ET (non divisible par 100 OU divisible par 400) Exemples :\n2024 : divisible par 4 et pas par 100 â†’ bissextile 2000 : divisible par 400 â†’ bissextile 1900 : divisible par 100 mais pas par 400 â†’ non bissextile 2023 : pas divisible par 4 â†’ non bissextile Formule logique :\n(annee % 4 == 0) \u0026\u0026 ((annee % 100 != 0) || (annee % 400 == 0)) 2. MÃ©thode nombreJoursDansMois But : Retourner le nombre de jours dans un mois donnÃ©.\nParamÃ¨tres :\nmois : numÃ©ro du mois (1-12) (int) annee : annÃ©e (pour gÃ©rer fÃ©vrier) (int) Retour : Nombre de jours (int)\nRÃ¨gles :\nJanvier (1), Mars (3), Mai (5), Juillet (7), AoÃ»t (8), Octobre (10), DÃ©cembre (12) : 31 jours Avril (4), Juin (6), Septembre (9), Novembre (11) : 30 jours FÃ©vrier (2) : 28 jours (29 si annÃ©e bissextile) Algorithme :\nSi mois == 2: Si estBissextile(annee): retourner 29 Sinon: retourner 28 Si mois == 4 ou 6 ou 9 ou 11: retourner 30 Sinon: retourner 31 3. MÃ©thode dateValide But : VÃ©rifier si une date est valide.\nParamÃ¨tres :\njour : jour (1-31) (int) mois : mois (1-12) (int) annee : annÃ©e (int) Retour : true si valide, false sinon (boolean)\nVÃ©rifications :\nLe mois doit Ãªtre entre 1 et 12 Lâ€™annÃ©e doit Ãªtre positive (\u003e 0) Le jour doit Ãªtre entre 1 et le nombre de jours du mois (utiliser nombreJoursDansMois) Exemples :\n29/02/2024 : valide (annÃ©e bissextile) 29/02/2023 : invalide (pas bissextile) 31/04/2024 : invalide (avril a 30 jours) 15/13/2024 : invalide (mois 13 nâ€™existe pas) 4. MÃ©thode jourDeLannee But : Calculer le numÃ©ro du jour dans lâ€™annÃ©e (1-366).\nParamÃ¨tres :\njour, mois, annee : la date (int) Retour : NumÃ©ro du jour (1er janvier = 1) (int)\nAlgorithme :\nVÃ©rifier que la date est valide Initialiser total = 0 Pour chaque mois avant le mois actuel : Ajouter le nombre de jours de ce mois au total Ajouter le jour du mois actuel Retourner le total Exemple : 15 mars 2024\nJanvier : 31 jours FÃ©vrier : 29 jours (bissextile) Mars : 15 jours Total : 31 + 29 + 15 = 75Ã¨me jour de lâ€™annÃ©e 5. MÃ©thode jourDeLaSemaine But : DÃ©terminer quel jour de la semaine correspond Ã  une date.\nParamÃ¨tres :\njour, mois, annee : la date (int) Retour : Nom du jour (â€œLundiâ€, â€œMardiâ€, etc.) (String)\nAlgorithme simplifiÃ© (formule de Zeller modifiÃ©e) :\nPour simplifier, utilisez cette formule :\nSi mois \u003c 3: mois = mois + 12 annee = annee - 1 q = jour m = mois k = annee % 100 j = annee / 100 h = (q + (13*(m+1))/5 + k + k/4 + j/4 - 2*j) % 7 Convertir h en jour :\nh = 0 : Samedi h = 1 : Dimanche h = 2 : Lundi h = 3 : Mardi h = 4 : Mercredi h = 5 : Jeudi h = 6 : Vendredi Alternative plus simple : Vous pouvez aussi crÃ©er un tableau de rÃ©fÃ©rence avec des dates connues et calculer la diffÃ©rence en jours.\n6. MÃ©thode calculerAge But : Calculer lâ€™Ã¢ge exact dâ€™une personne.\nParamÃ¨tres :\njourNaissance, moisNaissance, anneeNaissance : date de naissance jourActuel, moisActuel, anneeActuel : date actuelle Retour : Ã‚ge en annÃ©es (int)\nAlgorithme :\nage = anneeActuel - anneeNaissance Si moisActuel \u003c moisNaissance: age = age - 1 Sinon si moisActuel == moisNaissance et jourActuel \u003c jourNaissance: age = age - 1 retourner age Exemple :\nNÃ© le 15/03/2000 Date actuelle : 28/01/2026 DiffÃ©rence dâ€™annÃ©es : 2026 - 2000 = 26 Mais le mois (01) est avant mars (03) â†’ encore 25 ans Ã‚ge : 25 ans 7. MÃ©thode determinerSaison But : DÃ©terminer la saison selon la date.\nParamÃ¨tres :\njour, mois : la date (sans lâ€™annÃ©e) (int) Retour : Nom de la saison (String)\nRÃ¨gles (hÃ©misphÃ¨re nord) :\nPrintemps : du 21 mars au 20 juin Ã‰tÃ© : du 21 juin au 20 septembre Automne : du 21 septembre au 20 dÃ©cembre Hiver : du 21 dÃ©cembre au 20 mars Algorithme :\nSi (mois == 3 et jour \u003e= 21) ou (mois == 4 ou 5) ou (mois == 6 et jour \u003c 21): retourner \"Printemps\" Si (mois == 6 et jour \u003e= 21) ou (mois == 7 ou 8) ou (mois == 9 et jour \u003c 21): retourner \"Ã‰tÃ©\" Si (mois == 9 et jour \u003e= 21) ou (mois == 10 ou 11) ou (mois == 12 et jour \u003c 21): retourner \"Automne\" Sinon: retourner \"Hiver\" 8. MÃ©thode differenceEnJours But : Calculer le nombre de jours entre deux dates.\nParamÃ¨tres :\nDate 1 : jour1, mois1, annee1 Date 2 : jour2, mois2, annee2 Retour : Nombre de jours de diffÃ©rence (int)\nAlgorithme (mÃ©thode simplifiÃ©e) :\nVÃ©rifier que les deux dates sont valides Convertir chaque date en â€œnombre de jours depuis une rÃ©fÃ©renceâ€ Par exemple, depuis lâ€™an 1 ou depuis lâ€™an 2000 Calculer la diffÃ©rence absolue Pour convertir une date en jours depuis lâ€™an 2000 :\njoursDepuis2000 = 0 Pour chaque annÃ©e de 2000 Ã  (annee - 1): Si bissextile: joursDepuis2000 += 366 Sinon: joursDepuis2000 += 365 joursDepuis2000 += jourDeLannee(jour, mois, annee) Faire ce calcul pour les deux dates Retourner la diffÃ©rence absolue 9. MÃ©thode afficherRapportDate But : Afficher un rapport complet dâ€™analyse dâ€™une date.\nParamÃ¨tres :\njour, mois, annee : la date Ã  analyser (int) Retour : void\nInformations Ã  afficher :\nLa date au format â€œDD/MM/YYYYâ€ Si la date est valide ou non Le jour de la semaine Le numÃ©ro du jour dans lâ€™annÃ©e La saison Si lâ€™annÃ©e est bissextile Nombre de jours restants dans lâ€™annÃ©e Nombre de jours dans le mois Combien de jours jusquâ€™Ã  la fin du mois Format attendu :\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•— â•‘ ANALYSE DE DATE COMPLÃˆTE â•‘ â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• Date : 15/08/2024 Jour de la semaine : Jeudi Jour de l'annÃ©e : 228/366 Saison : Ã‰tÃ© Informations sur l'annÃ©e : - AnnÃ©e bissextile : Oui - Jours restants : 138 Informations sur le mois : - AoÃ»t a 31 jours - Jours restants ce mois : 16 10. MÃ©thode main But : Tester toutes les fonctionnalitÃ©s.\nTests Ã  effectuer :\nAfficher le rapport pour plusieurs dates Tester calculerAge avec diffÃ©rentes dates de naissance Tester differenceEnJours entre deux dates Tester des dates invalides Tester des annÃ©es bissextiles et non-bissextiles âœ… CritÃ¨res de validation La dÃ©tection dâ€™annÃ©e bissextile fonctionne correctement Le nombre de jours par mois est correct (y compris fÃ©vrier) La validation de date dÃ©tecte toutes les erreurs Le calcul du jour de lâ€™annÃ©e est prÃ©cis Le jour de la semaine est correct Le calcul dâ€™Ã¢ge fonctionne mÃªme pour les dates limites La diffÃ©rence entre dates est exacte Les saisons sont correctement dÃ©terminÃ©es ğŸ’¡ Conseils Testez dâ€™abord les annÃ©es bissextiles : 2000, 2024, 1900, 2100 Testez fÃ©vrier : 28/02 et 29/02 pour annÃ©es bissextiles et non-bissextiles Testez des dates limites : 31/12, 1/1, 29/02 VÃ©rifiez les calculs avec un calendrier rÃ©el ğŸ Extensions possibles Ajouter la conversion entre calendriers (grÃ©gorien, julien) Calculer le nombre de jours ouvrables entre deux dates Trouver les dates de PÃ¢ques (algorithme de Gauss) Calculer les jours fÃ©riÃ©s ğŸ¦ Projet 5 : Simulateur de Compte Bancaire ğŸ“‹ Contexte DÃ©veloppez un systÃ¨me complet de simulation de compte bancaire avec transactions, dÃ©couvert, intÃ©rÃªts, frais et projections dâ€™Ã©pargne.\nğŸ¯ Objectifs pÃ©dagogiques Gestion dâ€™Ã©tat (solde) Validation de transactions Calculs financiers Simulation temporelle ğŸ“ Instructions CrÃ©ez une classe CompteBancaire avec les mÃ©thodes suivantes :\n1. MÃ©thode effectuerDepot But : Effectuer un dÃ©pÃ´t sur le compte.\nParamÃ¨tres :\nsoldeActuel : solde avant lâ€™opÃ©ration (double) montant : montant Ã  dÃ©poser (double) Retour : Nouveau solde aprÃ¨s dÃ©pÃ´t, ou -1 si invalide (double)\nRÃ¨gles de validation :\nLe montant doit Ãªtre strictement positif (\u003e 0) Si invalide, retourner -1 et ne pas modifier le solde Algorithme :\nSi montant \u003c= 0: Afficher \"Erreur : montant invalide\" Retourner -1 nouveauSolde = soldeActuel + montant Afficher \"DÃ©pÃ´t de X$ effectuÃ©. Nouveau solde : Y$\" Retourner nouveauSolde 2. MÃ©thode effectuerRetrait But : Effectuer un retrait avec gestion du dÃ©couvert.\nParamÃ¨tres :\nsoldeActuel : solde actuel (double) montant : montant Ã  retirer (double) decouvertAutorise : montant de dÃ©couvert maximum (double) Retour : Nouveau solde, ou -1 si impossible (double)\nRÃ¨gles :\nLe montant doit Ãªtre positif Le solde aprÃ¨s retrait doit rester \u003e= -decouvertAutorise Si impossible, retourner -1 Exemple :\nSolde actuel : 100$ DÃ©couvert autorisÃ© : 200$ Retrait possible jusquâ€™Ã  : 100 + 200 = 300$ Si retrait de 250$ : possible (nouveau solde = -150$) Si retrait de 350$ : impossible Algorithme :\nSi montant \u003c= 0: Retourner -1 nouveauSolde = soldeActuel - montant Si nouveauSolde \u003c -decouvertAutorise: Afficher \"Erreur : dÃ©couvert dÃ©passÃ©\" Retourner -1 Si nouveauSolde \u003c 0: Afficher \"Attention : vous Ãªtes Ã  dÃ©couvert\" Afficher \"Retrait de X$ effectuÃ©\" Retourner nouveauSolde 3. MÃ©thode calculerInterets But : Calculer les intÃ©rÃªts mensuels pour un solde crÃ©diteur.\nParamÃ¨tres :\nsolde : solde du compte (double) tauxAnnuel : taux dâ€™intÃ©rÃªt annuel en pourcentage (double) Retour : Montant des intÃ©rÃªts (double)\nRÃ¨gles :\nLes intÃ©rÃªts ne sont calculÃ©s que si le solde est positif Si solde \u003c= 0 : retourner 0 Formule mensuelle : solde Ã— (tauxAnnuel / 100) / 12 Exemple :\nSolde : 1000$ Taux annuel : 2% IntÃ©rÃªts mensuels : 1000 Ã— (2 / 100) / 12 = 1.67$ 4. MÃ©thode calculerFraisDecouvert But : Calculer les frais appliquÃ©s en cas de dÃ©couvert.\nParamÃ¨tres :\nsolde : solde actuel (double) Retour : Montant des frais (double)\nRÃ¨gle :\nSi solde \u003c 0 : frais de 8$ Sinon : 0$ Note : Dans une vraie banque, ce serait des frais par jour de dÃ©couvert, mais on simplifie ici.\n5. MÃ©thode determinerTypeCompte But : DÃ©terminer le type de compte selon le solde moyen.\nParamÃ¨tres :\nsoldeMoyen : solde moyen sur la pÃ©riode (double) Retour : Type de compte (String)\nClassification :\n= 5000$ : â€œPremiumâ€\n= 2000$ : â€œGoldâ€\n\u003c 2000$ : â€œStandardâ€ 6. MÃ©thode calculerFraisGestion But : Calculer les frais de gestion mensuels.\nParamÃ¨tres :\ntypeCompte : type du compte (String) nombreTransactions : nombre de transactions du mois (int) Retour : Montant des frais (double)\nGrille tarifaire :\nPremium :\nGratuit (toutes transactions) Gold :\nGratuit si \u003c= 20 transactions 5$ si \u003e 20 transactions Standard :\n10$ de frais de base 0,50$ par transaction au-delÃ  de 10 transactions gratuites Exemples :\nStandard avec 15 transactions : 10 + (5 Ã— 0.50) = 12.50$ Standard avec 8 transactions : 10$ Gold avec 25 transactions : 5$ Premium avec 100 transactions : 0$ 7. MÃ©thode virementPossible But : VÃ©rifier si un virement est rÃ©alisable.\nParamÃ¨tres :\nsoldeActuel : solde actuel (double) montant : montant du virement (double) decouvertAutorise : dÃ©couvert maximum (double) Retour : true si possible, false sinon (boolean)\nCondition : soldeActuel - montant \u003e= -decouvertAutorise\n8. MÃ©thode simulerMois But : Simuler un mois complet dâ€™opÃ©rations bancaires.\nParamÃ¨tres :\nsoldeInitial : solde au dÃ©but du mois (double) depots : tableau des dÃ©pÃ´ts du mois (double[]) retraits : tableau des retraits du mois (double[]) tauxInteret : taux annuel (double) decouvertAutorise : dÃ©couvert maximum (double) Retour : void (affiche les rÃ©sultats)\nAlgorithme :\n1. Initialiser : - solde = soldeInitial - nombreTransactions = 0 - sommePositions = 0 (pour calculer le solde moyen) - compteurJours = 30 2. Afficher l'en-tÃªte \"=== SIMULATION MENSUELLE ===\" \"Solde initial : X$\" 3. Traiter tous les dÃ©pÃ´ts : Pour chaque dÃ©pÃ´t dans le tableau : - nouveauSolde = effectuerDepot(solde, dÃ©pÃ´t) - Si valide : solde = nouveauSolde - nombreTransactions++ - sommePositions += solde 4. Traiter tous les retraits : Pour chaque retrait dans le tableau : - nouveauSolde = effectuerRetrait(solde, retrait, dÃ©couvert) - Si valide : solde = nouveauSolde - nombreTransactions++ - sommePositions += solde 5. Calculer le solde moyen : soldeMoyen = sommePositions / (nombreTransactions + 1) 6. DÃ©terminer le type de compte : typeCompte = determinerTypeCompte(soldeMoyen) 7. Appliquer intÃ©rÃªts ou frais de dÃ©couvert : Si solde \u003e 0 : - interets = calculerInterets(solde, tauxInteret) - solde += interets - Afficher \"IntÃ©rÃªts crÃ©diteurs : +X$\" Sinon : - frais = calculerFraisDecouvert(solde) - solde -= frais - Afficher \"Frais de dÃ©couvert : -X$\" 8. Appliquer les frais de gestion : fraisGestion = calculerFraisGestion(typeCompte, nombreTransactions) solde -= fraisGestion Afficher \"Frais de gestion : -X$\" 9. Afficher le rÃ©capitulatif : - Type de compte - Nombre de transactions - Solde moyen - Solde final Format d'affichage : \"\"\" === SIMULATION MENSUELLE === Solde initial : 1000.00$ --- OPÃ‰RATIONS DU MOIS --- DÃ©pÃ´t de 500.00$ effectuÃ©. Nouveau solde : 1500.00$ DÃ©pÃ´t de 300.00$ effectuÃ©. Nouveau solde : 1800.00$ ... Retrait de 150.00$ effectuÃ©. Nouveau solde : 1650.00$ ... --- FIN DE MOIS --- IntÃ©rÃªts crÃ©diteurs : +1.67$ Frais de gestion (Standard) : -10.00$ === RÃ‰CAPITULATIF === Type de compte : Standard Solde moyen du mois : 1450.00$ Nombre de transactions : 7 Solde final : 1641.67$ \"\"\" 9. MÃ©thode projeterEpargne But : Calculer le solde futur avec Ã©pargne rÃ©guliÃ¨re et intÃ©rÃªts composÃ©s.\nParamÃ¨tres :\nsoldeInitial : solde de dÃ©part (double) depotMensuel : montant Ã©pargnÃ© chaque mois (double) tauxInteret : taux annuel (double) nombreMois : durÃ©e de la projection (int) Retour : Solde projetÃ© (double)\nAlgorithme :\nsolde = soldeInitial Pour i de 1 Ã  nombreMois : 1. Ajouter le dÃ©pÃ´t mensuel : solde += depotMensuel 2. Calculer les intÃ©rÃªts du mois : interets = calculerInterets(solde, tauxInteret) solde += interets 3. (Optionnel) Afficher l'Ã©tat aprÃ¨s chaque mois : \"Mois X : +depotMensuel$ +interets$ â†’ solde$\" Retourner solde Exemple de calcul manuel :\nSolde initial : 1000$ DÃ©pÃ´t mensuel : 200$ Taux annuel : 2% DurÃ©e : 3 mois Mois 1 :\nSolde aprÃ¨s dÃ©pÃ´t : 1000 + 200 = 1200$ IntÃ©rÃªts : 1200 Ã— 0.02 / 12 = 2$ Nouveau solde : 1202$ Mois 2 :\nSolde aprÃ¨s dÃ©pÃ´t : 1202 + 200 = 1402$ IntÃ©rÃªts : 1402 Ã— 0.02 / 12 = 2.34$ Nouveau solde : 1404.34$ Et ainsi de suiteâ€¦\n10. MÃ©thode main But : Tester toutes les fonctionnalitÃ©s avec des scÃ©narios rÃ©alistes.\nScÃ©narios Ã  tester :\nTest 1 : Simulation mensuelle normale\ndouble soldeInitial = 1000.0; double[] depots = {500.0, 300.0, 200.0}; double[] retraits = {150.0, 80.0, 200.0, 50.0}; double tauxInteret = 2.0; double decouvertAutorise = 200.0; simulerMois(soldeInitial, depots, retraits, tauxInteret, decouvertAutorise); Test 2 : Situation de dÃ©couvert\ndouble soldeInitial = 100.0; double[] depots = {}; double[] retraits = {50.0, 80.0, 100.0}; // Solde final devrait Ãªtre nÃ©gatif avec frais Test 3 : Projection dâ€™Ã©pargne\ndouble soldeFutur = projeterEpargne(1000, 200, 2.0, 12); System.out.println(\"AprÃ¨s 12 mois : \" + soldeFutur + \"$\"); Test 4 : Tests des types de compte\nSystem.out.println(\"Solde 1500$ â†’ \" + determinerTypeCompte(1500)); System.out.println(\"Solde 3000$ â†’ \" + determinerTypeCompte(3000)); System.out.println(\"Solde 6000$ â†’ \" + determinerTypeCompte(6000)); âœ… CritÃ¨res de validation Les dÃ©pÃ´ts et retraits valident correctement les montants Le dÃ©couvert est bien gÃ©rÃ© (pas de dÃ©passement) Les intÃ©rÃªts sont calculÃ©s uniquement sur solde positif Les frais de dÃ©couvert sâ€™appliquent correctement La classification des comptes fonctionne Les frais de gestion sont calculÃ©s selon les bonnes rÃ¨gles La projection dâ€™Ã©pargne inclut les intÃ©rÃªts composÃ©s Tous les montants sont affichÃ©s avec 2 dÃ©cimales ğŸ’¡ Conseils Utilisez System.out.printf(\"%.2f$%n\", montant) pour formater Testez dâ€™abord chaque mÃ©thode individuellement VÃ©rifiez les cas limites (solde Ã  0, dÃ©couvert au maximum, etc.) Ajoutez des messages clairs pour suivre les opÃ©rations ğŸ Extensions possibles Ajouter un historique des transactions (tableau ou ArrayList) CrÃ©er une mÃ©thode pour gÃ©nÃ©rer un relevÃ© PDF ImplÃ©menter des virements entre comptes Ajouter des notifications de seuil de solde CrÃ©er un systÃ¨me de budget mensuel avec alertes ğŸ¯ Projet 6 : Analyseur de Texte ğŸ“‹ Contexte CrÃ©ez un outil dâ€™analyse textuelle complet qui peut compter les mots, analyser la structure, calculer des statistiques et transformer le texte.\nğŸ¯ Objectifs pÃ©dagogiques Manipulation de chaÃ®nes de caractÃ¨res (String) MÃ©thodes de String (split, substring, charAt, length, etc.) Boucles sur les caractÃ¨res Conditions pour classification ğŸ“ Instructions CrÃ©ez une classe AnalyseurTexte avec les mÃ©thodes suivantes :\n1. MÃ©thode compterMots But : Compter le nombre de mots dans un texte.\nParamÃ¨tres :\ntexte : texte Ã  analyser (String) Retour : Nombre de mots (int)\nDÃ©finition dâ€™un mot : SÃ©quence de caractÃ¨res sÃ©parÃ©e par des espaces\nAlgorithme :\n1. Supprimer les espaces au dÃ©but et Ã  la fin : texte.trim() 2. Si le texte est vide : retourner 0 3. DÃ©couper le texte en mots : String[] mots = texte.split(\"\\\\s+\") (\\\\s+ signifie : un ou plusieurs espaces) 4. Retourner la longueur du tableau de mots Exemples :\nâ€œBonjour le mondeâ€ â†’ 3 mots â€œJava est gÃ©nialâ€ â†’ 3 mots (espaces multiples) \"\" â†’ 0 mots \" \" â†’ 0 mots 2. MÃ©thode compterPhrases But : Compter le nombre de phrases dans un texte.\nParamÃ¨tres :\ntexte : texte Ã  analyser (String) Retour : Nombre de phrases (int)\nDÃ©finition : Une phrase se termine par . ou ! ou ?\nAlgorithme :\ncompteur = 0 Pour chaque caractÃ¨re c du texte : Si c == '.' ou c == '!' ou c == '?' : compteur++ Retourner compteur Alternative avec mÃ©thode String :\nint compteur = 0; for (int i = 0; i \u003c texte.length(); i++) { char c = texte.charAt(i); if (c == '.' || c == '!' || c == '?') { compteur++; } } return compteur; 3. MÃ©thode compterVoyelles But : Compter le nombre de voyelles dans un texte.\nParamÃ¨tres :\ntexte : texte Ã  analyser (String) Retour : Nombre de voyelles (int)\nVoyelles : a, e, i, o, u, y (et leurs majuscules)\nAlgorithme :\n1. Convertir le texte en minuscules : texte.toLowerCase() 2. Initialiser compteur = 0 3. Pour chaque caractÃ¨re c : Si c est dans \"aeiouy\" : compteur++ 4. Retourner compteur MÃ©thode pour vÃ©rifier si câ€™est une voyelle :\nboolean estVoyelle(char c) { c = Character.toLowerCase(c); return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'y'; } 4. MÃ©thode compterConsonnes But : Compter le nombre de consonnes (lettres qui ne sont pas des voyelles).\nParamÃ¨tres :\ntexte : texte Ã  analyser (String) Retour : Nombre de consonnes (int)\nAlgorithme :\ncompteur = 0 Pour chaque caractÃ¨re c : Si c est une lettre ET ce n'est pas une voyelle : compteur++ Retourner compteur VÃ©rifier si câ€™est une lettre :\nCharacter.isLetter(c) 5. MÃ©thode longueurMoyenneMots But : Calculer la longueur moyenne des mots.\nParamÃ¨tres :\ntexte : texte Ã  analyser (String) Retour : Longueur moyenne (double)\nAlgorithme :\n1. DÃ©couper le texte en mots 2. Si aucun mot : retourner 0.0 3. Initialiser somme = 0 4. Pour chaque mot : somme += longueur du mot (mot.length()) 5. Retourner somme / nombre de mots Exemple :\nâ€œBonjour le mondeâ€ â†’ (7 + 2 + 5) / 3 = 4.67 6. MÃ©thode motLePlusLong But : Trouver le mot le plus long dans le texte.\nParamÃ¨tres :\ntexte : texte Ã  analyser (String) Retour : Le mot le plus long (String)\nAlgorithme :\n1. DÃ©couper le texte en mots 2. Si aucun mot : retourner \"\" 3. Initialiser : motMax = premier mot longueurMax = longueur du premier mot 4. Pour chaque mot suivant : Si longueur du mot \u003e longueurMax : motMax = ce mot longueurMax = longueur de ce mot 5. Retourner motMax En cas dâ€™Ã©galitÃ© : Retourner le premier trouvÃ©\n7. MÃ©thode compterOccurrences But : Compter combien de fois un mot spÃ©cifique apparaÃ®t (insensible Ã  la casse).\nParamÃ¨tres :\ntexte : texte Ã  analyser (String) motCherche : mot Ã  chercher (String) Retour : Nombre dâ€™occurrences (int)\nRÃ¨gles :\nInsensible Ã  la casse (â€œJavaâ€ = â€œjavaâ€ = â€œJAVAâ€) Mot entier seulement (â€œleâ€ ne doit pas compter dans â€œManuelâ€) Algorithme :\n1. Convertir texte et motCherche en minuscules 2. DÃ©couper le texte en mots 3. Initialiser compteur = 0 4. Pour chaque mot : Si mot (en minuscules) == motCherche (en minuscules) : compteur++ 5. Retourner compteur 8. MÃ©thode calculerLisibilite But : Calculer un indice de lisibilitÃ© du texte.\nParamÃ¨tres :\ntexte : texte Ã  analyser (String) Retour : Score de lisibilitÃ© (0-100, plus Ã©levÃ© = plus facile) (double)\nFormule simplifiÃ©e (inspirÃ©e de Flesch) :\n206.835 - (1.015 Ã— mots par phrase) - (84.6 Ã— syllabes par mot) Pour simplifier : Estimez le nombre de syllabes en comptant les voyelles\nAlgorithme :\n1. Compter le nombre de mots (W) 2. Compter le nombre de phrases (S) 3. Compter le nombre de voyelles (V) comme approximation des syllabes 4. Si S == 0, retourner 0 (Ã©viter division par zÃ©ro) 5. motsParPhrase = W / S 6. syllabesParMot = V / W 7. score = 206.835 - (1.015 Ã— motsParPhrase) - (84.6 Ã— syllabesParMot) 8. Limiter le score entre 0 et 100 : Si score \u003e 100 : score = 100 Si score \u003c 0 : score = 0 9. Retourner score 9. MÃ©thode determinerNiveauComplexite But : DÃ©terminer le niveau de complexitÃ© selon lâ€™indice de lisibilitÃ©.\nParamÃ¨tres :\nindiceLisibilite : score calculÃ© (double) Retour : Niveau de complexitÃ© (String)\nClassification :\n= 90 : â€œTrÃ¨s facileâ€\n= 70 : â€œFacileâ€\n= 50 : â€œMoyenâ€\n= 30 : â€œDifficileâ€\n\u003c 30 : â€œTrÃ¨s difficileâ€ 10. MÃ©thode inverserTexte But : Inverser lâ€™ordre des mots dans le texte.\nParamÃ¨tres :\ntexte : texte Ã  inverser (String) Retour : Texte avec mots dans lâ€™ordre inverse (String)\nExemple :\nâ€œBonjour le mondeâ€ â†’ â€œmonde le Bonjourâ€ Algorithme :\n1. DÃ©couper le texte en mots 2. CrÃ©er un nouveau String vide (rÃ©sultat) 3. Parcourir le tableau de mots de la fin au dÃ©but : Pour i de (longueur-1) Ã  0 (dÃ©croissant) : Ajouter mots[i] au rÃ©sultat Ajouter un espace (sauf pour le dernier) 4. Retourner rÃ©sultat 11. MÃ©thode filtrerMotsCourts But : Supprimer tous les mots plus courts quâ€™une longueur donnÃ©e.\nParamÃ¨tres :\ntexte : texte Ã  filtrer (String) longueurMin : longueur minimale (int) Retour : Texte filtrÃ© (String)\nAlgorithme :\n1. DÃ©couper le texte en mots 2. CrÃ©er un String vide pour le rÃ©sultat 3. Pour chaque mot : Si longueur du mot \u003e= longueurMin : Ajouter le mot au rÃ©sultat Ajouter un espace 4. Retirer l'espace final (trim) 5. Retourner rÃ©sultat Exemple :\nTexte : â€œJe suis un dÃ©veloppeur Javaâ€ Longueur min : 4 RÃ©sultat : â€œsuis dÃ©veloppeur Javaâ€ 12. MÃ©thode genererRapport But : GÃ©nÃ©rer et afficher un rapport complet dâ€™analyse.\nParamÃ¨tres :\ntexte : texte Ã  analyser (String) Retour : void\nInformations Ã  afficher :\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•— â•‘ ANALYSE DE TEXTE COMPLÃˆTE â•‘ â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• TEXTE ANALYSÃ‰ : [Afficher le texte] --- STATISTIQUES GÃ‰NÃ‰RALES --- Nombre de caractÃ¨res (avec espaces) : X Nombre de caractÃ¨res (sans espaces) : Y Nombre de mots : Z Nombre de phrases : N Nombre de voyelles : V Nombre de consonnes : C --- ANALYSE DES MOTS --- Longueur moyenne des mots : X.XX caractÃ¨res Mot le plus long : \"XXXXXXXXX\" (X lettres) Mots par phrase (moyenne) : X.XX --- LISIBILITÃ‰ --- Indice de lisibilitÃ© : XX.XX Niveau de complexitÃ© : XXXXXX --- COMPOSITION --- Voyelles : XX% du texte Consonnes : XX% du texte Algorithme :\n1. Afficher l'en-tÃªte 2. Afficher le texte 3. Calculer et afficher : - Longueur avec espaces : texte.length() - Longueur sans espaces : texte.replace(\" \", \"\").length() - Appeler compterMots(texte) - Appeler compterPhrases(texte) - Appeler compterVoyelles(texte) - Appeler compterConsonnes(texte) 4. Calculer et afficher : - Appeler longueurMoyenneMots(texte) - Appeler motLePlusLong(texte) - Mots par phrase : compterMots / compterPhrases 5. Calculer et afficher : - Appeler calculerLisibilite(texte) - Appeler determinerNiveauComplexite(indice) 6. Calculer les pourcentages : - % voyelles : (voyelles / longueurSansEspaces) Ã— 100 - % consonnes : (consonnes / longueurSansEspaces) Ã— 100 13. MÃ©thode main But : Tester toutes les fonctionnalitÃ©s.\nTests Ã  effectuer :\nTest 1 : Texte exemple\nString texte = \"Java est un langage de programmation orientÃ© objet. \" + \"Il est largement utilisÃ© pour dÃ©velopper des applications. \" + \"Ce langage offre une grande portabilitÃ© et robustesse.\"; genererRapport(texte); Test 2 : Transformations\nSystem.out.println(\" --- TRANSFORMATIONS ---\"); System.out.println(\"Texte inversÃ© : \" + inverserTexte(texte)); System.out.println(\"Sans mots courts (\u003c4) : \" + filtrerMotsCourts(texte, 4)); Test 3 : Occurrences\nSystem.out.println(\" --- RECHERCHE ---\"); System.out.println(\"Occurrences de 'Java' : \" + compterOccurrences(texte, \"Java\")); System.out.println(\"Occurrences de 'est' : \" + compterOccurrences(texte, \"est\")); Test 4 : Cas limites\nString texteVide = \"\"; String texteUnMot = \"Bonjour\"; String texteEspaces = \" Multiple espaces \"; // Tester avec ces cas âœ… CritÃ¨res de validation Le comptage de mots gÃ¨re les espaces multiples Les voyelles incluent y et sont insensibles Ã  la casse Les consonnes nâ€™incluent que les lettres La recherche dâ€™occurrences est insensible Ã  la casse Lâ€™inversion de texte prÃ©serve lâ€™ordre dans chaque mot Le filtrage conserve les espaces correctement Le rapport affiche toutes les informations demandÃ©es Les pourcentages sont calculÃ©s correctement ğŸ’¡ Conseils Utilisez String.split(\"\\s+\") pour gÃ©rer les espaces multiples Character.isLetter(c) est utile pour identifier les lettres Testez avec des textes en majuscules, minuscules et mixtes GÃ©rez les cas oÃ¹ le texte est vide ou null ğŸ Extensions possibles Ajouter la dÃ©tection de mots-clÃ©s (programmation, Java, etc.) CrÃ©er un correcteur orthographique basique Analyser la ponctuation utilisÃ©e DÃ©tecter les mots rÃ©pÃ©tÃ©s consÃ©cutifs GÃ©nÃ©rer un nuage de mots (afficher les mots les plus frÃ©quents) ğŸ° Projet 7 : Machine Ã  Sous (Slot Machine) ğŸ“‹ Contexte CrÃ©ez un jeu de machine Ã  sous complet avec rouleaux, symboles, calcul de gains, systÃ¨me de crÃ©dits et statistiques de session.\nğŸ¯ Objectifs pÃ©dagogiques GÃ©nÃ©ration de nombres alÃ©atoires Logique de jeu et conditions complexes Gestion dâ€™Ã©tat (crÃ©dits, tours) Interaction utilisateur avec Scanner Calculs de probabilitÃ©s et gains ğŸ“ Instructions CrÃ©ez une classe MachineASous avec les mÃ©thodes suivantes :\n1. MÃ©thode genererSymbole But : GÃ©nÃ©rer alÃ©atoirement un symbole de rouleau.\nParamÃ¨tres : Aucun\nRetour : Un symbole (String)\nSymboles disponibles :\nğŸ’ Cerise ğŸ‹ Citron ğŸŠ Orange ğŸ”” Cloche â­ Ã‰toile ğŸ’ Diamant 7 Sept Algorithme :\n1. CrÃ©er un tableau : String[] symboles = {\"ğŸ’\", \"ğŸ‹\", \"ğŸŠ\", \"ğŸ””\", \"â­\", \"ğŸ’\", \"7\"} 2. GÃ©nÃ©rer un index alÃ©atoire entre 0 et 6 : Random random = new Random(); int index = random.nextInt(7); 3. Retourner symboles[index] Note : Tous les symboles ont la mÃªme probabilitÃ© (1/7).\n2. MÃ©thode lancerRouleaux But : Lancer les trois rouleaux et retourner les symboles.\nParamÃ¨tres : Aucun\nRetour : Tableau de 3 symboles (String[])\nAlgorithme :\n1. CrÃ©er un tableau de taille 3 : String[] rouleaux = new String[3] 2. Pour i de 0 Ã  2 : rouleaux[i] = genererSymbole() 3. Retourner rouleaux 3. MÃ©thode afficherRouleaux But : Afficher les rouleaux de maniÃ¨re visuelle et attractive.\nParamÃ¨tres :\nrouleaux : tableau de 3 symboles (String[]) Retour : void\nFormat dâ€™affichage :\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•— â•‘ ğŸ’ â”‚ ğŸ‹ â”‚ ğŸŠ â•‘ â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• Algorithme :\nSystem.out.println(\"â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\"); System.out.println(\"â•‘ \" + rouleaux[0] + \" â”‚ \" + rouleaux[1] + \" â”‚ \" + rouleaux[2] + \" â•‘\"); System.out.println(\"â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\"); 4. MÃ©thode troisSymbolesIdentiques But : VÃ©rifier si les trois symboles sont identiques.\nParamÃ¨tres :\nrouleaux : tableau de 3 symboles (String[]) Retour : true si les 3 sont identiques, false sinon (boolean)\nAlgorithme :\nRetourner rouleaux[0].equals(rouleaux[1]) \u0026\u0026 rouleaux[1].equals(rouleaux[2]) Note : Utiliser .equals() et non == pour comparer des String\n5. MÃ©thode deuxSymbolesIdentiques But : VÃ©rifier si exactement 2 symboles sur 3 sont identiques.\nParamÃ¨tres :\nrouleaux : tableau de 3 symboles (String[]) Retour : true si 2 sont identiques, false sinon (boolean)\nAlgorithme :\nSi les 3 sont identiques : retourner false Si rouleaux[0] == rouleaux[1] : retourner true Si rouleaux[0] == rouleaux[2] : retourner true Si rouleaux[1] == rouleaux[2] : retourner true Sinon : retourner false 6. MÃ©thode obtenirMultiplicateur But : Retourner le multiplicateur de gain selon le symbole.\nParamÃ¨tres :\nsymbole : le symbole (String) Retour : Multiplicateur (int)\nTable des multiplicateurs :\nğŸ’ (Cerise) : Ã—2 ğŸ‹ (Citron) : Ã—3 ğŸŠ (Orange) : Ã—4 ğŸ”” (Cloche) : Ã—5 â­ (Ã‰toile) : Ã—10 ğŸ’ (Diamant) : Ã—20 7 (Sept) : Ã—50 (JACKPOT!) Algorithme avec switch :\nswitch (symbole) { case \"ğŸ’\": return 2; case \"ğŸ‹\": return 3; case \"ğŸŠ\": return 4; case \"ğŸ””\": return 5; case \"â­\": return 10; case \"ğŸ’\": return 20; case \"7\": return 50; default: return 0; } 7. MÃ©thode calculerGains But : Calculer les gains dâ€™un tour selon les rouleaux et la mise.\nParamÃ¨tres :\nrouleaux : tableau de 3 symboles (String[]) mise : montant misÃ© (double) Retour : Montant gagnÃ© (double)\nRÃ¨gles de gains :\n3 symboles identiques : mise Ã— multiplicateur du symbole 2 symboles identiques : mise Ã— 1.5 Aucune correspondance : 0 Algorithme :\nSi troisSymbolesIdentiques(rouleaux) : symbole = rouleaux[0] multiplicateur = obtenirMultiplicateur(symbole) gains = mise Ã— multiplicateur retourner gains Sinon si deuxSymbolesIdentiques(rouleaux) : gains = mise Ã— 1.5 retourner gains Sinon : retourner 0.0 Exemples :\nğŸ’ ğŸ’ ğŸ’ avec mise de 5$ â†’ 5 Ã— 2 = 10$ ğŸ’ ğŸ’ ğŸ’ avec mise de 10$ â†’ 10 Ã— 20 = 200$ ğŸ‹ ğŸ‹ ğŸŠ avec mise de 5$ â†’ 5 Ã— 1.5 = 7.50$ ğŸ’ ğŸ‹ ğŸŠ avec mise de 5$ â†’ 0$ 8. MÃ©thode afficherResultat But : Afficher un message selon les gains.\nParamÃ¨tres :\ngains : montant gagnÃ© (double) mise : montant misÃ© (double) Retour : void\nMessages selon les gains :\ngains == 0 : â€œâŒ Perdu ! Vous perdez X$â€ gains == mise : â€œğŸ¤ RemboursÃ© ! Vous rÃ©cupÃ©rez votre miseâ€ gains \u003c mise Ã— 5 : â€œğŸ’° Petit gain ! Vous gagnez X$â€ gains \u003c mise Ã— 20 : â€œğŸ‰ Beau gain ! Vous gagnez X$â€ gains \u003e= mise Ã— 20 : â€œğŸŠ JACKPOT ! Vous gagnez X$ !!!â€ Algorithme :\nif (gains == 0) { System.out.printf(\"âŒ Perdu ! Vous perdez %.2f$%n\", mise); } else if (gains == mise) { System.out.println(\"ğŸ¤ RemboursÃ© ! Vous rÃ©cupÃ©rez votre mise\"); } else if (gains \u003c mise * 5) { System.out.printf(\"ğŸ’° Petit gain ! Vous gagnez %.2f$%n\", gains); } else if (gains \u003c mise * 20) { System.out.printf(\"ğŸ‰ Beau gain ! Vous gagnez %.2f$%n\", gains); } else { System.out.printf(\"ğŸŠ JACKPOT ! Vous gagnez %.2f$ !!!%n\", gains); } 9. MÃ©thode afficherStatistiques But : Afficher les statistiques de la session de jeu.\nParamÃ¨tres :\ntoursJoues : nombre de tours jouÃ©s (int) toursGagnes : nombre de tours avec gains (int) creditsInitiaux : crÃ©dits au dÃ©but (double) creditsFinaux : crÃ©dits Ã  la fin (double) Retour : void\nFormat dâ€™affichage :\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•— â•‘ STATISTIQUES DE SESSION â•‘ â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• Tours jouÃ©s : X Tours gagnÃ©s : Y Taux de rÃ©ussite : Z.Z% CrÃ©dits de dÃ©part : XX.XX$ CrÃ©dits finaux : YY.YY$ [BÃ©nÃ©fice/Perte] : Â±ZZ.ZZ$ Algorithme :\n1. Afficher l'en-tÃªte 2. Afficher tours jouÃ©s et tours gagnÃ©s 3. Si toursJoues \u003e 0 : tauxReussite = (toursGagnes / toursJoues) Ã— 100 Afficher le taux 4. Afficher crÃ©dits initiaux et finaux 5. Calculer la diffÃ©rence : difference = creditsFinaux - creditsInitiaux 6. Si diffÃ©rence \u003e 0 : Afficher \"âœ… BÃ©nÃ©fice : +X$\" Si diffÃ©rence \u003c 0 : Afficher \"âŒ Perte : X$\" (valeur absolue) Sinon : Afficher \"ğŸ¤ Ã€ l'Ã©quilibre\" 10. MÃ©thode jouerTour But : Jouer un tour complet de machine Ã  sous.\nParamÃ¨tres :\ncredits : crÃ©dits disponibles (double) mise : montant de la mise (double) Retour : Nouveaux crÃ©dits aprÃ¨s le tour (double)\nAlgorithme :\n1. VÃ©rifier si la mise est possible : Si mise \u003e credits : Afficher \"âŒ CrÃ©dits insuffisants !\" Retourner credits (inchangÃ©s) 2. DÃ©duire la mise : credits = credits - mise 3. Afficher l'animation : System.out.println(\" ğŸ° Les rouleaux tournent...\") (Optionnel : ajouter une pause) 4. Lancer les rouleaux : rouleaux = lancerRouleaux() 5. Afficher les rouleaux : afficherRouleaux(rouleaux) 6. Calculer les gains : gains = calculerGains(rouleaux, mise) 7. Afficher le rÃ©sultat : afficherResultat(gains, mise) 8. Ajouter les gains aux crÃ©dits : credits = credits + gains 9. Afficher le nouveau solde : System.out.printf(\"Nouveau solde : %.2f$%n\", credits) 10. Retourner credits 11. MÃ©thode jouer (jeu principal) But : GÃ©rer le jeu complet avec boucle de jeu et menu.\nParamÃ¨tres : Aucun\nRetour : void\nAlgorithme complet :\n1. Initialiser : Scanner scanner = new Scanner(System.in); double credits = 100.0; // CrÃ©dits de dÃ©part double creditsInitiaux = credits; int toursJoues = 0; int toursGagnes = 0; 2. Afficher l'Ã©cran de bienvenue : â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•— â•‘ MACHINE Ã€ SOUS ğŸ° â•‘ â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• CrÃ©dits de dÃ©part : 100.00$ TABLE DES GAINS : ğŸ’ ğŸ’ ğŸ’ : Ã—2 ğŸ‹ ğŸ‹ ğŸ‹ : Ã—3 ğŸŠ ğŸŠ ğŸŠ : Ã—4 ğŸ”” ğŸ”” ğŸ”” : Ã—5 â­ â­ â­ : Ã—10 ğŸ’ ğŸ’ ğŸ’ : Ã—20 7 7 7 : Ã—50 JACKPOT! 2 symboles identiques : Ã—1.5 3. Boucle de jeu (tant que credits \u003e= 1) : a. Afficher le menu : \"\\nğŸ’° CrÃ©dits : X.XX$\" \"Choisissez votre mise :\" \"1. 1$\" \"2. 2$\" \"3. 5$\" \"4. 10$ (max)\" \"0. Quitter\" \"Votre choix : \" b. Lire le choix du joueur c. Selon le choix : - 0 : sortir de la boucle - 1 : mise = 1 - 2 : mise = 2 - 3 : mise = 5 - 4 : mise = 10 - Autre : afficher \"Choix invalide\", continuer d. VÃ©rifier que la mise \u003c= credits Sinon : afficher erreur, continuer e. Jouer le tour : creditsAvant = credits credits = jouerTour(credits, mise) toursJoues++ f. Si credits \u003e creditsAvant : toursGagnes++ g. Attendre avant le prochain tour (optionnel) : System.out.println(\" Appuyez sur EntrÃ©e pour continuer...\"); scanner.nextLine(); 4. Fin du jeu : Si credits \u003c 1 : Afficher \" ğŸ’” Vous n'avez plus de crÃ©dits !\" Sinon : Afficher \" ğŸ‘‹ Merci d'avoir jouÃ© !\" 5. Afficher les statistiques finales : afficherStatistiques(toursJoues, toursGagnes, creditsInitiaux, credits); 6. Fermer le scanner : scanner.close(); 12. MÃ©thode main But : Lancer le jeu.\nCode :\npublic static void main(String[] args) { jouer(); } âœ… CritÃ¨res de validation Les symboles sont gÃ©nÃ©rÃ©s alÃ©atoirement Les trois rouleaux sont indÃ©pendants Le calcul des gains suit les rÃ¨gles exactes Les crÃ©dits sont correctement mis Ã  jour Le jeu sâ€™arrÃªte quand crÃ©dits \u003c 1 Les statistiques sont calculÃ©es correctement Le taux de rÃ©ussite est un pourcentage entre 0 et 100 Lâ€™affichage est clair et attractif ğŸ’¡ Conseils Testez dâ€™abord avec des symboles fixes pour vÃ©rifier la logique Utilisez System.out.printf(\"%.2f$\", montant) pour formater lâ€™argent Ajoutez des Thread.sleep(1000) pour des pauses dramatiques (importer java.lang.Thread) VÃ©rifiez tous les cas : 3 identiques, 2 identiques, aucun Testez les cas limites : crÃ©dits Ã  0, mise maximale, etc. ğŸ Extensions possibles Ajouter des symboles spÃ©ciaux (Wild, Scatter) ImplÃ©menter des tours gratuits (free spins) CrÃ©er des niveaux de difficultÃ© (probabilitÃ©s diffÃ©rentes) Ajouter un systÃ¨me de jackpot progressif Sauvegarder les meilleurs scores CrÃ©er un systÃ¨me de multiplicateurs en cascade Ajouter des sons (avec des caractÃ¨res BEEP) ğŸ“Š Grille dâ€™Ã©valuation gÃ©nÃ©rale Pour chaque projet, voici comment vous serez Ã©valuÃ© :\nFonctionnalitÃ© (50 points) Toutes les mÃ©thodes demandÃ©es sont implÃ©mentÃ©es (20 pts) Les mÃ©thodes fonctionnent correctement (20 pts) Les calculs sont exacts (10 pts) QualitÃ© du code (30 points) Noms de variables et mÃ©thodes clairs (10 pts) Code bien indentÃ© et lisible (10 pts) Commentaires pertinents (10 pts) Robustesse (20 points) Validation des entrÃ©es utilisateur (10 pts) Gestion des cas limites (5 pts) Pas dâ€™erreurs Ã  lâ€™exÃ©cution (5 pts) Total : 100 points par projet\nğŸ’¡ Conseils gÃ©nÃ©raux pour tous les projets 1. MÃ©thodologie de dÃ©veloppement Lire entiÃ¨rement les instructions Planifier : liste des mÃ©thodes Ã  crÃ©er DÃ©velopper mÃ©thode par mÃ©thode (commencer par les plus simples) Tester chaque mÃ©thode individuellement IntÃ©grer progressivement DÃ©boguer en cas de problÃ¨me AmÃ©liorer le code (refactoring) 2. Techniques de dÃ©bogage Utiliser System.out.println() pour afficher les valeurs Tester avec des valeurs simples et connues Isoler le problÃ¨me (quelle mÃ©thode ne fonctionne pas ?) VÃ©rifier les types de donnÃ©es (int vs double) Attention aux divisions par zÃ©ro 3. Bonnes pratiques Java // âœ… Bon public static double calculerMoyenne(double[] notes) { if (notes == null || notes.length == 0) { return 0.0; } double somme = 0.0; for (double note : notes) { somme += note; } return somme / notes.length; } // âŒ Mauvais public static double calcul(double[] n) { double s = 0; for (int i = 0; i \u003c n.length; i++) { s = s + n[i]; } return s / n.length; // Erreur possible si n.length == 0 } 4. Checklist avant de soumettre Le code compile sans erreur Toutes les mÃ©thodes demandÃ©es sont prÃ©sentes Les tests dans main fonctionnent Le code est indentÃ© correctement Les noms de variables sont explicites Les cas limites sont gÃ©rÃ©s Des commentaires expliquent la logique complexe ğŸš€ Ordre recommandÃ© des projets Pour dÃ©butants :\nProjet 1 (Gestion de Notes) - Le plus simple Projet 4 (Calculateur de Dates) - Logique pure Projet 6 (Analyseur de Texte) - Manipulation de String Pour intermÃ©diaires : 4. Projet 5 (Compte Bancaire) - Plus de logique 5. Projet 2 (Calculateur de Salaire) - Calculs complexes\nPour avancÃ©s : 6. Projet 3 (Jeu de Devinette) - Interaction utilisateur 7. Projet 7 (Machine Ã  Sous) - Le plus complet\nğŸ“š Ressources Java utiles MÃ©thodes String importantes length() : longueur de la chaÃ®ne charAt(index) : caractÃ¨re Ã  la position substring(debut, fin) : sous-chaÃ®ne split(regex) : dÃ©couper en tableau trim() : supprimer espaces dÃ©but/fin toLowerCase() / toUpperCase() equals(autre) : comparer deux String replace(ancien, nouveau) : remplacer MÃ©thodes de tableaux array.length : taille du tableau Arrays.toString(array) : afficher un tableau Classe Math Math.abs(x) : valeur absolue Math.max(a, b) : maximum Math.min(a, b) : minimum Math.pow(x, y) : puissance Math.round(x) : arrondir Classe Random Random random = new Random(); int nombre = random.nextInt(100); // 0-99 int nombreDe = random.nextInt(6) + 1; // 1-6 Scanner Scanner scanner = new Scanner(System.in); int nombre = scanner.nextInt(); double decimal = scanner.nextDouble(); String texte = scanner.nextLine(); scanner.close(); // Important !",
    "description": "Exercices de rÃ©vision ğŸ® Projet 1 : SystÃ¨me de Gestion de Notes Scolaires ğŸ“‹ Contexte Vous devez crÃ©er un systÃ¨me pour gÃ©rer et analyser les notes dâ€™une classe dâ€™Ã©tudiants. Le systÃ¨me permettra de calculer des statistiques, dâ€™attribuer des mentions et de gÃ©nÃ©rer des rapports.",
    "tags": [],
    "title": "Exercices de rÃ©vision",
    "uri": "/420-210/exo_revisions/index.html"
  },
  {
    "breadcrumb": "Programmation orientÃ©e objet",
    "content": "Avant de commencer : pourquoi la POO ? Jusquâ€™Ã  prÃ©sent, vous avez Ã©crit des programmes avec des variables et des mÃ©thodes statiques. Ã‡a marche trÃ¨s bien pour des programmes simples. Mais imaginez que vous deviez gÃ©rer une liste de 500 Ã©tudiants, chacun avec un nom, un numÃ©ro dâ€™Ã©tudiant et une note.\nAvec des variables sÃ©parÃ©es, Ã§a ressemblerait Ã  Ã§a :\nString nom1 = \"Alice\"; int numero1 = 12345; double note1 = 88.5; String nom2 = \"Bob\"; int numero2 = 12346; double note2 = 75.0; String nom3 = \"Charlie\"; int numero3 = 12347; double note3 = 92.0; // ... 497 autres fois ??? Câ€™est impossible Ã  gÃ©rer. La POO existe pour organiser le code comme on organise les choses dans la vie rÃ©elle.\n1. La grande idÃ©e : le moule et les objets 1.1 Une analogie concrÃ¨te Pensez Ã  un plan de maison.\nLe plan vous montre la disposition des piÃ¨ces, la taille, oÃ¹ est la cuisine, oÃ¹ est la chambre. Ã€ partir de ce plan, vous pouvez construire plusieurs maisons. Chaque maison a les mÃªmes piÃ¨ces, mais la couleur des murs peut Ãªtre diffÃ©rente, le mobilier peut changer, etc. En POO :\nLe plan = la classe Chaque maison construite = un objet (on dit aussi une instance) Une classe est donc un moule. On la dÃ©finit une seule fois, puis on lâ€™utilise pour crÃ©er autant dâ€™objets quâ€™on veut.\n2. Notre premiÃ¨re classe : Animal 2.1 Pourquoi Animal ? Tous les animaux ont certaines caractÃ©ristiques communes :\nUn nom Une espÃ¨ce Un nombre de pattes Un son quâ€™ils font PlutÃ´t que de crÃ©er des variables sÃ©parÃ©es pour chaque animal, on va crÃ©er un moule Animal.\n2.2 Ã‰criture de la classe En Java, chaque classe va dans son propre fichier. Le fichier doit avoir le mÃªme nom que la classe.\nFichier : Animal.java\npublic class Animal { // Ces variables appartiennent Ã  chaque objet. // On les appelle des ATTRIBUTS. public String nom; public String espece; public int nombrePattes; public String son; } Câ€™est tout ! On a juste dÃ©crit ce quâ€™un animal contient.\nÃ€ noter : En Java, le type chaÃ®ne de caractÃ¨res sâ€™Ã©crit String avec un grand S.\n2.3 CrÃ©er des objets Ã  partir de la classe Le code qui crÃ©e et utilise des objets se trouve dans une autre classe qui contient la mÃ©thode main.\nFichier : Main.java\npublic class Main { public static void main(String[] args) { // On crÃ©e un premier animal Animal monChien = new Animal(); monChien.nom = \"Rex\"; monChien.espece = \"Chien\"; monChien.nombrePattes = 4; monChien.son = \"Ouaf!\"; // On crÃ©e un deuxiÃ¨me animal avec le mÃªme moule Animal monChat = new Animal(); monChat.nom = \"Whiskers\"; monChat.espece = \"Chat\"; monChat.nombrePattes = 4; monChat.son = \"Miaou!\"; // Un troisiÃ¨me Animal monPoisson = new Animal(); monPoisson.nom = \"Nemo\"; monPoisson.espece = \"Poisson\"; monPoisson.nombrePattes = 0; monPoisson.son = \"...\"; } } Le mot-clÃ© new est celui qui crÃ©e un nouvel objet.\n2.4 Utiliser les attributs System.out.println(monChien.nom); // Affiche: Rex System.out.println(monChat.son); // Affiche: Miaou! System.out.println(monPoisson.nombrePattes); // Affiche: 0 Le point (.) permet dâ€™accÃ©der Ã  un attribut dâ€™un objet. On dit quâ€™on â€œaccÃ¨de Ã  un membre de lâ€™objetâ€.\n3. Les mÃ©thodes : donner des comportements Ã  nos objets 3.1 Pourquoi des mÃ©thodes ? Un animal ne fait pas quâ€™exister. Il fait des choses :\nIl peut faire un son On peut lui afficher ses informations Une mÃ©thode est une fonction qui appartient Ã  une classe. Elle dÃ©crit un comportement de lâ€™objet.\n3.2 Ajout de mÃ©thodes Ã  la classe Animal Fichier : Animal.java\npublic class Animal { public String nom; public String espece; public int nombrePattes; public String son; // MÃ©thode qui fait parler l'animal public void faireSon() { System.out.println(nom + \" dit: \" + son); } // MÃ©thode qui affiche les informations public void afficherInfo() { System.out.println(\"--- Informations ---\"); System.out.println(\"Nom: \" + nom); System.out.println(\"Espece: \" + espece); System.out.println(\"Nombre de pattes: \" + nombrePattes); } } Convention Java : Les noms de mÃ©thodes commencent par une minuscule : faireSon(), pas FaireSon().\n3.3 Appeler une mÃ©thode Fichier : Main.java\npublic class Main { public static void main(String[] args) { Animal monChien = new Animal(); monChien.nom = \"Rex\"; monChien.espece = \"Chien\"; monChien.nombrePattes = 4; monChien.son = \"Ouaf!\"; monChien.faireSon(); // Affiche: Rex dit: Ouaf! monChien.afficherInfo(); // Affiche les infos de Rex } } On appelle une mÃ©thode avec le point, exactement comme on accÃ¨de Ã  un attribut, mais avec des parenthÃ¨ses Ã  la fin.\n3.4 MÃ©thodes avec des paramÃ¨tres et retour de valeur Fichier : Animal.java\npublic class Animal { public String nom; public String espece; public int nombrePattes; public String son; public void faireSon() { System.out.println(nom + \" dit: \" + son); } public void afficherInfo() { System.out.println(\"--- Informations ---\"); System.out.println(\"Nom: \" + nom); System.out.println(\"Espece: \" + espece); System.out.println(\"Nombre de pattes: \" + nombrePattes); } // MÃ©thode qui prend un paramÃ¨tre public void faireSonNFois(int n) { for (int i = 0; i \u003c n; i++) { System.out.println(nom + \" dit: \" + son); } } // MÃ©thode qui retourne une valeur (boolean) public boolean estQuadrupede() { return nombrePattes == 4; } } Fichier : Main.java\npublic class Main { public static void main(String[] args) { Animal monChien = new Animal(); monChien.nom = \"Rex\"; monChien.nombrePattes = 4; monChien.son = \"Ouaf!\"; monChien.faireSonNFois(3); // Affiche: // Rex dit: Ouaf! // Rex dit: Ouaf! // Rex dit: Ouaf! boolean quadrupede = monChien.estQuadrupede(); System.out.println(quadrupede); // Affiche: true } } Ã€ noter : En Java, le type boolÃ©en sâ€™Ã©crit boolean (tout en minuscules), et les valeurs sont true / false.\n4. Le constructeur : initialiser un objet proprement 4.1 Le problÃ¨me Avec notre classe actuelle, on doit dâ€™abord crÃ©er lâ€™objet, puis remplir chaque attribut un par un. Câ€™est long et on risque dâ€™oublier un attribut.\n// Long et risquÃ© Animal monChien = new Animal(); monChien.nom = \"Rex\"; monChien.espece = \"Chien\"; monChien.nombrePattes = 4; monChien.son = \"Ouaf!\"; 4.2 La solution : le constructeur Le constructeur est une mÃ©thode spÃ©ciale qui sâ€™exÃ©cute automatiquement au moment oÃ¹ on crÃ©e un objet avec new. Il permet de donner les valeurs en mÃªme temps quâ€™on crÃ©e lâ€™objet.\nFichier : Animal.java\npublic class Animal { public String nom; public String espece; public int nombrePattes; public String son; // C'est le constructeur ! // Il a le mÃªme nom que la classe. // Il n'a pas de type de retour. public Animal(String nom, String espece, int nombrePattes, String son) { this.nom = nom; this.espece = espece; this.nombrePattes = nombrePattes; this.son = son; } public void faireSon() { System.out.println(nom + \" dit: \" + son); } public void afficherInfo() { System.out.println(\"--- Informations ---\"); System.out.println(\"Nom: \" + nom); System.out.println(\"Espece: \" + espece); System.out.println(\"Nombre de pattes: \" + nombrePattes); } } 4.3 Le mot-clÃ© this Dans le constructeur ci-dessus, vous voyez this.nom = nom;.\nLe problÃ¨me : le paramÃ¨tre du constructeur sâ€™appelle nom, et lâ€™attribut de la classe sâ€™appelle aussi nom. Comment distinguer les deux ?\nthis.nom = lâ€™attribut de lâ€™objet en cours de crÃ©ation nom (sans this) = le paramÃ¨tre reÃ§u par le constructeur // this.nom â†’ l'attribut de l'objet // nom â†’ la valeur passÃ©e en paramÃ¨tre this.nom = nom; 4.4 CrÃ©ation dâ€™objets avec le constructeur Fichier : Main.java\npublic class Main { public static void main(String[] args) { // Beaucoup plus propre ! Animal monChien = new Animal(\"Rex\", \"Chien\", 4, \"Ouaf!\"); Animal monChat = new Animal(\"Whiskers\", \"Chat\", 4, \"Miaou!\"); Animal monSerpent = new Animal(\"Slinky\", \"Serpent\", 0, \"Ssss!\"); monChien.faireSon(); // Rex dit: Ouaf! monChat.faireSon(); // Whiskers dit: Miaou! monSerpent.faireSon(); // Slinky dit: Ssss! } } 5. Une classe plus rÃ©aliste : Etudiant Appliquons tout ce quâ€™on a vu avec un exemple plus proche de votre vie quotidienne.\nFichier : Etudiant.java\npublic class Etudiant { public String nom; public String prenom; public int numeroEtudiant; public double[] notes; // Tableau de notes public Etudiant(String nom, String prenom, int numeroEtudiant) { this.nom = nom; this.prenom = prenom; this.numeroEtudiant = numeroEtudiant; this.notes = new double[0]; // Pas de notes au dÃ©part } // Ajoute une note Ã  l'Ã©tudiant public void ajouterNote(double note) { // On crÃ©e un nouveau tableau plus grand double[] nouvelles_notes = new double[notes.length + 1]; for (int i = 0; i \u003c notes.length; i++) { nouvelles_notes[i] = notes[i]; } nouvelles_notes[notes.length] = note; notes = nouvelles_notes; } // Calcule la moyenne des notes public double calculerMoyenne() { if (notes.length == 0) { return 0.0; } double somme = 0; for (double note : notes) { somme += note; } return somme / notes.length; } // Affiche les informations complÃ¨tes public void afficherInfo() { System.out.println(\"=== Fiche Etudiant ===\"); System.out.println(\"Nom: \" + prenom + \" \" + nom); System.out.println(\"Numero: \" + numeroEtudiant); System.out.println(\"Nombre de notes: \" + notes.length); System.out.printf(\"Moyenne: %.2f%n\", calculerMoyenne()); } // Retourne si l'Ã©tudiant a rÃ©ussi (moyenne \u003e= 60) public boolean aReussi() { return calculerMoyenne() \u003e= 60.0; } } Fichier : Main.java\npublic class Main { public static void main(String[] args) { Etudiant alice = new Etudiant(\"Dupont\", \"Alice\", 12345); alice.ajouterNote(85.0); alice.ajouterNote(92.0); alice.ajouterNote(78.0); Etudiant bob = new Etudiant(\"Martin\", \"Bob\", 12346); bob.ajouterNote(55.0); bob.ajouterNote(48.0); bob.ajouterNote(62.0); // Affichage alice.afficherInfo(); // === Fiche Etudiant === // Nom: Alice Dupont // Numero: 12345 // Nombre de notes: 3 // Moyenne: 85.00 bob.afficherInfo(); // === Fiche Etudiant === // Nom: Bob Martin // Numero: 12346 // Nombre de notes: 3 // Moyenne: 55.00 // VÃ©rification System.out.println(\"Alice a reussi: \" + alice.aReussi()); // true System.out.println(\"Bob a reussi: \" + bob.aReussi()); // false } } Ã€ noter : En Java, on utilise notes.length (sans parenthÃ¨ses) pour obtenir la taille dâ€™un tableau. On utilise aussi for (double note : notes) pour parcourir un tableau â€” câ€™est la boucle for-each en Java.\n6. Plusieurs objets dans un tableau Puisque chaque objet est une valeur comme une autre, on peut les mettre dans des tableaux.\nFichier : Main.java\npublic class Main { public static void main(String[] args) { // CrÃ©ation d'un tableau d'Ã©tudiants Etudiant[] etudiants = new Etudiant[3]; etudiants[0] = new Etudiant(\"Dupont\", \"Alice\", 12345); etudiants[0].ajouterNote(85.0); etudiants[0].ajouterNote(92.0); etudiants[1] = new Etudiant(\"Martin\", \"Bob\", 12346); etudiants[1].ajouterNote(55.0); etudiants[1].ajouterNote(48.0); etudiants[2] = new Etudiant(\"Tremblay\", \"Charlie\", 12347); etudiants[2].ajouterNote(70.0); etudiants[2].ajouterNote(75.0); // On peut parcourir le tableau avec une boucle for-each for (Etudiant e : etudiants) { System.out.printf(\"%s %s - Moyenne: %.2f%n\", e.prenom, e.nom, e.calculerMoyenne()); } // Affiche: // Alice Dupont - Moyenne: 88.50 // Bob Martin - Moyenne: 51.50 // Charlie Tremblay - Moyenne: 72.50 } } 7. RÃ©sumÃ© des concepts Concept Ce que câ€™est Analogie Classe Un moule qui dÃ©crit un type dâ€™objet Le plan de maison Objet Une instance crÃ©Ã©e Ã  partir dâ€™une classe Une maison construite Attribut Une variable qui appartient Ã  un objet La couleur des murs MÃ©thode Une fonction qui appartient Ã  une classe Une action que peut faire la maison Constructeur Une mÃ©thode spÃ©ciale qui initialise lâ€™objet Le moment oÃ¹ on ameuble la maison new Le mot-clÃ© pour crÃ©er un objet Le moment oÃ¹ on commence la construction this DÃ©signe lâ€™objet en cours â€œcette maison-ciâ€ . (point) Permet dâ€™accÃ©der aux attributs/mÃ©thodes La clÃ© qui ouvre la maison Rappel des conventions Java Chose Convention Exemple Nom de classe Commence par une majuscule Animal, Etudiant Nom de mÃ©thode Commence par une minuscule faireSon(), calculerMoyenne() Nom dâ€™attribut Commence par une minuscule nom, nombrePattes Fichier MÃªme nom que la classe publique Animal.java BoolÃ©en Tout en minuscules boolean, true, false ChaÃ®ne Grand S String Taille dâ€™un tableau .length sans parenthÃ¨ses notes.length 8. Exercices Exercice 1 â€” CrÃ©er une classe simple Niveau : â­ DÃ©butant\nCrÃ©ez une classe appelÃ©e Voiture (dans le fichier Voiture.java) avec les attributs suivants :\nmarque (String) modele (String) annee (int) couleur (String) Puis, dans votre classe Main, crÃ©ez trois voitures diffÃ©rentes et affichage chacun de leurs attributs avec System.out.println.\nSortie attendue :\nVoiture 1: Toyota Camry 2020, Couleur: Rouge\rVoiture 2: Honda Civic 2019, Couleur: Bleu\rVoiture 3: Ford Mustang 2022, Couleur: Noir Exercice 2 â€” Classe avec mÃ©thodes Niveau : â­ DÃ©butant\nReprenez la classe Voiture de lâ€™exercice 1 et ajoutez :\nUne mÃ©thode afficherInfo() qui affiche toutes les informations de la voiture sur la console. Une mÃ©thode estAncienne() qui retourne true si lâ€™annÃ©e est avant 2015, false sinon. Testez avec ces voitures dans Main :\nVoiture v1 = new Voiture(); v1.marque = \"Toyota\"; v1.modele = \"Camry\"; v1.annee = 2020; v1.couleur = \"Rouge\"; Voiture v2 = new Voiture(); v2.marque = \"Ford\"; v2.modele = \"Model T\"; v2.annee = 2010; v2.couleur = \"Noir\"; v1.afficherInfo(); v2.afficherInfo(); System.out.println(\"v1 est ancienne: \" + v1.estAncienne()); // false System.out.println(\"v2 est ancienne: \" + v2.estAncienne()); // true Exercice 3 â€” Ajout dâ€™un constructeur Niveau : â­â­ IntermÃ©diaire\nModifiez la classe Voiture pour quâ€™elle possÃ¨de un constructeur qui prend les quatre attributs en paramÃ¨tres. Puis crÃ©ez trois voitures en utilisant le constructeur.\nLa crÃ©ation doit ressembler Ã  ceci :\nVoiture v1 = new Voiture(\"Toyota\", \"Camry\", 2020, \"Rouge\"); Exercice 4 â€” Classe CompteBancaire Niveau : â­â­ IntermÃ©diaire\nCrÃ©ez une classe appelÃ©e CompteBancaire avec :\nAttributs :\ntitulaire (String) â€” le nom du propriÃ©taire solde (double) â€” le montant dâ€™argent dans le compte Constructeur :\nPrend titulaire et un soldeInitial en paramÃ¨tres MÃ©thodes :\ndeposer(double montant) â€” ajoute de lâ€™argent au solde. Si le montant est nÃ©gatif ou zÃ©ro, afficher un message dâ€™erreur. retirer(double montant) â€” retire de lâ€™argent du solde. Si le montant dÃ©passe le solde actuel, afficher â€œFonds insuffisantsâ€. Si le montant est nÃ©gatif ou zÃ©ro, afficher un message dâ€™erreur. afficherSolde() â€” affiche le nom du titulaire et le solde actuel. Testez avec ce code dans Main :\nCompteBancaire compte = new CompteBancaire(\"Alice\", 1000.0); compte.afficherSolde(); // Alice - Solde: 1000.00 compte.deposer(500.0); compte.afficherSolde(); // Alice - Solde: 1500.00 compte.retirer(200.0); compte.afficherSolde(); // Alice - Solde: 1300.00 compte.retirer(2000.0); // Affiche: Fonds insuffisants compte.afficherSolde(); // Alice - Solde: 1300.00 (inchangÃ©) Exercice 5 â€” Classe avec tableau interne Niveau : â­â­ IntermÃ©diaire\nCrÃ©ez une classe appelÃ©e Cuisine qui reprÃ©sente une cuisine avec une liste de recettes.\nAttributs :\nnom (String) â€” le nom de la cuisine (ex: â€œCuisine de Marieâ€) recettes (String[]) â€” un tableau de noms de recettes Constructeur :\nPrend uniquement le nom. Le tableau recettes commence vide. MÃ©thodes :\najouterRecette(String recette) â€” ajoute une recette au tableau (mÃªme logique que ajouterNote dans la classe Etudiant). afficherRecettes() â€” affiche le nom de la cuisine puis toutes les recettes numÃ©rotÃ©es. combienDeRecettes() â€” retourne le nombre de recettes (int). Testez dans Main :\nCuisine cuisine = new Cuisine(\"Cuisine de Marie\"); cuisine.ajouterRecette(\"Pates carbonara\"); cuisine.ajouterRecette(\"Salade Cesar\"); cuisine.ajouterRecette(\"Soupe a l'oignon\"); cuisine.afficherRecettes(); // Cuisine de Marie a 3 recette(s): // 1. Pates carbonara // 2. Salade Cesar // 3. Soupe a l'oignon Exercice 6 â€” Plusieurs objets dans un tableau Niveau : â­â­â­ AvancÃ©\nUtilisez la classe CompteBancaire de lâ€™exercice 4. Dans votre Main :\nCrÃ©ez un tableau de 4 comptes bancaires avec des noms et des soldes initiaux diffÃ©rents. Parcourez le tableau et affichage le solde de chaque compte. Parcourez le tableau et trouvez le compte avec le plus grand solde. Affichage son nom et son solde. Parcourez le tableau et calculez la somme totale de tous les soldes. Sortie attendue :\n--- Tous les comptes ---\rAlice - Solde: 1500.00\rBob - Solde: 3200.00\rCharlie - Solde: 750.00\rDiana - Solde: 4100.00\r--- Resultats ---\rPlus grand solde: Diana - 4100.00\rSomme totale: 9550.00 Exercice 7 â€” Classe complÃ¨te : Animal Niveau : â­â­â­ AvancÃ©\nReprenez la classe Animal du cours (celle avec le constructeur). Dans votre Main, crÃ©ez un tableau de 5 animaux diffÃ©rents, puis :\nFaites parler chaque animal avec faireSon(). Comptez combien dâ€™animaux sont quadrupÃ¨des avec estQuadrupede(). Trouvez lâ€™animal avec le plus grand nombre de pattes. Sortie attendue :\n--- Tous les animaux parlent ---\rRex dit: Ouaf!\rWhiskers dit: Miaou!\rSlinky dit: Ssss!\rTweety dit: Piou!\rCharlotte dit: ...\r--- Statistiques ---\rNombre de quadrupedes: 2\rAnimal avec le plus de pattes: Charlotte (8 pattes) Solutions des exercices Note pour lâ€™Ã©tudiant : Essayez de rÃ©soudre les exercices vous-mÃªmes avant de regarder les solutions ! Câ€™est la meilleure faÃ§on dâ€™apprendre.\nSolution â€” Exercice 1 Fichier : Voiture.java\npublic class Voiture { public String marque; public String modele; public int annee; public String couleur; } Fichier : Main.java\npublic class Main { public static void main(String[] args) { Voiture v1 = new Voiture(); v1.marque = \"Toyota\"; v1.modele = \"Camry\"; v1.annee = 2020; v1.couleur = \"Rouge\"; Voiture v2 = new Voiture(); v2.marque = \"Honda\"; v2.modele = \"Civic\"; v2.annee = 2019; v2.couleur = \"Bleu\"; Voiture v3 = new Voiture(); v3.marque = \"Ford\"; v3.modele = \"Mustang\"; v3.annee = 2022; v3.couleur = \"Noir\"; System.out.println(\"Voiture 1: \" + v1.marque + \" \" + v1.modele + \" \" + v1.annee + \", Couleur: \" + v1.couleur); System.out.println(\"Voiture 2: \" + v2.marque + \" \" + v2.modele + \" \" + v2.annee + \", Couleur: \" + v2.couleur); System.out.println(\"Voiture 3: \" + v3.marque + \" \" + v3.modele + \" \" + v3.annee + \", Couleur: \" + v3.couleur); } } Solution â€” Exercice 2 Fichier : Voiture.java\npublic class Voiture { public String marque; public String modele; public int annee; public String couleur; public void afficherInfo() { System.out.println(marque + \" \" + modele + \" \" + annee + \", Couleur: \" + couleur); } public boolean estAncienne() { return annee \u003c 2015; } } Fichier : Main.java\npublic class Main { public static void main(String[] args) { Voiture v1 = new Voiture(); v1.marque = \"Toyota\"; v1.modele = \"Camry\"; v1.annee = 2020; v1.couleur = \"Rouge\"; Voiture v2 = new Voiture(); v2.marque = \"Ford\"; v2.modele = \"Model T\"; v2.annee = 2010; v2.couleur = \"Noir\"; v1.afficherInfo(); v2.afficherInfo(); System.out.println(\"v1 est ancienne: \" + v1.estAncienne()); System.out.println(\"v2 est ancienne: \" + v2.estAncienne()); } } Solution â€” Exercice 3 Fichier : Voiture.java\npublic class Voiture { public String marque; public String modele; public int annee; public String couleur; public Voiture(String marque, String modele, int annee, String couleur) { this.marque = marque; this.modele = modele; this.annee = annee; this.couleur = couleur; } public void afficherInfo() { System.out.println(marque + \" \" + modele + \" \" + annee + \", Couleur: \" + couleur); } public boolean estAncienne() { return annee \u003c 2015; } } Fichier : Main.java\npublic class Main { public static void main(String[] args) { Voiture v1 = new Voiture(\"Toyota\", \"Camry\", 2020, \"Rouge\"); Voiture v2 = new Voiture(\"Honda\", \"Civic\", 2019, \"Bleu\"); Voiture v3 = new Voiture(\"Ford\", \"Mustang\", 2022, \"Noir\"); v1.afficherInfo(); v2.afficherInfo(); v3.afficherInfo(); } } Solution â€” Exercice 4 Fichier : CompteBancaire.java\npublic class CompteBancaire { public String titulaire; public double solde; public CompteBancaire(String titulaire, double soldeInitial) { this.titulaire = titulaire; this.solde = soldeInitial; } public void deposer(double montant) { if (montant \u003c= 0) { System.out.println(\"Erreur: le montant doit etre positif\"); return; } solde += montant; System.out.printf(\"Depot de %.2f effectue%n\", montant); } public void retirer(double montant) { if (montant \u003c= 0) { System.out.println(\"Erreur: le montant doit etre positif\"); return; } if (montant \u003e solde) { System.out.println(\"Fonds insuffisants\"); return; } solde -= montant; System.out.printf(\"Retrait de %.2f effectue%n\", montant); } public void afficherSolde() { System.out.printf(\"%s - Solde: %.2f%n\", titulaire, solde); } } Fichier : Main.java\npublic class Main { public static void main(String[] args) { CompteBancaire compte = new CompteBancaire(\"Alice\", 1000.0); compte.afficherSolde(); compte.deposer(500.0); compte.afficherSolde(); compte.retirer(200.0); compte.afficherSolde(); compte.retirer(2000.0); compte.afficherSolde(); } } Solution â€” Exercice 5 Fichier : Cuisine.java\npublic class Cuisine { public String nom; public String[] recettes; public Cuisine(String nom) { this.nom = nom; this.recettes = new String[0]; } public void ajouterRecette(String recette) { String[] nouvelles_recettes = new String[recettes.length + 1]; for (int i = 0; i \u003c recettes.length; i++) { nouvelles_recettes[i] = recettes[i]; } nouvelles_recettes[recettes.length] = recette; recettes = nouvelles_recettes; } public void afficherRecettes() { System.out.println(nom + \" a \" + recettes.length + \" recette(s):\"); for (int i = 0; i \u003c recettes.length; i++) { System.out.println(\" \" + (i + 1) + \". \" + recettes[i]); } } public int combienDeRecettes() { return recettes.length; } } Fichier : Main.java\npublic class Main { public static void main(String[] args) { Cuisine cuisine = new Cuisine(\"Cuisine de Marie\"); cuisine.ajouterRecette(\"Pates carbonara\"); cuisine.ajouterRecette(\"Salade Cesar\"); cuisine.ajouterRecette(\"Soupe a l'oignon\"); cuisine.afficherRecettes(); System.out.println(\"Nombre de recettes: \" + cuisine.combienDeRecettes()); } } Solution â€” Exercice 6 Fichier : Main.java\npublic class Main { public static void main(String[] args) { CompteBancaire[] comptes = new CompteBancaire[4]; comptes[0] = new CompteBancaire(\"Alice\", 1500.0); comptes[1] = new CompteBancaire(\"Bob\", 3200.0); comptes[2] = new CompteBancaire(\"Charlie\", 750.0); comptes[3] = new CompteBancaire(\"Diana\", 4100.0); // Afficher tous les comptes System.out.println(\"--- Tous les comptes ---\"); for (CompteBancaire compte : comptes) { compte.afficherSolde(); } // Trouver le plus grand solde CompteBancaire plusGrand = comptes[0]; for (CompteBancaire compte : comptes) { if (compte.solde \u003e plusGrand.solde) { plusGrand = compte; } } // Calculer la somme totale double somme = 0; for (CompteBancaire compte : comptes) { somme += compte.solde; } System.out.println(\"\\n--- Resultats ---\"); System.out.printf(\"Plus grand solde: %s - %.2f%n\", plusGrand.titulaire, plusGrand.solde); System.out.printf(\"Somme totale: %.2f%n\", somme); } } Solution â€” Exercice 7 Fichier : Main.java\npublic class Main { public static void main(String[] args) { Animal[] animaux = new Animal[5]; animaux[0] = new Animal(\"Rex\", \"Chien\", 4, \"Ouaf!\"); animaux[1] = new Animal(\"Whiskers\", \"Chat\", 4, \"Miaou!\"); animaux[2] = new Animal(\"Slinky\", \"Serpent\", 0, \"Ssss!\"); animaux[3] = new Animal(\"Tweety\", \"Oiseau\", 2, \"Piou!\"); animaux[4] = new Animal(\"Charlotte\", \"Araignee\", 8, \"...\"); // Faire parler tous les animaux System.out.println(\"--- Tous les animaux parlent ---\"); for (Animal a : animaux) { a.faireSon(); } // Compter les quadrupÃ¨des int compteurQuadrupedes = 0; for (Animal a : animaux) { if (a.estQuadrupede()) { compteurQuadrupedes++; } } // Trouver l'animal avec le plus de pattes Animal plusDePattes = animaux[0]; for (Animal a : animaux) { if (a.nombrePattes \u003e plusDePattes.nombrePattes) { plusDePattes = a; } } System.out.println(\"\\n--- Statistiques ---\"); System.out.println(\"Nombre de quadrupedes: \" + compteurQuadrupedes); System.out.println(\"Animal avec le plus de pattes: \" + plusDePattes.nom + \" (\" + plusDePattes.nombrePattes + \" pattes)\"); } }",
    "description": "Avant de commencer : pourquoi la POO ? Jusquâ€™Ã  prÃ©sent, vous avez Ã©crit des programmes avec des variables et des mÃ©thodes statiques. Ã‡a marche trÃ¨s bien pour des programmes simples. Mais imaginez que vous deviez gÃ©rer une liste de 500 Ã©tudiants, chacun avec un nom, un numÃ©ro dâ€™Ã©tudiant et une note.\nAvec des variables sÃ©parÃ©es, Ã§a ressemblerait Ã  Ã§a :",
    "tags": [],
    "title": "Introduction Ã  POO",
    "uri": "/420-210/poo/index.html"
  },
  {
    "breadcrumb": "Programmation orientÃ©e objet",
    "content": "ğŸ® MISSION SPÃ‰CIALE : Lâ€™Ã‰VOLUTION DES COLLECTIONS ! ğŸš€ Du Tableau Statique Ã  lâ€™ArrayList Dynamique ğŸš€ ğŸµ Musique Ã‰pique de Transformation ğŸµ ğŸµ ThÃ¨me de transformation\rğŸ“Š Tableau de Bord du Cours ğŸ¯ Progression de la Mission\râ­ Niveau Actuel : 1 - Apprenti des Collections\nğŸ† Points : 0 / 100\nğŸ¯ Objectif : MaÃ®triser ArrayList\nğŸ—ºï¸ CARTE DE LA MISSION ğŸ“¦ PHASE 1 âš ï¸ PHASE 2 âœ¨ PHASE 3 ğŸ”„ PHASE 4\rLes Tableaux Les ProblÃ¨mes ArrayList Magique Grande Transition\r[DÃ©couverte] [Boss Fight] [Nouveau Pouvoir] [Transformation]\r15 pts 15 pts 35 pts 35 pts\rTOTAL : 100 POINTS POUR DEVENIR MAÃTRE ! ğŸ“¦ PHASE 1 - DÃ‰COUVERTE DES TABLEAUX ğŸ“œ Histoire â€œTu es un gestionnaire de bibliothÃ¨que. Ta premiÃ¨re arme : le TABLEAU. Puissant maisâ€¦ limitÃ© ! DÃ©couvre ses secrets et ses faiblessesâ€¦â€\nğŸµ Musique Phase 1\rğŸ’ Points disponibles : 15 pts | â±ï¸ Temps : 20 minutes ğŸ¯ QuÃªte 1.1 : Comprendre les Tableaux ğŸ“ Le Tableau Statique Un tableau est comme une Ã©tagÃ¨re avec un nombre fixe de cases. Une fois construite, tu ne peux pas ajouter de cases !\nImagine :\nâ”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”\râ”‚ 0 â”‚ 1 â”‚ 2 â”‚ 3 â”‚ 4 â”‚ â† Indices\râ”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤\râ”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â† 5 cases FIXES\râ””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜ ğŸ“ Exemple Concret : Ta Collection de Jeux VidÃ©o // Tu veux stocker 5 jeux maximum String[] jeux = new String[5]; jeux[0] = \"Zelda\"; jeux[1] = \"Mario Kart\"; jeux[2] = \"Pokemon\"; jeux[3] = \"Minecraft\"; jeux[4] = \"Fortnite\"; // Afficher tous les jeux for (int i = 0; i \u003c jeux.length; i++) { System.out.println(\"ğŸ® Jeu \" + (i+1) + \" : \" + jeux[i]); } Sortie :\nğŸ® Jeu 1 : Zelda\rğŸ® Jeu 2 : Mario Kart\rğŸ® Jeu 3 : Pokemon\rğŸ® Jeu 4 : Minecraft\rğŸ® Jeu 5 : Fortnite ğŸ® MINI-JEU 1 : CrÃ©ation de Tableau Mission : CrÃ©e un tableau pour stocker tes 3 snacks prÃ©fÃ©rÃ©s !\npublic class MiniJeu1 { public static void main(String[] args) { // ğŸ¯ TON CODE ICI // 1. CrÃ©e un tableau de 3 Strings nommÃ© \"snacks\" // 2. Ajoute tes 3 snacks prÃ©fÃ©rÃ©s // 3. Affiche-les avec une boucle System.out.println(\"ğŸ¿ MES SNACKS PRÃ‰FÃ‰RÃ‰S :\"); System.out.println(\"\\nâœ… +5 points gagnÃ©s !\"); } } ğŸ’¡ Solution\rpublic class MiniJeu1 { public static void main(String[] args) { String[] snacks = new String[3]; snacks[0] = \"Chips\"; snacks[1] = \"Chocolat\"; snacks[2] = \"Cookies\"; System.out.println(\"ğŸ¿ MES SNACKS PRÃ‰FÃ‰RÃ‰S :\"); for (int i = 0; i \u003c snacks.length; i++) { System.out.println((i+1) + \". \" + snacks[i]); } System.out.println(\"\\nâœ… +5 points gagnÃ©s !\"); } } âœ… Checklist : Tableau crÃ©Ã© avec taille fixe 3 Ã©lÃ©ments ajoutÃ©s Boucle for qui affiche tout Programme compile et fonctionne ğŸ† RÃ©compense : +5 points\nâš ï¸ PHASE 2 - LES 3 BOSS DE LA LIMITATION ğŸ“œ Histoire â€œTu commences Ã  utiliser tes tableauxâ€¦ mais des BOSS apparaissent ! Trois ennemis redoutables qui vont te bloquer. Peux-tu les vaincre ?â€\nğŸµ Musique de combat\rğŸ’ Points disponibles : 15 pts | â±ï¸ Temps : 30 minutes ğŸ‘¹ BOSS 1 : La Taille Fixe Impitoyable ğŸ’€ Attaque du Boss â€œHa ha ha ! Ta collection de jeux est limitÃ©e Ã  5 ! Tu ne pourras JAMAIS en ajouter plus !â€\nğŸ® DÃ©monstration du ProblÃ¨me public class Boss1TailleFixe { public static void main(String[] args) { String[] jeux = new String[5]; // 5 places maximum jeux[0] = \"Zelda\"; jeux[1] = \"Mario Kart\"; jeux[2] = \"Pokemon\"; jeux[3] = \"Minecraft\"; jeux[4] = \"Fortnite\"; System.out.println(\"âœ… 5 jeux ajoutÃ©s !\"); // Oh non ! Un nouveau jeu sort ! jeux[5] = \"Valorant\"; // ğŸ’¥ BOOM ! ERREUR ! // ğŸ”¥ ArrayIndexOutOfBoundsException } } RÃ©sultat :\nâœ… 5 jeux ajoutÃ©s !\rğŸ’¥ Exception in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: 5 ğŸ˜¢ Le ProblÃ¨me Tu ne peux PAS dÃ©passer la taille initiale ! Si tu veux ajouter un 6Ã¨me jeu, câ€™est IMPOSSIBLE sans :\nCrÃ©er un NOUVEAU tableau plus grand COPIER tous les anciens Ã©lÃ©ments Ajouter le nouvel Ã©lÃ©ment Câ€™est LONG et COMPLIQUÃ‰ ! ğŸ˜«\nğŸ‘¹ BOSS 2 : Le Compteur Obligatoire ğŸ’€ Attaque du Boss â€œTu crois savoir combien de jeux tu as ? FAUX ! Le tableau te ment avec sa longueur !â€\nğŸ® DÃ©monstration du ProblÃ¨me public class Boss2CompteurObligatoire { public static void main(String[] args) { String[] jeux = new String[10]; // CapacitÃ© : 10 // Mais on n'ajoute que 3 jeux jeux[0] = \"Zelda\"; jeux[1] = \"Mario Kart\"; jeux[2] = \"Pokemon\"; System.out.println(\"Combien de jeux ? \" + jeux.length); // Affiche : 10 âŒ (FAUX ! On n'en a que 3 !) // Tu DOIS gÃ©rer un compteur toi-mÃªme ! int nombreJeux = 3; // ğŸ˜¤ Fastidieux ! System.out.println(\"Vrais jeux : \" + nombreJeux); } } ğŸ˜¢ Le ProblÃ¨me jeux.length te donne la capacitÃ© totale, pas le nombre rÃ©el ! Tu dois crÃ©er et gÃ©rer un compteur sÃ©parÃ© Tu dois penser Ã  lâ€™incrÃ©menter Ã  chaque ajout Tu dois lâ€™utiliser dans toutes tes boucles Câ€™est une SOURCE Dâ€™ERREURS ! ğŸ›\nğŸ‘¹ BOSS 3 : Le Suppresseur Impossible ğŸ’€ Attaque du Boss â€œTu veux SUPPRIMER un jeu ? Mouahahaha ! PrÃ©pare-toi Ã  souffrir !â€\nğŸ® DÃ©monstration du ProblÃ¨me public class Boss3SuppressionDifficile { public static void main(String[] args) { String[] jeux = new String[5]; jeux[0] = \"Zelda\"; jeux[1] = \"Mario Kart\"; jeux[2] = \"Pokemon\"; jeux[3] = \"Minecraft\"; jeux[4] = \"Fortnite\"; // Je veux supprimer \"Pokemon\" (index 2) // Il n'y a PAS de mÃ©thode simple ! // Il faut : // 1. DÃ©caler tous les Ã©lÃ©ments aprÃ¨s for (int i = 2; i \u003c 4; i++) { jeux[i] = jeux[i + 1]; } // 2. Mettre null Ã  la fin jeux[4] = null; // 3. DÃ©crÃ©menter le compteur manuellement // ğŸ˜« C'EST HORRIBLE ! } } ğŸ˜¢ Le ProblÃ¨me Pas de mÃ©thode pour supprimer facilement Tu dois tout dÃ©caler manuellement Tu dois gÃ©rer les indices toi-mÃªme Risque dâ€™erreurs trÃ¨s Ã©levÃ© Câ€™est un CAUCHEMAR ! ğŸ˜±\nğŸ® BOSS FIGHT : Affronte les 3 Boss ! Mission : CrÃ©e une classe CollectionJeux avec tableau et essaie de survivre !\npublic class CollectionJeux { private String[] jeux; private int nombreJeux; public CollectionJeux(int capacite) { this.jeux = new String[capacite]; this.nombreJeux = 0; } // ğŸ¯ DÃ©fi 1 : Ajoute cette mÃ©thode public void ajouterJeu(String jeu) { // VÃ©rifie s'il y a de la place // Si oui : ajoute et incrÃ©mente // Si non : affiche \"Collection pleine !\" } // ğŸ¯ DÃ©fi 2 : Ajoute cette mÃ©thode public void afficherJeux() { // Affiche tous les jeux avec une boucle // Utilise nombreJeux, pas jeux.length ! } } ğŸ’¡ Solution du Boss Fight\rpublic class CollectionJeux { private String[] jeux; private int nombreJeux; public CollectionJeux(int capacite) { this.jeux = new String[capacite]; this.nombreJeux = 0; } public void ajouterJeu(String jeu) { if (nombreJeux \u003c jeux.length) { jeux[nombreJeux] = jeu; nombreJeux++; System.out.println(\"âœ… \" + jeu + \" ajoutÃ© !\"); } else { System.out.println(\"âŒ Collection pleine !\"); } } public void afficherJeux() { System.out.println(\"\\nğŸ® MA COLLECTION :\"); for (int i = 0; i \u003c nombreJeux; i++) { System.out.println((i+1) + \". \" + jeux[i]); } System.out.println(\"Total : \" + nombreJeux + \"/\" + jeux.length); } public static void main(String[] args) { CollectionJeux maCollection = new CollectionJeux(3); maCollection.ajouterJeu(\"Zelda\"); maCollection.ajouterJeu(\"Mario\"); maCollection.ajouterJeu(\"Pokemon\"); maCollection.ajouterJeu(\"Fortnite\"); // Va Ã©chouer ! maCollection.afficherJeux(); } } ğŸ† Si tu as survÃ©cu : +10 points !\nâœ¨ PHASE 3 - Lâ€™ARME ULTIME : ARRAYLIST ! ğŸ“œ Histoire â€œUn sorcier apparaÃ®t et te donne une ARME LÃ‰GENDAIRE : lâ€™ArrayList ! Cette arme magique DÃ‰TRUIT les 3 Boss dâ€™un seul coup !â€\nğŸµ Musique de victoire\rğŸ’ Points disponibles : 35 pts | â±ï¸ Temps : 45 minutes ğŸ”® Lâ€™Arme Magique : ArrayList âš”ï¸ SUPER-POUVOIRS Dâ€™ARRAYLIST âœ¨ Taille DYNAMIQUE - Sâ€™agrandit automatiquement !\nâœ¨ Compteur INTÃ‰GRÃ‰ - .size() te donne le vrai nombre !\nâœ¨ Suppression FACILE - .remove() fait tout le travail !\nâœ¨ MÃ©thodes MAGIQUES - Plein de pouvoirs en plus !\nğŸ¯ QuÃªte 3.1 : Premier Contact avec ArrayList ğŸ”§ Anatomie de lâ€™Arme import java.util.ArrayList; // ğŸ”® Invocation de l'arme ArrayList\u003cType\u003e nom = new ArrayList\u003cType\u003e(); DÃ©cortiquons :\nimport : Invoque lâ€™arme depuis la bibliothÃ¨que Java ArrayList\u003cType\u003e : Arme qui contient des Ã©lÃ©ments de type Type \u003cType\u003e : Peut Ãªtre String, Integer, Livre, etc. new ArrayList\u003cType\u003e() : Forge une nouvelle arme ! ğŸ® MINI-JEU 2 : Ta PremiÃ¨re ArrayList Mission : RecrÃ©er ta collection de jeux, mais SANS LIMITES !\nimport java.util.ArrayList; public class MiniJeu2 { public static void main(String[] args) { // ğŸ”® CrÃ©e ton ArrayList magique ArrayList\u003cString\u003e jeux = new ArrayList\u003cString\u003e(); // âœ¨ Ajoute autant de jeux que tu veux ! jeux.add(\"Zelda\"); jeux.add(\"Mario Kart\"); jeux.add(\"Pokemon\"); jeux.add(\"Minecraft\"); jeux.add(\"Fortnite\"); jeux.add(\"Valorant\"); // âœ… Fonctionne ! jeux.add(\"Among Us\"); // âœ… Fonctionne ! jeux.add(\"Roblox\"); // âœ… Fonctionne ! // ... INFINI ! ğŸš€ // ğŸ“Š Affiche le nombre RÃ‰EL de jeux System.out.println(\"ğŸ® Nombre de jeux : \" + jeux.size()); // ğŸ¯ Affiche tous les jeux System.out.println(\"\\nâœ¨ MA COLLECTION ILLIMITÃ‰E :\"); for (int i = 0; i \u003c jeux.size(); i++) { System.out.println((i+1) + \". \" + jeux.get(i)); } System.out.println(\"\\nğŸ† +10 points gagnÃ©s !\"); } } Sortie :\nğŸ® Nombre de jeux : 8\râœ¨ MA COLLECTION ILLIMITÃ‰E :\r1. Zelda\r2. Mario Kart\r3. Pokemon\r4. Minecraft\r5. Fortnite\r6. Valorant\r7. Among Us\r8. Roblox\rğŸ† +10 points gagnÃ©s ! ğŸ¯ QuÃªte 3.2 : Les Sorts de lâ€™ArrayList ğŸª„ Sort 1 : add() - Invocation ArrayList\u003cString\u003e pokemons = new ArrayList\u003cString\u003e(); pokemons.add(\"Pikachu\"); pokemons.add(\"Charizard\"); pokemons.add(\"Mewtwo\"); // Liste : [Pikachu, Charizard, Mewtwo] ğŸª„ Sort 2 : get() - Localisation String premier = pokemons.get(0); // \"Pikachu\" String deuxieme = pokemons.get(1); // \"Charizard\" ğŸª„ Sort 3 : size() - Compte Magique int nombre = pokemons.size(); // 3 ğŸª„ Sort 4 : remove() - Bannissement pokemons.remove(1); // Supprime \"Charizard\" // Liste : [Pikachu, Mewtwo] // Ou par nom : pokemons.remove(\"Mewtwo\"); // Liste : [Pikachu] ğŸª„ Sort 5 : set() - Transformation pokemons.add(\"Bulbasaur\"); pokemons.set(1, \"Venusaur\"); // Remplace index 1 // Liste : [Pikachu, Venusaur] ğŸª„ Sort 6 : contains() - DÃ©tection boolean aPikachu = pokemons.contains(\"Pikachu\"); // true boolean aMewtwo = pokemons.contains(\"Mewtwo\"); // false ğŸª„ Sort 7 : clear() - Purge Totale pokemons.clear(); // Vide tout ! // Liste : [] ğŸª„ Sort 8 : isEmpty() - VÃ©rification du Vide boolean vide = pokemons.isEmpty(); // true ğŸ® ENTRAÃNEMENT AU COMBAT : MaÃ®trise Tous les Sorts ! import java.util.ArrayList; public class EntrainementSorts { public static void main(String[] args) { ArrayList\u003cString\u003e inventaire = new ArrayList\u003cString\u003e(); System.out.println(\"=== ğŸ’ GESTION D'INVENTAIRE ===\\n\"); // Sort 1 : add() System.out.println(\"ğŸ“¦ Ajout d'objets...\"); inventaire.add(\"Ã‰pÃ©e\"); inventaire.add(\"Bouclier\"); inventaire.add(\"Potion\"); System.out.println(\"Inventaire : \" + inventaire); // Sort 3 : size() System.out.println(\"\\nğŸ“Š Nombre d'objets : \" + inventaire.size()); // Sort 2 : get() System.out.println(\"\\nğŸ” Premier objet : \" + inventaire.get(0)); // Sort 5 : set() System.out.println(\"\\nğŸ”„ AmÃ©lioration de l'Ã©pÃ©e...\"); inventaire.set(0, \"Ã‰pÃ©e LÃ©gendaire\"); System.out.println(\"Inventaire : \" + inventaire); // Sort 6 : contains() System.out.println(\"\\nğŸ” A un bouclier ? \" + inventaire.contains(\"Bouclier\")); // Sort 4 : remove() System.out.println(\"\\nğŸ—‘ï¸ Utilisation de la potion...\"); inventaire.remove(\"Potion\"); System.out.println(\"Inventaire : \" + inventaire); // Sort 1 (insertion) System.out.println(\"\\nâ• Ajout d'une armure...\"); inventaire.add(1, \"Armure\"); System.out.println(\"Inventaire : \" + inventaire); System.out.println(\"\\nâœ… +15 points de maÃ®trise !\"); } } ğŸ† Si tu maÃ®trises tous les sorts : +15 points !\nğŸ“Š Tableau Comparatif : Avant vs AprÃ¨s Action ğŸ˜° Tableau (Difficile) ğŸ˜ ArrayList (Facile) Ajouter arr[i] = x; i++; ğŸ˜« list.add(x); âœ¨ Obtenir arr[i] âœ… list.get(i) âœ… Taille rÃ©elle Besoin de compteur ğŸ˜¤ list.size() âœ¨ Supprimer DÃ©calage manuel ğŸ˜± list.remove(i) âœ¨ VÃ©rifier contenu Boucle manuelle ğŸ˜“ list.contains(x) âœ¨ CapacitÃ© Fixe forever ğŸ’€ Dynamique ğŸš€ ğŸ”„ PHASE 4 - LA GRANDE TRANSFORMATION ğŸ“œ Histoire â€œTu possÃ¨des maintenant lâ€™arme ultime ! Il est temps de TRANSFORMER tout ton ancien code de tableau en ArrayList puissant !â€\nğŸµ Musique de transformation\rğŸ’ Points disponibles : 35 pts | â±ï¸ Temps : 1 heure ğŸ¯ Mission Finale : Convertis Ta Collection ! ğŸ“¦ AVANT : Code avec Tableau public class CollectionJeuxTableau { private String[] jeux; private int nombreJeux; // ğŸ˜¤ Compteur obligatoire public CollectionJeuxTableau(int capacite) { this.jeux = new String[capacite]; // ğŸ˜¢ Taille fixe this.nombreJeux = 0; } public void ajouterJeu(String jeu) { if (nombreJeux \u003c jeux.length) { // ğŸš§ VÃ©rification jeux[nombreJeux] = jeu; // ğŸ“ Utilise [] nombreJeux++; // â• IncrÃ©ment manuel System.out.println(\"âœ… \" + jeu + \" ajoutÃ© !\"); } else { System.out.println(\"âŒ Collection pleine !\"); } } public void afficherJeux() { for (int i = 0; i \u003c nombreJeux; i++) { // âš ï¸ nombreJeux System.out.println((i+1) + \". \" + jeux[i]); // ğŸ“ [] } } public String chercherJeu(String nom) { for (int i = 0; i \u003c nombreJeux; i++) { // âš ï¸ nombreJeux if (jeux[i].equalsIgnoreCase(nom)) { // ğŸ“ [] return jeux[i]; } } return null; } } âœ¨ APRÃˆS : Code avec ArrayList (Ã€ TOI DE LE FAIRE !) import java.util.ArrayList; // ğŸ”® N'oublie pas ! public class CollectionJeuxArrayList { private ArrayList\u003cString\u003e jeux; // ğŸ¯ TON CODE : Change le type // Plus besoin de nombreJeux ! // ğŸ¯ TON CODE : Supprime cette ligne public CollectionJeuxArrayList() { // ğŸ¯ TON CODE : Plus de paramÃ¨tre capacite // ğŸ¯ TON CODE : Initialise l'ArrayList } public void ajouterJeu(String jeu) { // ğŸ¯ TON CODE : Utilise .add() // Plus besoin de if ! // Plus besoin de nombreJeux++ ! } public void afficherJeux() { // ğŸ¯ TON CODE : Utilise .size() et .get() } public String chercherJeu(String nom) { // ğŸ¯ TON CODE : Utilise for-each ou .get() } // ğŸ¯ BONUS : Ajoute cette mÃ©thode (impossible avec tableau!) public void supprimerJeu(String nom) { // ğŸ¯ TON CODE : Utilise .remove() } } ğŸ“‹ Checklist de Transformation Pour chaque mÃ©thode, vÃ©rifie :\nImport : import java.util.ArrayList; en haut Attribut : String[] â†’ ArrayList\u003cString\u003e Suppression : Enlever nombreJeux Constructeur : Plus de paramÃ¨tre capacite Initialisation : new ArrayList\u003cString\u003e() Ajouter : arr[i] = x â†’ list.add(x) Obtenir : arr[i] â†’ list.get(i) Taille : nombreJeux â†’ list.size() Supprimer : Ajouter mÃ©thode avec .remove() ğŸ Solution ComplÃ¨te de la Transformation\rimport java.util.ArrayList; public class CollectionJeuxArrayList { private ArrayList\u003cString\u003e jeux; public CollectionJeuxArrayList() { this.jeux = new ArrayList\u003cString\u003e(); } public void ajouterJeu(String jeu) { jeux.add(jeu); System.out.println(\"âœ… \" + jeu + \" ajoutÃ© !\"); } public void afficherJeux() { System.out.println(\"\\nğŸ® MA COLLECTION :\"); for (int i = 0; i \u003c jeux.size(); i++) { System.out.println((i+1) + \". \" + jeux.get(i)); } System.out.println(\"Total : \" + jeux.size() + \" jeux\"); } // Version alternative avec for-each (encore plus simple!) public void afficherJeuxSimple() { int compteur = 1; for (String jeu : jeux) { System.out.println(compteur + \". \" + jeu); compteur++; } } public String chercherJeu(String nom) { for (String jeu : jeux) { if (jeu.equalsIgnoreCase(nom)) { return jeu; } } return null; } // NOUVEAU : Impossible avec tableau ! public void supprimerJeu(String nom) { boolean supprime = jeux.remove(nom); if (supprime) { System.out.println(\"ğŸ—‘ï¸ \" + nom + \" supprimÃ© !\"); } else { System.out.println(\"âŒ \" + nom + \" non trouvÃ©.\"); } } // Test de la classe public static void main(String[] args) { CollectionJeuxArrayList maCollection = new CollectionJeuxArrayList(); // Ajouter AUTANT de jeux qu'on veut ! maCollection.ajouterJeu(\"Zelda\"); maCollection.ajouterJeu(\"Mario\"); maCollection.ajouterJeu(\"Pokemon\"); maCollection.ajouterJeu(\"Minecraft\"); maCollection.ajouterJeu(\"Fortnite\"); maCollection.ajouterJeu(\"Valorant\"); maCollection.ajouterJeu(\"Among Us\"); // ... INFINI ! Aucune limite ! maCollection.afficherJeux(); // Chercher un jeu String trouve = maCollection.chercherJeu(\"Mario\"); System.out.println(\"\\nğŸ” Recherche : \" + trouve); // Supprimer un jeu maCollection.supprimerJeu(\"Pokemon\"); maCollection.afficherJeux(); System.out.println(\"\\nğŸŠ TRANSFORMATION RÃ‰USSIE !\"); System.out.println(\"ğŸ† +35 points gagnÃ©s !\"); } } ğŸ† Transformation rÃ©ussie : +35 points !\nğŸŠ VICTOIRE FINALE ! ğŸ† FÃ‰LICITATIONS, MAÃTRE DES COLLECTIONS ! ğŸ† Tu as complÃ©tÃ© toutes les phases et gagnÃ© 100 POINTS !\nğŸ¯ Ce que tu maÃ®trises maintenant : âœ… Tableaux - Leur fonctionnement et leurs limites\nâœ… ArrayList - Lâ€™arme ultime des collections\nâœ… Transformation - Convertir ancien code en nouveau\nâœ… Tous les sorts - .add(), .get(), .remove(), etc.\nğŸŒŸ Nouveaux titres dÃ©bloquÃ©s : ğŸ“¦ MaÃ®tre des Tableaux âœ¨ Sorcier ArrayList ğŸ”„ Alchimiste du Code ğŸ‘‘ LÃ©gende des Collections ğŸ“š Guide de RÃ©fÃ©rence Rapide ğŸ”„ Tableau de Conversion Express // TABLEAU â†’ ARRAYLIST // DÃ©claration Type[] arr; â†’ ArrayList\u003cType\u003e list; // CrÃ©ation new Type[10]; â†’ new ArrayList\u003cType\u003e(); // Ajouter arr[i] = x; â†’ list.add(x); // Obtenir arr[i] â†’ list.get(i); // Taille arr.length â†’ list.size(); // Supprimer (compliquÃ©) â†’ list.remove(i); ou list.remove(obj); ğŸ® Mini-Jeux Bonus ğŸ† DÃ©fi 1 : Speed Coding (5 min) CrÃ©e un ArrayList de tes 5 films prÃ©fÃ©rÃ©s et affiche-les !\nğŸ† DÃ©fi 2 : Le Tri Magique (10 min) CrÃ©e un ArrayList de nombres, ajoute-en 10, puis affiche-les triÃ©s ! Astuce : Collections.sort(list);\nğŸ† DÃ©fi 3 : Le Filtrage (15 min) CrÃ©e un ArrayList de prÃ©noms, puis crÃ©e une mÃ©thode qui retourne seulement ceux qui commencent par â€˜Aâ€™ !\nğŸµ Playlist de Codage ğŸ§ Musiques pour chaque phase : ğŸ“¦ Phase 1 - DÃ©couverte calme âš ï¸ Phase 2 - Combat intense âœ¨ Phase 3 - Ã‰pique et magique ğŸ”„ Phase 4 - Transformation triomphale ğŸ’¬ Citations de Motivation â€œUn tableau est limitÃ©, mais un ArrayList est infini !â€ - MaÃ®tre Java\nâ€œPourquoi gÃ©rer un compteur quand .size() le fait pour toi ?â€ - Sorcier ArrayList\n\".remove() est le sort le plus puissant que tu apprendras aujourdâ€™hui.\" - Archimage Collections\nğŸŠ Prochaines Aventures Maintenant que tu maÃ®trises ArrayList, tu es prÃªt pour :\nğŸ‰ Niveau 5 du Projet - HÃ©ritage avec Documents ğŸŒˆ Niveau 6 du Projet - Polymorphisme ğŸ›ï¸ Niveau 7 du Projet - Classes abstraites Continue ton aventure, hÃ©ros du code ! âš”ï¸âœ¨\nCours crÃ©Ã© avec â¤ï¸ pour les futurs MaÃ®tres Java\nVersion GamifiÃ©e - 2024\nğŸ® Apprendre en sâ€™amusant ! ğŸ®",
    "description": "ğŸ® MISSION SPÃ‰CIALE : Lâ€™Ã‰VOLUTION DES COLLECTIONS ! ğŸš€ Du Tableau Statique Ã  lâ€™ArrayList Dynamique ğŸš€ ğŸµ Musique Ã‰pique de Transformation ğŸµ ğŸµ ThÃ¨me de transformation\rğŸ“Š Tableau de Bord du Cours ğŸ¯ Progression de la Mission\râ­ Niveau Actuel : 1 - Apprenti des Collections",
    "tags": [],
    "title": "Introduction Ã  POO",
    "uri": "/420-210/arrayList/index.html"
  },
  {
    "breadcrumb": "Programmation orientÃ©e objet",
    "content": "Introduction Ã  la POO â€” Partie 2 Introduction Dans la premiÃ¨re partie du cours, vous avez appris les bases de la POO :\nCrÃ©er des classes et des objets Utiliser des attributs et des mÃ©thodes CrÃ©er des constructeurs Manipuler des tableaux dâ€™objets Maintenant, nous allons voir les 4 grands principes de la POO :\nLâ€™encapsulation â€” protÃ©ger les donnÃ©es Lâ€™hÃ©ritage â€” rÃ©utiliser du code Le polymorphisme â€” utiliser des objets de maniÃ¨re flexible Lâ€™abstraction â€” dÃ©finir des contrats 1. Lâ€™encapsulation : protÃ©ger vos donnÃ©es 1.1 Le problÃ¨me avec public Jusquâ€™Ã  prÃ©sent, tous nos attributs Ã©taient public. Ã‡a veut dire que nâ€™importe qui peut les modifier :\npublic class CompteBancaire { public String titulaire; public double solde; public CompteBancaire(String titulaire, double soldeInitial) { this.titulaire = titulaire; this.solde = soldeInitial; } } Le problÃ¨me :\nCompteBancaire compte = new CompteBancaire(\"Alice\", 1000.0); // Quelqu'un peut faire n'importe quoi ! compte.solde = -5000.0; // Solde nÃ©gatif ?? Impossible ! compte.solde = 999999999.0; // Fraude ! 1.2 La solution : private On rend les attributs privÃ©s avec le mot-clÃ© private. Personne de lâ€™extÃ©rieur ne peut y accÃ©der directement.\npublic class CompteBancaire { private String titulaire; // PRIVATE maintenant private double solde; // PRIVATE maintenant public CompteBancaire(String titulaire, double soldeInitial) { this.titulaire = titulaire; this.solde = soldeInitial; } } Maintenant, ce code ne compile plus :\nCompteBancaire compte = new CompteBancaire(\"Alice\", 1000.0); compte.solde = -5000.0; // ERREUR DE COMPILATION ! 1.3 Les getters et setters Pour accÃ©der aux attributs privÃ©s de maniÃ¨re contrÃ´lÃ©e, on crÃ©e des mÃ©thodes publiques :\nGetter : mÃ©thode qui retourne la valeur dâ€™un attribut Setter : mÃ©thode qui modifie la valeur dâ€™un attribut (avec validation) public class CompteBancaire { private String titulaire; private double solde; public CompteBancaire(String titulaire, double soldeInitial) { this.titulaire = titulaire; this.solde = soldeInitial; } // GETTER pour titulaire public String getTitulaire() { return titulaire; } // GETTER pour solde public double getSolde() { return solde; } // SETTER pour solde (avec validation) public void setSolde(double nouveauSolde) { if (nouveauSolde \u003c 0) { System.out.println(\"Erreur: le solde ne peut pas etre negatif\"); return; } solde = nouveauSolde; } public void deposer(double montant) { if (montant \u003c= 0) { System.out.println(\"Erreur: montant invalide\"); return; } solde += montant; } public void retirer(double montant) { if (montant \u003c= 0 || montant \u003e solde) { System.out.println(\"Erreur: retrait impossible\"); return; } solde -= montant; } public void afficherSolde() { System.out.printf(\"%s - Solde: %.2f%n\", titulaire, solde); } } Utilisation :\nCompteBancaire compte = new CompteBancaire(\"Alice\", 1000.0); // AccÃ¨s en lecture System.out.println(compte.getTitulaire()); // Alice System.out.println(compte.getSolde()); // 1000.0 // Modification contrÃ´lÃ©e compte.setSolde(-500.0); // Affiche une erreur, ne modifie pas compte.deposer(500.0); // OK, solde devient 1500.0 1.4 Pourquoi lâ€™encapsulation ? Avantage Explication Protection EmpÃªche les modifications invalides Validation On peut vÃ©rifier les donnÃ©es avant de les accepter FlexibilitÃ© On peut changer lâ€™implÃ©mentation interne sans casser le code externe ContrÃ´le On dÃ©cide exactement ce qui est accessible de lâ€™extÃ©rieur RÃ¨gle dâ€™or : Tous les attributs doivent Ãªtre private. CrÃ©ez des getters/setters seulement si nÃ©cessaire.\n2. Lâ€™hÃ©ritage : rÃ©utiliser du code 2.1 Le problÃ¨me : code rÃ©pÃ©tÃ© Imaginez que vous devez crÃ©er plusieurs types de vÃ©hicules :\npublic class Voiture { private String marque; private String modele; private int annee; private int nombrePortes; // ... mÃ©thodes ... } public class Moto { private String marque; // RÃ©pÃ©tÃ© ! private String modele; // RÃ©pÃ©tÃ© ! private int annee; // RÃ©pÃ©tÃ© ! private boolean aSidecar; // ... mÃ©thodes ... } public class Camion { private String marque; // RÃ©pÃ©tÃ© ! private String modele; // RÃ©pÃ©tÃ© ! private int annee; // RÃ©pÃ©tÃ© ! private double chargeMaximale; // ... mÃ©thodes ... } Tous les vÃ©hicules ont une marque, un modÃ¨le et une annÃ©e. On se rÃ©pÃ¨te !\n2.2 La solution : lâ€™hÃ©ritage On crÃ©e une classe parent (ou superclasse) qui contient les attributs communs.\nFichier : Vehicule.java\npublic class Vehicule { private String marque; private String modele; private int annee; public Vehicule(String marque, String modele, int annee) { this.marque = marque; this.modele = modele; this.annee = annee; } public void afficherInfo() { System.out.println(marque + \" \" + modele + \" (\" + annee + \")\"); } // Getters public String getMarque() { return marque; } public String getModele() { return modele; } public int getAnnee() { return annee; } } Ensuite, les classes enfants (ou sous-classes) hÃ©ritent de la classe parent avec le mot-clÃ© extends :\nFichier : Voiture.java\npublic class Voiture extends Vehicule { private int nombrePortes; public Voiture(String marque, String modele, int annee, int nombrePortes) { super(marque, modele, annee); // Appelle le constructeur du parent this.nombrePortes = nombrePortes; } public int getNombrePortes() { return nombrePortes; } } Fichier : Moto.java\npublic class Moto extends Vehicule { private boolean aSidecar; public Moto(String marque, String modele, int annee, boolean aSidecar) { super(marque, modele, annee); this.aSidecar = aSidecar; } public boolean aSidecar() { return aSidecar; } } Fichier : Camion.java\npublic class Camion extends Vehicule { private double chargeMaximale; public Camion(String marque, String modele, int annee, double chargeMaximale) { super(marque, modele, annee); this.chargeMaximale = chargeMaximale; } public double getChargeMaximale() { return chargeMaximale; } } 2.3 Le mot-clÃ© super Le mot-clÃ© super permet dâ€™appeler le constructeur de la classe parent.\npublic Voiture(String marque, String modele, int annee, int nombrePortes) { super(marque, modele, annee); // Initialise les attributs du parent this.nombrePortes = nombrePortes; // Initialise l'attribut spÃ©cifique } Important : Lâ€™appel Ã  super() doit Ãªtre la premiÃ¨re ligne du constructeur de la classe enfant.\n2.4 Utilisation public class Main { public static void main(String[] args) { Voiture maVoiture = new Voiture(\"Toyota\", \"Camry\", 2020, 4); Moto maMoto = new Moto(\"Harley\", \"Sportster\", 2019, false); Camion monCamion = new Camion(\"Ford\", \"F-150\", 2021, 1500.0); // Tous hÃ©ritent de afficherInfo() maVoiture.afficherInfo(); // Toyota Camry (2020) maMoto.afficherInfo(); // Harley Sportster (2019) monCamion.afficherInfo(); // Ford F-150 (2021) // Chacun a ses attributs spÃ©cifiques System.out.println(\"Portes: \" + maVoiture.getNombrePortes()); System.out.println(\"Sidecar: \" + maMoto.aSidecar()); System.out.println(\"Charge max: \" + monCamion.getChargeMaximale()); } } 2.5 RedÃ©finition de mÃ©thodes (Override) Une classe enfant peut redÃ©finir une mÃ©thode du parent pour changer son comportement.\nFichier : Camion.java (version amÃ©liorÃ©e)\npublic class Camion extends Vehicule { private double chargeMaximale; public Camion(String marque, String modele, int annee, double chargeMaximale) { super(marque, modele, annee); this.chargeMaximale = chargeMaximale; } public double getChargeMaximale() { return chargeMaximale; } // REDÃ‰FINITION de la mÃ©thode afficherInfo() @Override public void afficherInfo() { super.afficherInfo(); // Appelle la version du parent System.out.println(\"Charge maximale: \" + chargeMaximale + \" kg\"); } } Maintenant :\nCamion monCamion = new Camion(\"Ford\", \"F-150\", 2021, 1500.0); monCamion.afficherInfo(); // Affiche: // Ford F-150 (2021) // Charge maximale: 1500.0 kg Lâ€™annotation @Override est optionnelle mais recommandÃ©e. Elle dit au compilateur : â€œJe redÃ©finis une mÃ©thode du parentâ€.\n3. Le polymorphisme : flexibilitÃ© maximale 3.1 Quâ€™est-ce que le polymorphisme ? Polymorphisme = â€œplusieurs formesâ€\nEn Java, Ã§a veut dire quâ€™une variable de type parent peut contenir un objet enfant.\nVehicule v1 = new Voiture(\"Toyota\", \"Camry\", 2020, 4); Vehicule v2 = new Moto(\"Harley\", \"Sportster\", 2019, false); Vehicule v3 = new Camion(\"Ford\", \"F-150\", 2021, 1500.0); Pourquoi câ€™est utile ? Regardez :\npublic class Main { public static void main(String[] args) { // Un tableau qui contient diffÃ©rents types de vÃ©hicules Vehicule[] flotte = new Vehicule[3]; flotte[0] = new Voiture(\"Toyota\", \"Camry\", 2020, 4); flotte[1] = new Moto(\"Harley\", \"Sportster\", 2019, false); flotte[2] = new Camion(\"Ford\", \"F-150\", 2021, 1500.0); // On peut traiter tous les vÃ©hicules de la mÃªme faÃ§on for (Vehicule v : flotte) { v.afficherInfo(); } } } Sortie :\nToyota Camry (2020)\rHarley Sportster (2019)\rFord F-150 (2021)\rCharge maximale: 1500.0 kg Remarquez que mÃªme si v est de type Vehicule, quand on appelle afficherInfo() sur le camion, câ€™est la version redÃ©finie qui sâ€™exÃ©cute !\n3.2 Exemple concret : systÃ¨me de paiement Fichier : Employe.java\npublic class Employe { private String nom; private int id; public Employe(String nom, int id) { this.nom = nom; this.id = id; } public String getNom() { return nom; } public int getId() { return id; } // MÃ©thode qui sera redÃ©finie par les enfants public double calculerSalaire() { return 0.0; } } Fichier : EmployeHoraire.java\npublic class EmployeHoraire extends Employe { private double tauxHoraire; private int heuresTravaillees; public EmployeHoraire(String nom, int id, double tauxHoraire) { super(nom, id); this.tauxHoraire = tauxHoraire; this.heuresTravaillees = 0; } public void ajouterHeures(int heures) { heuresTravaillees += heures; } @Override public double calculerSalaire() { return tauxHoraire * heuresTravaillees; } } Fichier : EmployeSalarie.java\npublic class EmployeSalarie extends Employe { private double salaireAnnuel; public EmployeSalarie(String nom, int id, double salaireAnnuel) { super(nom, id); this.salaireAnnuel = salaireAnnuel; } @Override public double calculerSalaire() { return salaireAnnuel / 12.0; // Salaire mensuel } } Fichier : EmployeCommission.java\npublic class EmployeCommission extends Employe { private double salaireBase; private double totalVentes; private double tauxCommission; public EmployeCommission(String nom, int id, double salaireBase, double tauxCommission) { super(nom, id); this.salaireBase = salaireBase; this.tauxCommission = tauxCommission; this.totalVentes = 0; } public void ajouterVente(double montant) { totalVentes += montant; } @Override public double calculerSalaire() { return salaireBase + (totalVentes * tauxCommission); } } Utilisation â€” Le pouvoir du polymorphisme :\npublic class Main { public static void main(String[] args) { // DiffÃ©rents types d'employÃ©s EmployeHoraire emp1 = new EmployeHoraire(\"Alice\", 101, 15.50); emp1.ajouterHeures(160); EmployeSalarie emp2 = new EmployeSalarie(\"Bob\", 102, 60000.0); EmployeCommission emp3 = new EmployeCommission(\"Charlie\", 103, 2000.0, 0.05); emp3.ajouterVente(10000.0); emp3.ajouterVente(5000.0); // On peut tous les mettre dans un tableau de type Employe Employe[] employes = { emp1, emp2, emp3 }; // Calcul de la paie pour tout le monde double totalPaie = 0; for (Employe e : employes) { double salaire = e.calculerSalaire(); System.out.printf(\"%s: %.2f$%n\", e.getNom(), salaire); totalPaie += salaire; } System.out.printf(\"Total de la paie: %.2f$%n\", totalPaie); } } Sortie :\nAlice: 2480.00$\rBob: 5000.00$\rCharlie: 2750.00$\rTotal de la paie: 10230.00$ Le polymorphisme nous permet de traiter des objets diffÃ©rents de faÃ§on uniforme !\n4. Classes abstraites : forcer un contrat 4.1 Le problÃ¨me Dans notre classe Employe, la mÃ©thode calculerSalaire() retourne 0.0. Ã‡a nâ€™a pas de sens â€” un employÃ© doit avoir un calcul de salaire spÃ©cifique.\nOn ne veut jamais crÃ©er un objet Employe directement. On veut seulement crÃ©er des EmployeHoraire, EmployeSalarie, etc.\n4.2 La solution : classe abstraite On dÃ©clare la classe Employe comme abstraite avec le mot-clÃ© abstract :\nFichier : Employe.java (version abstraite)\npublic abstract class Employe { private String nom; private int id; public Employe(String nom, int id) { this.nom = nom; this.id = id; } public String getNom() { return nom; } public int getId() { return id; } // MÃ©thode ABSTRAITE - pas d'implÃ©mentation public abstract double calculerSalaire(); } Maintenant :\nEmploye e = new Employe(\"Test\", 1); // ERREUR DE COMPILATION ! // Cannot instantiate the type Employe Mais les classes enfants fonctionnent toujours :\nEmploye e = new EmployeHoraire(\"Alice\", 101, 15.50); // OK ! 4.3 MÃ©thodes abstraites Une mÃ©thode abstraite :\nNâ€™a pas de corps (pas dâ€™implÃ©mentation) Se termine par un point-virgule Oblige les classes enfants Ã  la redÃ©finir public abstract double calculerSalaire(); // Pas de { } Si une classe enfant ne redÃ©finit pas la mÃ©thode abstraite, Ã§a ne compile pas.\n4.4 Exemple : formes gÃ©omÃ©triques Fichier : Forme.java\npublic abstract class Forme { private String couleur; public Forme(String couleur) { this.couleur = couleur; } public String getCouleur() { return couleur; } // MÃ©thodes abstraites - chaque forme calcule diffÃ©remment public abstract double calculerAire(); public abstract double calculerPerimetre(); } Fichier : Rectangle.java\npublic class Rectangle extends Forme { private double largeur; private double hauteur; public Rectangle(String couleur, double largeur, double hauteur) { super(couleur); this.largeur = largeur; this.hauteur = hauteur; } @Override public double calculerAire() { return largeur * hauteur; } @Override public double calculerPerimetre() { return 2 * (largeur + hauteur); } } Fichier : Cercle.java\npublic class Cercle extends Forme { private double rayon; public Cercle(String couleur, double rayon) { super(couleur); this.rayon = rayon; } @Override public double calculerAire() { return Math.PI * rayon * rayon; } @Override public double calculerPerimetre() { return 2 * Math.PI * rayon; } } Fichier : Triangle.java\npublic class Triangle extends Forme { private double base; private double hauteur; private double cote1; private double cote2; public Triangle(String couleur, double base, double hauteur, double cote1, double cote2) { super(couleur); this.base = base; this.hauteur = hauteur; this.cote1 = cote1; this.cote2 = cote2; } @Override public double calculerAire() { return (base * hauteur) / 2.0; } @Override public double calculerPerimetre() { return base + cote1 + cote2; } } Utilisation :\npublic class Main { public static void main(String[] args) { Forme[] formes = new Forme[3]; formes[0] = new Rectangle(\"Rouge\", 5.0, 3.0); formes[1] = new Cercle(\"Bleu\", 4.0); formes[2] = new Triangle(\"Vert\", 6.0, 4.0, 5.0, 5.0); for (Forme f : formes) { System.out.println(\"Forme \" + f.getCouleur()); System.out.printf(\" Aire: %.2f%n\", f.calculerAire()); System.out.printf(\" Perimetre: %.2f%n\", f.calculerPerimetre()); } } } 5. Interfaces : contrats purs 5.1 Quâ€™est-ce quâ€™une interface ? Une interface est un contrat 100% abstrait. Elle dÃ©finit ce quâ€™une classe doit faire, mais pas comment.\nDiffÃ©rence avec une classe abstraite :\nUne classe ne peut hÃ©riter que dâ€™une seule classe (abstraite ou non) Une classe peut implÃ©menter plusieurs interfaces 5.2 CrÃ©ation dâ€™une interface Fichier : Volant.java\npublic interface Volant { void voler(); void atterrir(); } Important :\nLes mÃ©thodes dâ€™une interface sont automatiquement public et abstract On ne met pas le mot-clÃ© abstract, juste la signature Pas de constructeur dans une interface 5.3 ImplÃ©mentation dâ€™une interface On utilise le mot-clÃ© implements :\nFichier : Avion.java\npublic class Avion implements Volant { private String modele; private int altitude; public Avion(String modele) { this.modele = modele; this.altitude = 0; } @Override public void voler() { altitude = 10000; System.out.println(modele + \" vole a \" + altitude + \" metres\"); } @Override public void atterrir() { altitude = 0; System.out.println(modele + \" a atterri\"); } } Fichier : Oiseau.java\npublic class Oiseau implements Volant { private String espece; private int altitude; public Oiseau(String espece) { this.espece = espece; this.altitude = 0; } @Override public void voler() { altitude = 100; System.out.println(espece + \" vole a \" + altitude + \" metres\"); } @Override public void atterrir() { altitude = 0; System.out.println(espece + \" s'est pose\"); } } Utilisation :\npublic class Main { public static void main(String[] args) { Volant[] volants = new Volant[2]; volants[0] = new Avion(\"Boeing 747\"); volants[1] = new Oiseau(\"Aigle\"); for (Volant v : volants) { v.voler(); v.atterrir(); } } } Sortie :\nBoeing 747 vole a 10000 metres\rBoeing 747 a atterri\rAigle vole a 100 metres\rAigle s'est pose 5.4 ImplÃ©menter plusieurs interfaces Fichier : Nageable.java\npublic interface Nageable { void nager(); } Fichier : Canard.java\npublic class Canard implements Volant, Nageable { private String nom; public Canard(String nom) { this.nom = nom; } @Override public void voler() { System.out.println(nom + \" vole bas au-dessus de l'eau\"); } @Override public void atterrir() { System.out.println(nom + \" se pose sur l'eau\"); } @Override public void nager() { System.out.println(nom + \" nage tranquillement\"); } } Canard donald = new Canard(\"Donald\"); donald.voler(); donald.atterrir(); donald.nager(); 5.5 Classe abstraite vs Interface CritÃ¨re Classe abstraite Interface HÃ©ritage Une seule classe parent Plusieurs interfaces Attributs Peut avoir des attributs Pas dâ€™attributs (seulement des constantes) Constructeur Peut avoir un constructeur Pas de constructeur MÃ©thodes concrÃ¨tes Peut avoir des mÃ©thodes normales Seulement des signatures (Java 7) Quand lâ€™utiliser ? Relation â€œest unâ€ avec code partagÃ© Relation â€œpeut faireâ€ Exemple :\nChien est un Animal â†’ classe abstraite ou hÃ©ritage normal Chien peut Nager â†’ interface Nageable 6. Exercices Exercice 1 â€” Encapsulation Niveau : â­ DÃ©butant\nReprenez la classe Etudiant de la partie 1. Modifiez-la pour :\nRendre tous les attributs private CrÃ©er des getters pour tous les attributs CrÃ©er un setter setNumeroEtudiant(int numero) qui refuse les numÃ©ros nÃ©gatifs Testez dans Main :\nEtudiant e = new Etudiant(\"Dupont\", \"Alice\", 12345); System.out.println(e.getNom()); // OK e.setNumeroEtudiant(-100); // Doit afficher une erreur e.setNumeroEtudiant(99999); // OK Exercice 2 â€” HÃ©ritage simple Niveau : â­â­ IntermÃ©diaire\nCrÃ©ez une hiÃ©rarchie de classes pour des instruments de musique :\nClasse parent Instrument avec :\nAttributs : nom (String), prix (double) Constructeur MÃ©thode afficherInfo() Classe enfant Guitare qui hÃ©rite de Instrument avec :\nAttribut supplÃ©mentaire : nombreCordes (int) Constructeur qui appelle super() RedÃ©finition de afficherInfo() pour inclure le nombre de cordes Classe enfant Piano qui hÃ©rite de Instrument avec :\nAttribut supplÃ©mentaire : nombreTouches (int) Constructeur qui appelle super() RedÃ©finition de afficherInfo() pour inclure le nombre de touches Testez :\nGuitare g = new Guitare(\"Fender Stratocaster\", 1200.0, 6); Piano p = new Piano(\"Yamaha Grand\", 15000.0, 88); g.afficherInfo(); p.afficherInfo(); Exercice 3 â€” Polymorphisme Niveau : â­â­ IntermÃ©diaire\nUtilisez les classes de lâ€™exercice 2. Dans Main :\nCrÃ©ez un tableau de type Instrument[] avec 4 instruments (2 guitares, 2 pianos) Parcourez le tableau et appelez afficherInfo() pour chaque instrument Calculez le prix total de tous les instruments Exercice 4 â€” Classe abstraite Niveau : â­â­â­ AvancÃ©\nCrÃ©ez un systÃ¨me pour calculer lâ€™aire de diffÃ©rentes formes en 3D :\nClasse abstraite Forme3D avec :\nAttribut : nom (String) Constructeur MÃ©thode abstraite : double calculerVolume() MÃ©thode abstraite : double calculerSurface() Classe Cube qui Ã©tend Forme3D :\nAttribut : cote (double) ImplÃ©mentation des mÃ©thodes abstraites Classe Sphere qui Ã©tend Forme3D :\nAttribut : rayon (double) ImplÃ©mentation des mÃ©thodes abstraites Formules :\nCube : volume = cÃ´tÃ©Â³, surface = 6 Ã— cÃ´tÃ©Â² SphÃ¨re : volume = (4/3) Ã— Ï€ Ã— rayonÂ³, surface = 4 Ã— Ï€ Ã— rayonÂ² Testez dans un tableau polymorphe.\nExercice 5 â€” Interface Niveau : â­â­â­ AvancÃ©\nCrÃ©ez une interface Rechargeable avec :\nMÃ©thode void recharger() MÃ©thode int niveauBatterie() CrÃ©ez deux classes qui implÃ©mentent cette interface :\nTelephone avec attribut batterie (int de 0 Ã  100) Ordinateur avec attribut batterie (int de 0 Ã  100) Dans Main, crÃ©ez un tableau de Rechargeable[] et rechargez tous les appareils.\nExercice 6 â€” Projet complet Niveau : â­â­â­â­ TrÃ¨s avancÃ©\nCrÃ©ez un systÃ¨me de gestion de zoo :\nInterface Bruyant avec mÃ©thode void faireDuBruit() Classe abstraite Animal avec : Attributs : nom, age, poids MÃ©thode abstraite : String getRegimeAlimentaire() Classes concrÃ¨tes : Lion extends Animal implements Bruyant Elephant extends Animal implements Bruyant Serpent extends Animal (ne fait pas de bruit) Dans Main :\nCrÃ©ez un tableau de 5 animaux Parcourez et affichez les infos de chaque animal Faites faire du bruit Ã  tous les animaux bruyants (utilisez instanceof) Solutions des exercices Note : Essayez vraiment de faire les exercices avant de regarder les solutions !\nSolution â€” Exercice 1 Fichier : Etudiant.java\npublic class Etudiant { private String nom; private String prenom; private int numeroEtudiant; private double[] notes; public Etudiant(String nom, String prenom, int numeroEtudiant) { this.nom = nom; this.prenom = prenom; this.numeroEtudiant = numeroEtudiant; this.notes = new double[0]; } // Getters public String getNom() { return nom; } public String getPrenom() { return prenom; } public int getNumeroEtudiant() { return numeroEtudiant; } public double[] getNotes() { return notes; } // Setter avec validation public void setNumeroEtudiant(int numero) { if (numero \u003c 0) { System.out.println(\"Erreur: le numero ne peut pas etre negatif\"); return; } numeroEtudiant = numero; } public void ajouterNote(double note) { double[] nouvelles_notes = new double[notes.length + 1]; for (int i = 0; i \u003c notes.length; i++) { nouvelles_notes[i] = notes[i]; } nouvelles_notes[notes.length] = note; notes = nouvelles_notes; } public double calculerMoyenne() { if (notes.length == 0) return 0.0; double somme = 0; for (double note : notes) { somme += note; } return somme / notes.length; } } Solution â€” Exercice 2 Fichier : Instrument.java\npublic class Instrument { private String nom; private double prix; public Instrument(String nom, double prix) { this.nom = nom; this.prix = prix; } public void afficherInfo() { System.out.printf(\"%s - Prix: %.2f$%n\", nom, prix); } public String getNom() { return nom; } public double getPrix() { return prix; } } Fichier : Guitare.java\npublic class Guitare extends Instrument { private int nombreCordes; public Guitare(String nom, double prix, int nombreCordes) { super(nom, prix); this.nombreCordes = nombreCordes; } @Override public void afficherInfo() { super.afficherInfo(); System.out.println(\" Nombre de cordes: \" + nombreCordes); } } Fichier : Piano.java\npublic class Piano extends Instrument { private int nombreTouches; public Piano(String nom, double prix, int nombreTouches) { super(nom, prix); this.nombreTouches = nombreTouches; } @Override public void afficherInfo() { super.afficherInfo(); System.out.println(\" Nombre de touches: \" + nombreTouches); } } Solution â€” Exercice 3 Fichier : Main.java\npublic class Main { public static void main(String[] args) { Instrument[] instruments = new Instrument[4]; instruments[0] = new Guitare(\"Fender Stratocaster\", 1200.0, 6); instruments[1] = new Guitare(\"Gibson Les Paul\", 2500.0, 6); instruments[2] = new Piano(\"Yamaha Grand\", 15000.0, 88); instruments[3] = new Piano(\"Steinway\", 50000.0, 88); System.out.println(\"=== Inventaire ===\"); double total = 0; for (Instrument i : instruments) { i.afficherInfo(); total += i.getPrix(); } System.out.printf(\"%nPrix total: %.2f$%n\", total); } } Solution â€” Exercice 4 Fichier : Forme3D.java\npublic abstract class Forme3D { private String nom; public Forme3D(String nom) { this.nom = nom; } public String getNom() { return nom; } public abstract double calculerVolume(); public abstract double calculerSurface(); } Fichier : Cube.java\npublic class Cube extends Forme3D { private double cote; public Cube(double cote) { super(\"Cube\"); this.cote = cote; } @Override public double calculerVolume() { return cote * cote * cote; } @Override public double calculerSurface() { return 6 * cote * cote; } } Fichier : Sphere.java\npublic class Sphere extends Forme3D { private double rayon; public Sphere(double rayon) { super(\"Sphere\"); this.rayon = rayon; } @Override public double calculerVolume() { return (4.0 / 3.0) * Math.PI * rayon * rayon * rayon; } @Override public double calculerSurface() { return 4 * Math.PI * rayon * rayon; } } Fichier : Main.java\npublic class Main { public static void main(String[] args) { Forme3D[] formes = new Forme3D[3]; formes[0] = new Cube(5.0); formes[1] = new Sphere(3.0); formes[2] = new Cube(2.5); for (Forme3D f : formes) { System.out.println(f.getNom()); System.out.printf(\" Volume: %.2f%n\", f.calculerVolume()); System.out.printf(\" Surface: %.2f%n\", f.calculerSurface()); } } } Solution â€” Exercice 5 Fichier : Rechargeable.java\npublic interface Rechargeable { void recharger(); int niveauBatterie(); } Fichier : Telephone.java\npublic class Telephone implements Rechargeable { private String modele; private int batterie; public Telephone(String modele, int batterieInitiale) { this.modele = modele; this.batterie = batterieInitiale; } @Override public void recharger() { batterie = 100; System.out.println(modele + \" recharge a 100%\"); } @Override public int niveauBatterie() { return batterie; } public String getModele() { return modele; } } Fichier : Ordinateur.java\npublic class Ordinateur implements Rechargeable { private String modele; private int batterie; public Ordinateur(String modele, int batterieInitiale) { this.modele = modele; this.batterie = batterieInitiale; } @Override public void recharger() { batterie = 100; System.out.println(modele + \" recharge a 100%\"); } @Override public int niveauBatterie() { return batterie; } public String getModele() { return modele; } } Fichier : Main.java\npublic class Main { public static void main(String[] args) { Rechargeable[] appareils = new Rechargeable[3]; appareils[0] = new Telephone(\"iPhone\", 25); appareils[1] = new Ordinateur(\"MacBook\", 50); appareils[2] = new Telephone(\"Samsung\", 10); System.out.println(\"=== Avant rechargement ===\"); for (Rechargeable a : appareils) { System.out.println(\"Batterie: \" + a.niveauBatterie() + \"%\"); } System.out.println(\"%n=== Rechargement ===\"); for (Rechargeable a : appareils) { a.recharger(); } System.out.println(\"%n=== Apres rechargement ===\"); for (Rechargeable a : appareils) { System.out.println(\"Batterie: \" + a.niveauBatterie() + \"%\"); } } } Solution â€” Exercice 6 Fichier : Bruyant.java\npublic interface Bruyant { void faireDuBruit(); } Fichier : Animal.java\npublic abstract class Animal { private String nom; private int age; private double poids; public Animal(String nom, int age, double poids) { this.nom = nom; this.age = age; this.poids = poids; } public String getNom() { return nom; } public int getAge() { return age; } public double getPoids() { return poids; } public abstract String getRegimeAlimentaire(); public void afficherInfo() { System.out.printf(\"%s - %d ans - %.1f kg - %s%n\", nom, age, poids, getRegimeAlimentaire()); } } Fichier : Lion.java\npublic class Lion extends Animal implements Bruyant { public Lion(String nom, int age, double poids) { super(nom, age, poids); } @Override public String getRegimeAlimentaire() { return \"Carnivore\"; } @Override public void faireDuBruit() { System.out.println(getNom() + \" rugit: ROAAAAR!\"); } } Fichier : Elephant.java\npublic class Elephant extends Animal implements Bruyant { public Elephant(String nom, int age, double poids) { super(nom, age, poids); } @Override public String getRegimeAlimentaire() { return \"Herbivore\"; } @Override public void faireDuBruit() { System.out.println(getNom() + \" barrit: PAAAAAW!\"); } } Fichier : Serpent.java\npublic class Serpent extends Animal { public Serpent(String nom, int age, double poids) { super(nom, age, poids); } @Override public String getRegimeAlimentaire() { return \"Carnivore\"; } } Fichier : Main.java\npublic class Main { public static void main(String[] args) { Animal[] zoo = new Animal[5]; zoo[0] = new Lion(\"Simba\", 5, 190.0); zoo[1] = new Elephant(\"Dumbo\", 10, 5000.0); zoo[2] = new Serpent(\"Kaa\", 3, 15.0); zoo[3] = new Lion(\"Nala\", 4, 150.0); zoo[4] = new Elephant(\"Tantor\", 15, 6000.0); System.out.println(\"=== Animaux du zoo ===\"); for (Animal a : zoo) { a.afficherInfo(); } System.out.println(\"%n=== Les animaux bruyants ===\"); for (Animal a : zoo) { if (a instanceof Bruyant) { Bruyant bruyant = (Bruyant) a; bruyant.faireDuBruit(); } } } } RÃ©sumÃ© des 4 principes de la POO Principe Ce que câ€™est Pourquoi câ€™est important Encapsulation Cacher les dÃ©tails internes avec private Protection des donnÃ©es, validation HÃ©ritage RÃ©utiliser du code avec extends Ã‰vite la rÃ©pÃ©tition, organise le code Polymorphisme Traiter des objets diffÃ©rents de faÃ§on uniforme FlexibilitÃ©, code gÃ©nÃ©rique Abstraction DÃ©finir des contrats avec classes abstraites et interfaces Force une structure, garantit lâ€™implÃ©mentation",
    "description": "Introduction Ã  la POO â€” Partie 2 Introduction Dans la premiÃ¨re partie du cours, vous avez appris les bases de la POO :\nCrÃ©er des classes et des objets Utiliser des attributs et des mÃ©thodes CrÃ©er des constructeurs Manipuler des tableaux dâ€™objets Maintenant, nous allons voir les 4 grands principes de la POO :",
    "tags": [],
    "title": "Programmation orientÃ©e objet - 2",
    "uri": "/420-210/poo_2/index.html"
  },
  {
    "breadcrumb": "Programmation orientÃ©e objet",
    "content": "Table des matiÃ¨res Niveaux dâ€™accÃ¨s (Modificateurs de visibilitÃ©) Packages et organisation du code MÃ©thodes et variables statiques Classes imbriquÃ©es (Inner classes) Le mot-clÃ© final Ã‰numÃ©rations (enum) Gestion des exceptions Composition vs HÃ©ritage Principes SOLID Surcharge de mÃ©thodes (Overloading) Constructeurs multiples et chaÃ®nage La classe Object et ses mÃ©thodes Collections Java 1. Niveaux dâ€™accÃ¨s (Modificateurs de visibilitÃ©) Java propose 4 niveaux dâ€™accÃ¨s pour contrÃ´ler qui peut accÃ©der Ã  vos classes, attributs et mÃ©thodes.\n1.1 Les quatre modificateurs Modificateur Classe Package Sous-classe Monde public âœ… âœ… âœ… âœ… protected âœ… âœ… âœ… âŒ (default) âœ… âœ… âŒ âŒ private âœ… âŒ âŒ âŒ 1.2 Explications dÃ©taillÃ©es public : Accessible partout\npublic class Voiture { public String marque; // Accessible partout public void demarrer() { // Accessible partout System.out.println(\"La voiture dÃ©marre\"); } } private : Accessible seulement dans la classe\npublic class CompteBancaire { private double solde; // Seulement accessible dans CompteBancaire private void validerMontant(double montant) { // MÃ©thode privÃ©e if (montant \u003c 0) { throw new IllegalArgumentException(\"Montant invalide\"); } } public void deposer(double montant) { validerMontant(montant); // OK, on est dans la mÃªme classe solde += montant; } } protected : Accessible dans le package ET par les sous-classes\npublic class Animal { protected String espece; // Accessible par les enfants protected void manger() { // Accessible par les enfants System.out.println(\"L'animal mange\"); } } public class Chien extends Animal { public void faireDuBruit() { System.out.println(espece); // OK, protected accessible manger(); // OK, mÃ©thode protected accessible } } default (aucun modificateur) : Accessible seulement dans le mÃªme package\nclass ClasseInterne { // Pas de 'public' = default String message; // default void afficher() { // default System.out.println(message); } } 1.3 Bonnes pratiques Attributs : Toujours private (sauf constantes public static final) MÃ©thodes publiques : Lâ€™API de votre classe MÃ©thodes privÃ©es : MÃ©thodes utilitaires internes Protected : Uniquement si vous voulez que les sous-classes y accÃ¨dent Classes : public ou default (pas de private ou protected pour les classes de premier niveau) 2. Packages et organisation du code Un package est un dossier qui organise vos classes de maniÃ¨re logique.\n2.1 DÃ©claration dâ€™un package Fichier : com/ecole/etudiant/Etudiant.java\npackage com.ecole.etudiant; // Doit Ãªtre la premiÃ¨re ligne public class Etudiant { private String nom; private String prenom; public Etudiant(String nom, String prenom) { this.nom = nom; this.prenom = prenom; } public String getNom() { return nom; } public String getPrenom() { return prenom; } } 2.2 Utilisation avec import Fichier : com/ecole/main/Main.java\npackage com.ecole.main; import com.ecole.etudiant.Etudiant; // Import de la classe Etudiant public class Main { public static void main(String[] args) { Etudiant alice = new Etudiant(\"Dupont\", \"Alice\"); System.out.println(alice.getNom()); } } 2.3 Import multiple et wildcard package com.ecole.main; // Import d'une classe spÃ©cifique import com.ecole.etudiant.Etudiant; import com.ecole.cours.Cours; // Import de toutes les classes d'un package import com.ecole.professeur.*; // Import statique pour les constantes import static java.lang.Math.PI; import static java.lang.Math.sqrt; public class Main { public static void main(String[] args) { double circonference = 2 * PI * 5; // PI sans Math.PI double racine = sqrt(16); // sqrt sans Math.sqrt } } 2.4 Conventions de nommage Package : tout en minuscules, souvent inversÃ© du nom de domaine\ncom.entreprise.projet.module org.apache.commons.lang Structure typique :\ncom.monentreprise.monprojet/\râ”œâ”€â”€ model/ (classes de donnÃ©es)\râ”œâ”€â”€ service/ (logique mÃ©tier)\râ”œâ”€â”€ controller/ (contrÃ´leurs)\râ”œâ”€â”€ util/ (utilitaires)\râ””â”€â”€ exception/ (exceptions personnalisÃ©es) 3. MÃ©thodes et variables statiques Le mot-clÃ© static signifie que quelque chose appartient Ã  la classe et non Ã  une instance.\n3.1 Variables statiques Une variable statique est partagÃ©e par toutes les instances de la classe.\npublic class Etudiant { private String nom; private static int compteur = 0; // Variable de classe public Etudiant(String nom) { this.nom = nom; compteur++; // IncrÃ©mente Ã  chaque crÃ©ation } public static int getNombreEtudiants() { return compteur; } } // Utilisation Etudiant e1 = new Etudiant(\"Alice\"); Etudiant e2 = new Etudiant(\"Bob\"); Etudiant e3 = new Etudiant(\"Charlie\"); System.out.println(Etudiant.getNombreEtudiants()); // 3 3.2 MÃ©thodes statiques Une mÃ©thode statique peut Ãªtre appelÃ©e sans crÃ©er dâ€™objet.\npublic class MathUtil { // MÃ©thode statique public static double calculerCirconference(double rayon) { return 2 * Math.PI * rayon; } public static int max(int a, int b) { return (a \u003e b) ? a : b; } } // Utilisation - SANS crÃ©er d'objet double c = MathUtil.calculerCirconference(5.0); int maximum = MathUtil.max(10, 20); 3.3 Constantes statiques Par convention, les constantes sont public static final.\npublic class Config { public static final String VERSION = \"1.0.0\"; public static final int MAX_CONNEXIONS = 100; public static final double TAUX_TVA = 0.15; } // Utilisation System.out.println(\"Version: \" + Config.VERSION); double prixTTC = prixHT * (1 + Config.TAUX_TVA); 3.4 Bloc statique dâ€™initialisation public class Database { private static Connection connection; // Bloc statique - s'exÃ©cute une seule fois au chargement de la classe static { try { connection = DriverManager.getConnection(\"jdbc:mysql://localhost/db\"); System.out.println(\"Connexion Ã©tablie\"); } catch (SQLException e) { e.printStackTrace(); } } } 3.5 Restrictions des mÃ©thodes statiques âš ï¸ Une mÃ©thode statique NE PEUT PAS :\nAccÃ©der Ã  this AccÃ©der aux variables dâ€™instance (non-statiques) Appeler des mÃ©thodes non-statiques directement public class Exemple { private int x = 10; private static int y = 20; public static void methodeStatique() { // System.out.println(x); // ERREUR ! x n'est pas statique System.out.println(y); // OK, y est statique // this.x = 5; // ERREUR ! pas de 'this' en statique } } 4. Classes imbriquÃ©es (Inner classes) Java permet de dÃ©finir une classe Ã  lâ€™intÃ©rieur dâ€™une autre classe.\n4.1 Classe membre (non-statique) public class Universite { private String nom; public Universite(String nom) { this.nom = nom; } // Classe interne membre public class Departement { private String nomDept; public Departement(String nomDept) { this.nomDept = nomDept; } public void afficher() { // Peut accÃ©der aux membres de la classe externe System.out.println(\"DÃ©partement \" + nomDept + \" de \" + nom); } } } // Utilisation Universite udem = new Universite(\"UdeM\"); Universite.Departement info = udem.new Departement(\"Informatique\"); info.afficher(); // DÃ©partement Informatique de UdeM 4.2 Classe statique imbriquÃ©e public class Ecole { private String nom; // Classe statique imbriquÃ©e public static class Adresse { private String rue; private String ville; public Adresse(String rue, String ville) { this.rue = rue; this.ville = ville; } public void afficher() { System.out.println(rue + \", \" + ville); // Ne peut PAS accÃ©der Ã  'nom' de Ecole } } } // Utilisation - pas besoin d'instance de Ecole Ecole.Adresse adresse = new Ecole.Adresse(\"123 Main St\", \"Montreal\"); adresse.afficher(); 4.3 Classes locales et anonymes Classe locale : dÃ©finie dans une mÃ©thode\npublic class Exemple { public void faireQuelqueChose() { // Classe locale class Helper { void aider() { System.out.println(\"J'aide !\"); } } Helper h = new Helper(); h.aider(); } } Classe anonyme : pour implÃ©menter une interface Ã  la volÃ©e\npublic interface Salutation { void direBonjour(); } public class Main { public static void main(String[] args) { // Classe anonyme Salutation s = new Salutation() { @Override public void direBonjour() { System.out.println(\"Bonjour !\"); } }; s.direBonjour(); } } 5. Le mot-clÃ© final Le mot-clÃ© final signifie â€œne peut pas Ãªtre modifiÃ©â€.\n5.1 Variables finales (constantes) public class Exemple { private final int VALEUR_MAX = 100; // Ne peut plus changer public void methode() { final double PI = 3.14159; // PI = 3.14; // ERREUR ! Variable finale } } 5.2 ParamÃ¨tres finaux public class Calculateur { public double calculer(final double montant) { // montant = montant * 2; // ERREUR ! ParamÃ¨tre final return montant * 1.15; } } 5.3 MÃ©thodes finales Une mÃ©thode final ne peut pas Ãªtre redÃ©finie par les sous-classes.\npublic class Animal { // Cette mÃ©thode ne peut PAS Ãªtre @Override public final void respirer() { System.out.println(\"L'animal respire\"); } } public class Chien extends Animal { // @Override // public void respirer() { // ERREUR ! MÃ©thode finale // } } 5.4 Classes finales Une classe final ne peut pas Ãªtre hÃ©ritÃ©e.\npublic final class String { // Oui, String est finale ! // ... } // public class MaString extends String { // ERREUR ! Classe finale // } Exemples de classes finales en Java : String, Integer, Double, Math\n6. Ã‰numÃ©rations (enum) Un enum est un type spÃ©cial pour reprÃ©senter un ensemble fixe de constantes.\n6.1 Enum simple public enum JourSemaine { LUNDI, MARDI, MERCREDI, JEUDI, VENDREDI, SAMEDI, DIMANCHE } // Utilisation JourSemaine jour = JourSemaine.LUNDI; if (jour == JourSemaine.SAMEDI || jour == JourSemaine.DIMANCHE) { System.out.println(\"C'est la fin de semaine !\"); } // Switch avec enum switch (jour) { case LUNDI: System.out.println(\"DÃ©but de semaine\"); break; case VENDREDI: System.out.println(\"Presque la fin !\"); break; default: System.out.println(\"Jour normal\"); } 6.2 Enum avec attributs et mÃ©thodes public enum NiveauDifficulte { FACILE(1, \"DÃ©butant\"), MOYEN(2, \"IntermÃ©diaire\"), DIFFICILE(3, \"AvancÃ©\"), EXPERT(4, \"Expert\"); private final int niveau; private final String description; // Constructeur (toujours private) NiveauDifficulte(int niveau, String description) { this.niveau = niveau; this.description = description; } public int getNiveau() { return niveau; } public String getDescription() { return description; } } // Utilisation NiveauDifficulte diff = NiveauDifficulte.DIFFICILE; System.out.println(diff.getDescription()); // AvancÃ© System.out.println(diff.getNiveau()); // 3 6.3 MÃ©thodes utiles des enums // Obtenir toutes les valeurs for (JourSemaine jour : JourSemaine.values()) { System.out.println(jour); } // Convertir une String en enum JourSemaine jour = JourSemaine.valueOf(\"LUNDI\"); // Nom de la constante String nom = JourSemaine.MARDI.name(); // \"MARDI\" // Position dans l'enum (commence Ã  0) int position = JourSemaine.MERCREDI.ordinal(); // 2 7. Gestion des exceptions Les exceptions permettent de gÃ©rer les erreurs de maniÃ¨re Ã©lÃ©gante.\n7.1 Try-Catch basique public class GestionErreurs { public static void main(String[] args) { try { int[] tableau = {1, 2, 3}; System.out.println(tableau[10]); // Index invalide } catch (ArrayIndexOutOfBoundsException e) { System.out.println(\"Erreur : index hors limites\"); e.printStackTrace(); } System.out.println(\"Le programme continue...\"); } } 7.2 Blocs multiples catch public void lireFichier(String chemin) { try { FileReader fichier = new FileReader(chemin); BufferedReader lecteur = new BufferedReader(fichier); String ligne = lecteur.readLine(); int nombre = Integer.parseInt(ligne); } catch (FileNotFoundException e) { System.out.println(\"Fichier introuvable\"); } catch (IOException e) { System.out.println(\"Erreur de lecture\"); } catch (NumberFormatException e) { System.out.println(\"Format de nombre invalide\"); } } 7.3 Finally Le bloc finally sâ€™exÃ©cute toujours, quâ€™il y ait une exception ou non.\npublic void traiterFichier(String chemin) { FileReader fichier = null; try { fichier = new FileReader(chemin); // Traitement... } catch (IOException e) { System.out.println(\"Erreur : \" + e.getMessage()); } finally { // S'exÃ©cute TOUJOURS if (fichier != null) { try { fichier.close(); } catch (IOException e) { e.printStackTrace(); } } } } 7.4 Try-with-resources (Java 7+) Ferme automatiquement les ressources.\npublic void lireFichier(String chemin) { try (FileReader fichier = new FileReader(chemin); BufferedReader lecteur = new BufferedReader(fichier)) { String ligne = lecteur.readLine(); System.out.println(ligne); } catch (IOException e) { e.printStackTrace(); } // fichier et lecteur sont automatiquement fermÃ©s } 7.5 Lancer des exceptions public class CompteBancaire { private double solde; public void retirer(double montant) throws Exception { if (montant \u003e solde) { throw new Exception(\"Fonds insuffisants\"); } solde -= montant; } } // Utilisation try { compte.retirer(1000.0); } catch (Exception e) { System.out.println(e.getMessage()); } 7.6 CrÃ©er des exceptions personnalisÃ©es public class SoldeInsuffisantException extends Exception { private double soldeActuel; private double montantDemande; public SoldeInsuffisantException(double soldeActuel, double montantDemande) { super(\"Solde insuffisant : \" + soldeActuel + \" \u003c \" + montantDemande); this.soldeActuel = soldeActuel; this.montantDemande = montantDemande; } public double getSoldeActuel() { return soldeActuel; } public double getMontantDemande() { return montantDemande; } } // Utilisation public void retirer(double montant) throws SoldeInsuffisantException { if (montant \u003e solde) { throw new SoldeInsuffisantException(solde, montant); } solde -= montant; } 8. Composition vs HÃ©ritage 8.1 Le problÃ¨me avec lâ€™hÃ©ritage Lâ€™hÃ©ritage crÃ©e un couplage fort. Parfois, la composition est meilleure.\nMauvais exemple avec hÃ©ritage :\n// Un moteur n'EST PAS une voiture ! public class Moteur { public void demarrer() { System.out.println(\"Moteur dÃ©marre\"); } } public class Voiture extends Moteur { // âŒ Mauvaise utilisation // ... } 8.2 Solution avec composition Bon exemple avec composition :\npublic class Moteur { private String type; public Moteur(String type) { this.type = type; } public void demarrer() { System.out.println(\"Moteur \" + type + \" dÃ©marre\"); } } public class Voiture { private Moteur moteur; // Composition : voiture HAS-A moteur private String marque; public Voiture(String marque, String typeMoteur) { this.marque = marque; this.moteur = new Moteur(typeMoteur); } public void demarrer() { moteur.demarrer(); // DÃ©lÃ©gation System.out.println(\"Voiture \" + marque + \" est prÃªte\"); } } 8.3 RÃ¨gle dâ€™or HÃ©ritage (IS-A) : â€œUn Chien EST UN Animalâ€ â†’ extends Composition (HAS-A) : â€œUne Voiture A UN Moteurâ€ â†’ attribut PrivilÃ©giez la composition quand câ€™est possible. Lâ€™hÃ©ritage devrait Ãªtre rÃ©servÃ© aux vraies relations â€œest-unâ€.\n9. Principes SOLID Les principes SOLID sont 5 rÃ¨gles de conception en POO.\n9.1 S - Single Responsibility Principle (ResponsabilitÃ© unique) Une classe ne devrait avoir quâ€™une seule raison de changer.\nâŒ Mauvais :\npublic class Employe { private String nom; private double salaire; // Gestion des donnÃ©es public void calculerPaie() { } // GÃ©nÃ©ration de rapports (autre responsabilitÃ© !) public void genererRapport() { } // Sauvegarde en BD (encore une autre responsabilitÃ© !) public void sauvegarderEnBD() { } } âœ… Bon :\npublic class Employe { private String nom; private double salaire; public double calculerPaie() { return salaire; } // Getters/setters... } public class RapportEmploye { public void genererRapport(Employe e) { // ... } } public class EmployeRepository { public void sauvegarder(Employe e) { // ... } } 9.2 O - Open/Closed Principle (Ouvert/FermÃ©) Les classes doivent Ãªtre ouvertes Ã  lâ€™extension mais fermÃ©es Ã  la modification.\nâŒ Mauvais :\npublic class CalculateurAire { public double calculer(Object forme) { if (forme instanceof Rectangle) { Rectangle r = (Rectangle) forme; return r.largeur * r.hauteur; } else if (forme instanceof Cercle) { Cercle c = (Cercle) forme; return Math.PI * c.rayon * c.rayon; } // Pour ajouter une forme, on doit MODIFIER cette classe ! return 0; } } âœ… Bon :\npublic abstract class Forme { public abstract double calculerAire(); } public class Rectangle extends Forme { private double largeur, hauteur; @Override public double calculerAire() { return largeur * hauteur; } } public class Cercle extends Forme { private double rayon; @Override public double calculerAire() { return Math.PI * rayon * rayon; } } // Pas besoin de modifier le code existant pour ajouter une forme public class Triangle extends Forme { private double base, hauteur; @Override public double calculerAire() { return (base * hauteur) / 2; } } 9.3 L - Liskov Substitution Principle Les objets dâ€™une classe mÃ¨re doivent pouvoir Ãªtre remplacÃ©s par des objets de classes filles sans casser le programme.\nâŒ Mauvais :\npublic class Rectangle { protected int largeur, hauteur; public void setLargeur(int l) { largeur = l; } public void setHauteur(int h) { hauteur = h; } public int getAire() { return largeur * hauteur; } } public class Carre extends Rectangle { @Override public void setLargeur(int l) { largeur = hauteur = l; // Change les deux ! } @Override public void setHauteur(int h) { largeur = hauteur = h; // Change les deux ! } } // ProblÃ¨me : Rectangle r = new Carre(); r.setLargeur(5); r.setHauteur(10); System.out.println(r.getAire()); // On s'attend Ã  50, mais on obtient 100 ! âœ… Bon :\npublic abstract class Forme { public abstract int getAire(); } public class Rectangle extends Forme { private int largeur, hauteur; public Rectangle(int largeur, int hauteur) { this.largeur = largeur; this.hauteur = hauteur; } @Override public int getAire() { return largeur * hauteur; } } public class Carre extends Forme { private int cote; public Carre(int cote) { this.cote = cote; } @Override public int getAire() { return cote * cote; } } 9.4 I - Interface Segregation Principle Mieux vaut plusieurs petites interfaces spÃ©cifiques quâ€™une grosse interface gÃ©nÃ©rale.\nâŒ Mauvais :\npublic interface Travailleur { void travailler(); void manger(); void dormir(); } // Un robot ne mange pas et ne dort pas ! public class Robot implements Travailleur { @Override public void travailler() { /* OK */ } @Override public void manger() { /* ??? */ } @Override public void dormir() { /* ??? */ } } âœ… Bon :\npublic interface Travaillable { void travailler(); } public interface Mangeable { void manger(); } public interface Dormable { void dormir(); } public class Humain implements Travaillable, Mangeable, Dormable { @Override public void travailler() { } @Override public void manger() { } @Override public void dormir() { } } public class Robot implements Travaillable { @Override public void travailler() { } } 9.5 D - Dependency Inversion Principle Les classes de haut niveau ne doivent pas dÃ©pendre des classes de bas niveau. Les deux doivent dÃ©pendre dâ€™abstractions.\nâŒ Mauvais :\npublic class MySQLDatabase { public void sauvegarder(String data) { // Sauvegarde dans MySQL } } public class UtilisateurService { private MySQLDatabase db = new MySQLDatabase(); // DÃ©pendance directe ! public void creerUtilisateur(String nom) { db.sauvegarder(nom); } } // Si on veut changer de BD, on doit modifier UtilisateurService ! âœ… Bon :\npublic interface Database { void sauvegarder(String data); } public class MySQLDatabase implements Database { @Override public void sauvegarder(String data) { // Sauvegarde dans MySQL } } public class PostgreSQLDatabase implements Database { @Override public void sauvegarder(String data) { // Sauvegarde dans PostgreSQL } } public class UtilisateurService { private Database db; // DÃ©pend d'une abstraction public UtilisateurService(Database db) { this.db = db; // Injection de dÃ©pendance } public void creerUtilisateur(String nom) { db.sauvegarder(nom); } } // Utilisation Database db = new MySQLDatabase(); // Ou PostgreSQLDatabase UtilisateurService service = new UtilisateurService(db); 10. Surcharge de mÃ©thodes (Overloading) La surcharge permet dâ€™avoir plusieurs mÃ©thodes avec le mÃªme nom mais des paramÃ¨tres diffÃ©rents.\n10.1 Surcharge simple public class Calculateur { // Additionner deux entiers public int additionner(int a, int b) { return a + b; } // Additionner trois entiers public int additionner(int a, int b, int c) { return a + b + c; } // Additionner deux doubles public double additionner(double a, double b) { return a + b; } } // Utilisation Calculateur calc = new Calculateur(); System.out.println(calc.additionner(2, 3)); // 5 (int, int) System.out.println(calc.additionner(2, 3, 4)); // 9 (int, int, int) System.out.println(calc.additionner(2.5, 3.7)); // 6.2 (double, double) 10.2 Surcharge de constructeurs public class Rectangle { private double largeur; private double hauteur; // Constructeur par dÃ©faut public Rectangle() { this.largeur = 1.0; this.hauteur = 1.0; } // Constructeur avec un paramÃ¨tre (carrÃ©) public Rectangle(double cote) { this.largeur = cote; this.hauteur = cote; } // Constructeur complet public Rectangle(double largeur, double hauteur) { this.largeur = largeur; this.hauteur = hauteur; } } // Utilisation Rectangle r1 = new Rectangle(); // 1.0 x 1.0 Rectangle r2 = new Rectangle(5.0); // 5.0 x 5.0 Rectangle r3 = new Rectangle(3.0, 7.0); // 3.0 x 7.0 10.3 RÃ¨gles de surcharge âœ… DiffÃ©rences acceptÃ©es :\nNombre de paramÃ¨tres diffÃ©rent Types de paramÃ¨tres diffÃ©rents Ordre des paramÃ¨tres diffÃ©rent âŒ PAS de surcharge avec :\nSeulement un type de retour diffÃ©rent Seulement des noms de paramÃ¨tres diffÃ©rents // âŒ ERREUR - mÃªme signature public int calculer(int a, int b) { return a + b; } public double calculer(int a, int b) { return a + b; } // ERREUR ! // âŒ ERREUR - noms de paramÃ¨tres ne comptent pas public int calculer(int x, int y) { return x + y; } public int calculer(int a, int b) { return a + b; } // ERREUR ! // âœ… OK - ordre diffÃ©rent public void afficher(int x, String s) { } public void afficher(String s, int x) { } // OK 11. Constructeurs multiples et chaÃ®nage 11.1 ChaÃ®nage avec this() Un constructeur peut appeler un autre constructeur de la mÃªme classe avec this().\npublic class Personne { private String nom; private String prenom; private int age; // Constructeur principal public Personne(String nom, String prenom, int age) { this.nom = nom; this.prenom = prenom; this.age = age; } // Appelle le constructeur principal avec des valeurs par dÃ©faut public Personne(String nom, String prenom) { this(nom, prenom, 0); // Appelle Personne(String, String, int) } // Appelle le constructeur avec 2 paramÃ¨tres public Personne(String nom) { this(nom, \"\"); // Appelle Personne(String, String) } // Appelle le constructeur avec 1 paramÃ¨tre public Personne() { this(\"Inconnu\"); // Appelle Personne(String) } } Important : Lâ€™appel Ã  this() doit Ãªtre la premiÃ¨re instruction du constructeur.\n11.2 ChaÃ®nage avec super() Rappel : super() appelle le constructeur de la classe parent.\npublic class Vehicule { private String marque; public Vehicule(String marque) { this.marque = marque; } } public class Voiture extends Vehicule { private int nombrePortes; public Voiture(String marque, int nombrePortes) { super(marque); // Appelle le constructeur de Vehicule this.nombrePortes = nombrePortes; } // Surcharge avec valeur par dÃ©faut public Voiture(String marque) { this(marque, 4); // Appelle l'autre constructeur de Voiture } } 12. La classe Object et ses mÃ©thodes Toutes les classes Java hÃ©ritent automatiquement de la classe Object.\n12.1 HiÃ©rarchie implicite public class MaClasse { // Ã‰quivalent Ã  : public class MaClasse extends Object } 12.2 MÃ©thodes importantes de Object toString() Retourne une reprÃ©sentation en String de lâ€™objet.\npublic class Personne { private String nom; private int age; public Personne(String nom, int age) { this.nom = nom; this.age = age; } // RedÃ©finition de toString() @Override public String toString() { return \"Personne{nom='\" + nom + \"', age=\" + age + \"}\"; } } // Utilisation Personne p = new Personne(\"Alice\", 25); System.out.println(p); // Appelle automatiquement toString() // Affiche: Personne{nom='Alice', age=25} equals() Compare deux objets pour lâ€™Ã©galitÃ©.\npublic class Point { private int x; private int y; public Point(int x, int y) { this.x = x; this.y = y; } @Override public boolean equals(Object obj) { // VÃ©rifier si c'est le mÃªme objet if (this == obj) return true; // VÃ©rifier si obj est null ou d'un autre type if (obj == null || getClass() != obj.getClass()) return false; // Comparer les attributs Point autre = (Point) obj; return x == autre.x \u0026\u0026 y == autre.y; } } // Utilisation Point p1 = new Point(3, 5); Point p2 = new Point(3, 5); System.out.println(p1 == p2); // false (rÃ©fÃ©rences diffÃ©rentes) System.out.println(p1.equals(p2)); // true (valeurs Ã©gales) hashCode() Retourne un code de hachage pour lâ€™objet. Important : si vous redÃ©finissez equals(), vous devez aussi redÃ©finir hashCode().\npublic class Point { private int x; private int y; @Override public boolean equals(Object obj) { if (this == obj) return true; if (obj == null || getClass() != obj.getClass()) return false; Point autre = (Point) obj; return x == autre.x \u0026\u0026 y == autre.y; } @Override public int hashCode() { int result = 17; result = 31 * result + x; result = 31 * result + y; return result; } } getClass() Retourne lâ€™objet Class qui reprÃ©sente la classe de lâ€™objet.\nPersonne p = new Personne(\"Alice\", 25); Class\u003c?\u003e classe = p.getClass(); System.out.println(classe.getName()); // Personne System.out.println(classe.getSimpleName()); // Personne 13. Collections Java Les collections sont des structures de donnÃ©es qui permettent de stocker et manipuler des groupes dâ€™objets de maniÃ¨re efficace. Contrairement aux tableaux, elles sont dynamiques (taille variable) et offrent de nombreuses mÃ©thodes utiles.\n13.1 HiÃ©rarchie des Collections Collection (interface)\râ”œâ”€â”€ List (interface) - Ordre maintenu, doublons autorisÃ©s\râ”‚ â”œâ”€â”€ ArrayList - Tableau dynamique (accÃ¨s rapide par index)\râ”‚ â”œâ”€â”€ LinkedList - Liste chaÃ®nÃ©e (insertion/suppression rapide)\râ”‚ â””â”€â”€ Vector - Comme ArrayList mais synchronisÃ© (legacy)\râ”‚\râ”œâ”€â”€ Set (interface) - Pas de doublons\râ”‚ â”œâ”€â”€ HashSet - Pas d'ordre garanti, trÃ¨s rapide\râ”‚ â”œâ”€â”€ LinkedHashSet - Ordre d'insertion maintenu\râ”‚ â””â”€â”€ TreeSet - Ordre naturel ou personnalisÃ©\râ”‚\râ””â”€â”€ Queue (interface) - Files (FIFO)\râ”œâ”€â”€ PriorityQueue - File avec prioritÃ©s\râ””â”€â”€ LinkedList - ImplÃ©mente aussi Queue\rMap (interface) - Paires clÃ©-valeur\râ”œâ”€â”€ HashMap - Pas d'ordre garanti, trÃ¨s rapide\râ”œâ”€â”€ LinkedHashMap - Ordre d'insertion maintenu\râ””â”€â”€ TreeMap - Ordre naturel des clÃ©s 13.2 ArrayList - Liste dynamique ArrayList est la collection la plus utilisÃ©e. Câ€™est un tableau redimensionnable automatiquement.\nCrÃ©ation et ajout import java.util.ArrayList; public class ExempleArrayList { public static void main(String[] args) { // CrÃ©ation d'une ArrayList de String ArrayList\u003cString\u003e noms = new ArrayList\u003c\u003e(); // Ajout d'Ã©lÃ©ments noms.add(\"Alice\"); noms.add(\"Bob\"); noms.add(\"Charlie\"); // Ajout Ã  un index spÃ©cifique noms.add(1, \"Diana\"); // InsÃ¨re Diana en position 1 System.out.println(noms); // [Alice, Diana, Bob, Charlie] } } AccÃ¨s et modification ArrayList\u003cString\u003e noms = new ArrayList\u003c\u003e(); noms.add(\"Alice\"); noms.add(\"Bob\"); noms.add(\"Charlie\"); // AccÃ¨s par index String premier = noms.get(0); // \"Alice\" String dernier = noms.get(noms.size() - 1); // \"Charlie\" // Modification noms.set(1, \"Bobby\"); // Remplace \"Bob\" par \"Bobby\" // Taille int taille = noms.size(); // 3 // VÃ©rifier si vide boolean estVide = noms.isEmpty(); // false // VÃ©rifier la prÃ©sence boolean contient = noms.contains(\"Alice\"); // true Suppression ArrayList\u003cString\u003e noms = new ArrayList\u003c\u003e(); noms.add(\"Alice\"); noms.add(\"Bob\"); noms.add(\"Charlie\"); // Supprimer par index noms.remove(1); // Supprime \"Bob\" // Supprimer par valeur noms.remove(\"Charlie\"); // Supprime \"Charlie\" // Vider complÃ¨tement noms.clear(); // Liste vide Parcourir une ArrayList ArrayList\u003cString\u003e noms = new ArrayList\u003c\u003e(); noms.add(\"Alice\"); noms.add(\"Bob\"); noms.add(\"Charlie\"); // MÃ©thode 1: Boucle for classique for (int i = 0; i \u003c noms.size(); i++) { System.out.println(noms.get(i)); } // MÃ©thode 2: Boucle for-each (recommandÃ©) for (String nom : noms) { System.out.println(nom); } // MÃ©thode 3: forEach avec lambda (Java 8+) noms.forEach(nom -\u003e System.out.println(nom)); ArrayList avec des objets personnalisÃ©s public class Etudiant { private String nom; private double moyenne; public Etudiant(String nom, double moyenne) { this.nom = nom; this.moyenne = moyenne; } public String getNom() { return nom; } public double getMoyenne() { return moyenne; } @Override public String toString() { return nom + \" (\" + moyenne + \")\"; } } // Utilisation ArrayList\u003cEtudiant\u003e etudiants = new ArrayList\u003c\u003e(); etudiants.add(new Etudiant(\"Alice\", 85.5)); etudiants.add(new Etudiant(\"Bob\", 72.0)); etudiants.add(new Etudiant(\"Charlie\", 91.5)); // Parcourir for (Etudiant e : etudiants) { System.out.println(e.getNom() + \": \" + e.getMoyenne()); } // Trouver la meilleure moyenne double meilleureMoyenne = 0; Etudiant meilleur = null; for (Etudiant e : etudiants) { if (e.getMoyenne() \u003e meilleureMoyenne) { meilleureMoyenne = e.getMoyenne(); meilleur = e; } } System.out.println(\"Meilleur: \" + meilleur); 13.3 LinkedList - Liste chaÃ®nÃ©e LinkedList est optimisÃ©e pour les insertions/suppressions frÃ©quentes.\nimport java.util.LinkedList; public class ExempleLinkedList { public static void main(String[] args) { LinkedList\u003cString\u003e liste = new LinkedList\u003c\u003e(); // Ajout au dÃ©but liste.addFirst(\"Premier\"); // Ajout Ã  la fin liste.addLast(\"Dernier\"); // Ajout normal (Ã  la fin) liste.add(\"Milieu\"); System.out.println(liste); // [Premier, Dernier, Milieu] // RÃ©cupÃ©rer et supprimer le premier String premier = liste.removeFirst(); // RÃ©cupÃ©rer et supprimer le dernier String dernier = liste.removeLast(); // Voir sans supprimer String tete = liste.peekFirst(); String queue = liste.peekLast(); } } Quand utiliser LinkedList vs ArrayList ?\nOpÃ©ration ArrayList LinkedList AccÃ¨s par index âš¡ TrÃ¨s rapide ğŸŒ Lent Ajout Ã  la fin âš¡ Rapide âš¡ Rapide Ajout au dÃ©but ğŸŒ Lent âš¡ TrÃ¨s rapide Insertion au milieu ğŸŒ Lent âš¡ Rapide MÃ©moire Moins Plus RÃ¨gle gÃ©nÃ©rale : Utilisez ArrayList par dÃ©faut, sauf si vous faites beaucoup dâ€™insertions/suppressions au dÃ©but ou au milieu.\n13.4 HashSet - Ensemble sans doublons HashSet ne garde pas dâ€™ordre et nâ€™accepte pas de doublons.\nimport java.util.HashSet; public class ExempleHashSet { public static void main(String[] args) { HashSet\u003cString\u003e ensemble = new HashSet\u003c\u003e(); ensemble.add(\"Pomme\"); ensemble.add(\"Banane\"); ensemble.add(\"Orange\"); ensemble.add(\"Pomme\"); // IgnorÃ© (doublon) System.out.println(ensemble); // [Banane, Orange, Pomme] (ordre non garanti) System.out.println(ensemble.size()); // 3 // VÃ©rifier la prÃ©sence boolean existe = ensemble.contains(\"Banane\"); // true // Supprimer ensemble.remove(\"Orange\"); // Parcourir for (String fruit : ensemble) { System.out.println(fruit); } } } Exemple pratique : Ã©liminer les doublons\nArrayList\u003cInteger\u003e nombres = new ArrayList\u003c\u003e(); nombres.add(1); nombres.add(2); nombres.add(2); nombres.add(3); nombres.add(1); nombres.add(4); // Convertir en HashSet pour Ã©liminer les doublons HashSet\u003cInteger\u003e sansDoublons = new HashSet\u003c\u003e(nombres); System.out.println(sansDoublons); // [1, 2, 3, 4] // Reconvertir en ArrayList si besoin ArrayList\u003cInteger\u003e resultat = new ArrayList\u003c\u003e(sansDoublons); 13.5 TreeSet - Ensemble triÃ© TreeSet garde les Ã©lÃ©ments triÃ©s automatiquement.\nimport java.util.TreeSet; public class ExempleTreeSet { public static void main(String[] args) { TreeSet\u003cInteger\u003e nombres = new TreeSet\u003c\u003e(); nombres.add(5); nombres.add(2); nombres.add(8); nombres.add(1); nombres.add(2); // IgnorÃ© (doublon) System.out.println(nombres); // [1, 2, 5, 8] - TriÃ© automatiquement ! // RÃ©cupÃ©rer le premier et le dernier int premier = nombres.first(); // 1 int dernier = nombres.last(); // 8 // Sous-ensembles TreeSet\u003cInteger\u003e sousEnsemble = (TreeSet\u003cInteger\u003e) nombres.headSet(5); // \u003c 5 System.out.println(sousEnsemble); // [1, 2] } } Tri dâ€™objets personnalisÃ©s\nimport java.util.TreeSet; public class Personne implements Comparable\u003cPersonne\u003e { private String nom; private int age; public Personne(String nom, int age) { this.nom = nom; this.age = age; } // DÃ©finit comment comparer deux personnes @Override public int compareTo(Personne autre) { return Integer.compare(this.age, autre.age); // Tri par Ã¢ge } @Override public String toString() { return nom + \" (\" + age + \" ans)\"; } } // Utilisation TreeSet\u003cPersonne\u003e personnes = new TreeSet\u003c\u003e(); personnes.add(new Personne(\"Alice\", 25)); personnes.add(new Personne(\"Bob\", 30)); personnes.add(new Personne(\"Charlie\", 20)); System.out.println(personnes); // [Charlie (20 ans), Alice (25 ans), Bob (30 ans)] 13.6 HashMap - Dictionnaire clÃ©-valeur HashMap stocke des paires clÃ© â†’ valeur. Les clÃ©s sont uniques.\nimport java.util.HashMap; public class ExempleHashMap { public static void main(String[] args) { // CrÃ©ation d'un dictionnaire String â†’ Integer HashMap\u003cString, Integer\u003e ages = new HashMap\u003c\u003e(); // Ajout de paires clÃ©-valeur ages.put(\"Alice\", 25); ages.put(\"Bob\", 30); ages.put(\"Charlie\", 22); // RÃ©cupÃ©rer une valeur int ageAlice = ages.get(\"Alice\"); // 25 // VÃ©rifier la prÃ©sence d'une clÃ© boolean existe = ages.containsKey(\"Bob\"); // true // VÃ©rifier la prÃ©sence d'une valeur boolean a30ans = ages.containsValue(30); // true // Modifier une valeur (mÃªme clÃ©) ages.put(\"Alice\", 26); // Remplace 25 par 26 // Supprimer ages.remove(\"Charlie\"); // Taille int taille = ages.size(); // 2 System.out.println(ages); // {Alice=26, Bob=30} } } Parcourir un HashMap HashMap\u003cString, Integer\u003e ages = new HashMap\u003c\u003e(); ages.put(\"Alice\", 25); ages.put(\"Bob\", 30); ages.put(\"Charlie\", 22); // MÃ©thode 1: Parcourir les clÃ©s for (String nom : ages.keySet()) { System.out.println(nom + \" a \" + ages.get(nom) + \" ans\"); } // MÃ©thode 2: Parcourir les valeurs for (Integer age : ages.values()) { System.out.println(\"Age: \" + age); } // MÃ©thode 3: Parcourir les paires clÃ©-valeur (recommandÃ©) for (Map.Entry\u003cString, Integer\u003e entree : ages.entrySet()) { System.out.println(entree.getKey() + \" â†’ \" + entree.getValue()); } // MÃ©thode 4: forEach avec lambda (Java 8+) ages.forEach((nom, age) -\u003e System.out.println(nom + \": \" + age)); Exemple pratique : compter les occurrences String texte = \"le chat et le chien jouent avec le chat\"; String[] mots = texte.split(\" \"); HashMap\u003cString, Integer\u003e compteur = new HashMap\u003c\u003e(); for (String mot : mots) { if (compteur.containsKey(mot)) { // Le mot existe dÃ©jÃ , incrÃ©menter compteur.put(mot, compteur.get(mot) + 1); } else { // Nouveau mot compteur.put(mot, 1); } } System.out.println(compteur); // {le=3, chat=2, et=1, chien=1, jouent=1, avec=1} // Version courte avec getOrDefault (Java 8+) HashMap\u003cString, Integer\u003e compteur2 = new HashMap\u003c\u003e(); for (String mot : mots) { compteur2.put(mot, compteur2.getOrDefault(mot, 0) + 1); } 13.7 TreeMap - Map triÃ© par clÃ©s TreeMap maintient les clÃ©s triÃ©es.\nimport java.util.TreeMap; public class ExempleTreeMap { public static void main(String[] args) { TreeMap\u003cString, Double\u003e notes = new TreeMap\u003c\u003e(); notes.put(\"Charlie\", 85.5); notes.put(\"Alice\", 92.0); notes.put(\"Bob\", 78.5); System.out.println(notes); // {Alice=92.0, Bob=78.5, Charlie=85.5} - TriÃ© alphabÃ©tiquement // PremiÃ¨re et derniÃ¨re clÃ© String premier = notes.firstKey(); // \"Alice\" String dernier = notes.lastKey(); // \"Charlie\" } } 13.8 Comparaison des Collections Lists Type Ordre Doublons AccÃ¨s par index Meilleur usage ArrayList âœ… Maintenu âœ… AutorisÃ©s âš¡ Rapide Usage gÃ©nÃ©ral LinkedList âœ… Maintenu âœ… AutorisÃ©s ğŸŒ Lent Insertions frÃ©quentes Sets Type Ordre Doublons Performance HashSet âŒ Non garanti âŒ Interdits âš¡ TrÃ¨s rapide LinkedHashSet âœ… Insertion âŒ Interdits âš¡ Rapide TreeSet âœ… TriÃ© âŒ Interdits ğŸŒ Plus lent Maps Type Ordre des clÃ©s Doublons Performance HashMap âŒ Non garanti âŒ ClÃ©s uniques âš¡ TrÃ¨s rapide LinkedHashMap âœ… Insertion âŒ ClÃ©s uniques âš¡ Rapide TreeMap âœ… TriÃ© âŒ ClÃ©s uniques ğŸŒ Plus lent 13.9 MÃ©thodes utiles communes Conversion entre collections // ArrayList â†’ HashSet ArrayList\u003cString\u003e liste = new ArrayList\u003c\u003e(); liste.add(\"A\"); liste.add(\"B\"); liste.add(\"A\"); // doublon HashSet\u003cString\u003e ensemble = new HashSet\u003c\u003e(liste); // {A, B} // HashSet â†’ ArrayList ArrayList\u003cString\u003e nouvelleListe = new ArrayList\u003c\u003e(ensemble); // Tableau â†’ ArrayList String[] tableau = {\"A\", \"B\", \"C\"}; ArrayList\u003cString\u003e liste2 = new ArrayList\u003c\u003e(Arrays.asList(tableau)); Tri de collections import java.util.ArrayList; import java.util.Collections; ArrayList\u003cInteger\u003e nombres = new ArrayList\u003c\u003e(); nombres.add(5); nombres.add(2); nombres.add(8); nombres.add(1); // Tri croissant Collections.sort(nombres); System.out.println(nombres); // [1, 2, 5, 8] // Tri dÃ©croissant Collections.sort(nombres, Collections.reverseOrder()); System.out.println(nombres); // [8, 5, 2, 1] // MÃ©langer alÃ©atoirement Collections.shuffle(nombres); // Inverser l'ordre Collections.reverse(nombres); Tri dâ€™objets personnalisÃ©s import java.util.ArrayList; import java.util.Collections; import java.util.Comparator; class Etudiant { String nom; double moyenne; Etudiant(String nom, double moyenne) { this.nom = nom; this.moyenne = moyenne; } } ArrayList\u003cEtudiant\u003e etudiants = new ArrayList\u003c\u003e(); etudiants.add(new Etudiant(\"Alice\", 85.5)); etudiants.add(new Etudiant(\"Bob\", 92.0)); etudiants.add(new Etudiant(\"Charlie\", 78.5)); // Tri par moyenne (ordre croissant) Collections.sort(etudiants, new Comparator\u003cEtudiant\u003e() { @Override public int compare(Etudiant e1, Etudiant e2) { return Double.compare(e1.moyenne, e2.moyenne); } }); // Version courte avec lambda (Java 8+) Collections.sort(etudiants, (e1, e2) -\u003e Double.compare(e1.moyenne, e2.moyenne)); // Version encore plus courte (Java 8+) etudiants.sort(Comparator.comparingDouble(e -\u003e e.moyenne)); // Tri dÃ©croissant etudiants.sort(Comparator.comparingDouble(e -\u003e -e.moyenne)); 13.10 Exercices pratiques Exercice 1 : Gestion de contacts import java.util.HashMap; import java.util.Scanner; public class GestionContacts { public static void main(String[] args) { HashMap\u003cString, String\u003e contacts = new HashMap\u003c\u003e(); Scanner scanner = new Scanner(System.in); while (true) { System.out.println(\"\\n1. Ajouter contact\"); System.out.println(\"2. Chercher numero\"); System.out.println(\"3. Afficher tous\"); System.out.println(\"4. Quitter\"); System.out.print(\"Choix: \"); int choix = scanner.nextInt(); scanner.nextLine(); // Consommer le retour ligne if (choix == 1) { System.out.print(\"Nom: \"); String nom = scanner.nextLine(); System.out.print(\"Numero: \"); String numero = scanner.nextLine(); contacts.put(nom, numero); System.out.println(\"Contact ajoute !\"); } else if (choix == 2) { System.out.print(\"Nom: \"); String nom = scanner.nextLine(); if (contacts.containsKey(nom)) { System.out.println(nom + \": \" + contacts.get(nom)); } else { System.out.println(\"Contact introuvable\"); } } else if (choix == 3) { System.out.println(\"\\n=== Tous les contacts ===\"); for (String nom : contacts.keySet()) { System.out.println(nom + \": \" + contacts.get(nom)); } } else if (choix == 4) { break; } } } } Exercice 2 : Top 3 des Ã©tudiants import java.util.ArrayList; import java.util.Collections; import java.util.Comparator; class Etudiant { String nom; double moyenne; Etudiant(String nom, double moyenne) { this.nom = nom; this.moyenne = moyenne; } @Override public String toString() { return nom + \": \" + moyenne; } } public class Top3Etudiants { public static void main(String[] args) { ArrayList\u003cEtudiant\u003e etudiants = new ArrayList\u003c\u003e(); etudiants.add(new Etudiant(\"Alice\", 85.5)); etudiants.add(new Etudiant(\"Bob\", 92.0)); etudiants.add(new Etudiant(\"Charlie\", 78.5)); etudiants.add(new Etudiant(\"Diana\", 95.5)); etudiants.add(new Etudiant(\"Eve\", 88.0)); // Trier par moyenne dÃ©croissante etudiants.sort((e1, e2) -\u003e Double.compare(e2.moyenne, e1.moyenne)); // Afficher le top 3 System.out.println(\"=== Top 3 ===\"); for (int i = 0; i \u003c 3 \u0026\u0026 i \u003c etudiants.size(); i++) { System.out.println((i + 1) + \". \" + etudiants.get(i)); } } } Exercice 3 : Statistiques de texte import java.util.HashMap; import java.util.HashSet; public class StatistiquesTexte { public static void main(String[] args) { String texte = \"le chat et le chien jouent avec le chat noir et le chien blanc\"; String[] mots = texte.toLowerCase().split(\" \"); // Nombre total de mots System.out.println(\"Nombre total de mots: \" + mots.length); // Nombre de mots uniques HashSet\u003cString\u003e motsUniques = new HashSet\u003c\u003e(); for (String mot : mots) { motsUniques.add(mot); } System.out.println(\"Mots uniques: \" + motsUniques.size()); // FrÃ©quence de chaque mot HashMap\u003cString, Integer\u003e frequences = new HashMap\u003c\u003e(); for (String mot : mots) { frequences.put(mot, frequences.getOrDefault(mot, 0) + 1); } System.out.println(\"\\nFrequences:\"); for (String mot : frequences.keySet()) { System.out.println(mot + \": \" + frequences.get(mot)); } // Mot le plus frÃ©quent String plusFrequent = \"\"; int maxFreq = 0; for (String mot : frequences.keySet()) { if (frequences.get(mot) \u003e maxFreq) { maxFreq = frequences.get(mot); plusFrequent = mot; } } System.out.println(\"\\nMot le plus frequent: \" + plusFrequent + \" (\" + maxFreq + \" fois)\"); } } 13.11 Bonnes pratiques avec les Collections 1. Utiliser lâ€™interface dans les dÃ©clarations // âŒ Moins flexible ArrayList\u003cString\u003e liste = new ArrayList\u003c\u003e(); // âœ… Plus flexible List\u003cString\u003e liste = new ArrayList\u003c\u003e(); // On peut facilement changer vers LinkedList si besoin 2. SpÃ©cifier la capacitÃ© initiale si connue // Si vous savez que vous aurez environ 1000 Ã©lÃ©ments ArrayList\u003cString\u003e grande = new ArrayList\u003c\u003e(1000); // Ã‰vite les redimensionnements multiples 3. Utiliser les bonnes collections pour le bon usage // Recherche rapide de prÃ©sence â†’ HashSet HashSet\u003cString\u003e motsInterdits = new HashSet\u003c\u003e(); // Ordre d'insertion important â†’ LinkedHashMap LinkedHashMap\u003cString, Integer\u003e cache = new LinkedHashMap\u003c\u003e(); // Association clÃ©-valeur â†’ HashMap HashMap\u003cString, Etudiant\u003e index = new HashMap\u003c\u003e(); // Pas de doublons + tri â†’ TreeSet TreeSet\u003cInteger\u003e scores = new TreeSet\u003c\u003e(); 4. Faire attention aux null ArrayList\u003cString\u003e liste = new ArrayList\u003c\u003e(); liste.add(null); // AutorisÃ© dans ArrayList HashSet\u003cString\u003e ensemble = new HashSet\u003c\u003e(); ensemble.add(null); // Un seul null autorisÃ© dans HashSet HashMap\u003cString, Integer\u003e map = new HashMap\u003c\u003e(); map.put(null, 10); // Une seule clÃ© null autorisÃ©e RÃ©sumÃ© des notions ajoutÃ©es Notion Description Niveaux dâ€™accÃ¨s public, private, protected, default Packages Organisation du code avec package et import Static Variables et mÃ©thodes de classe Final Constantes, mÃ©thodes non-redÃ©finissables, classes non-hÃ©ritables Enum Types Ã©numÃ©rÃ©s pour reprÃ©senter des constantes Exceptions Gestion des erreurs avec try-catch-finally Composition Alternative Ã  lâ€™hÃ©ritage (HAS-A vs IS-A) SOLID 5 principes de conception POO Overloading Surcharge de mÃ©thodes et constructeurs ChaÃ®nage Appeler dâ€™autres constructeurs avec this() et super() Object MÃ©thodes toString(), equals(), hashCode() Classes imbriquÃ©es Classes Ã  lâ€™intÃ©rieur dâ€™autres classes Collections ArrayList, LinkedList, HashSet, TreeSet, HashMap, TreeMap",
    "description": "Table des matiÃ¨res Niveaux dâ€™accÃ¨s (Modificateurs de visibilitÃ©) Packages et organisation du code MÃ©thodes et variables statiques Classes imbriquÃ©es (Inner classes) Le mot-clÃ© final Ã‰numÃ©rations (enum) Gestion des exceptions Composition vs HÃ©ritage Principes SOLID Surcharge de mÃ©thodes (Overloading) Constructeurs multiples et chaÃ®nage La classe Object et ses mÃ©thodes Collections Java 1. Niveaux dâ€™accÃ¨s (Modificateurs de visibilitÃ©) Java propose 4 niveaux dâ€™accÃ¨s pour contrÃ´ler qui peut accÃ©der Ã  vos classes, attributs et mÃ©thodes.",
    "tags": [],
    "title": "Programmation orientÃ©e objet - 3",
    "uri": "/420-210/poo_3/index.html"
  },
  {
    "breadcrumb": "Programmation orientÃ©e objet",
    "content": "Exercices de Programmation OrientÃ©e Objet - Complet Ce document contient des exercices dÃ©taillÃ©s couvrant toutes les notions de POO vues dans les cours, organisÃ©s par niveau de difficultÃ©.\nTable des matiÃ¨res Niveau DÃ©butant (â­) Classes et objets basiques Attributs et mÃ©thodes Constructeurs Getters et Setters Niveau IntermÃ©diaire (â­â­) Encapsulation HÃ©ritage Surcharge de mÃ©thodes Static et Final Collections de base Niveau AvancÃ© (â­â­â­) Polymorphisme Classes abstraites Interfaces Exceptions Collections avancÃ©es Enum Niveau Expert (â­â­â­â­) Projets intÃ©grateurs Principes SOLID Composition vs HÃ©ritage Exercices Niveau DÃ©butant â­ Exercice 1.1 â€” Classe Livre Objectifs : Classes, attributs, constructeur basique\nCrÃ©ez une classe Livre avec :\nAttributs publics : titre (String), auteur (String), nombrePages (int) Un constructeur qui initialise tous les attributs Une mÃ©thode afficherInfo() qui affiche toutes les informations du livre Testez :\nLivre livre1 = new Livre(\"1984\", \"George Orwell\", 328); Livre livre2 = new Livre(\"Le Petit Prince\", \"Antoine de Saint-ExupÃ©ry\", 96); livre1.afficherInfo(); livre2.afficherInfo(); Sortie attendue :\nTitre: 1984, Auteur: George Orwell, Pages: 328\rTitre: Le Petit Prince, Auteur: Antoine de Saint-ExupÃ©ry, Pages: 96 Exercice 1.2 â€” Classe Rectangle Objectifs : MÃ©thodes avec retour de valeur\nCrÃ©ez une classe Rectangle avec :\nAttributs publics : largeur (double), hauteur (double) Un constructeur Une mÃ©thode calculerAire() qui retourne lâ€™aire (largeur Ã— hauteur) Une mÃ©thode calculerPerimetre() qui retourne le pÃ©rimÃ¨tre (2 Ã— (largeur + hauteur)) Une mÃ©thode estCarre() qui retourne true si câ€™est un carrÃ© Testez :\nRectangle r1 = new Rectangle(5.0, 3.0); Rectangle r2 = new Rectangle(4.0, 4.0); System.out.println(\"Aire: \" + r1.calculerAire()); System.out.println(\"Perimetre: \" + r1.calculerPerimetre()); System.out.println(\"Est carre: \" + r2.estCarre()); Exercice 1.3 â€” Classe CompteBancaire Simple Objectifs : MÃ©thodes qui modifient lâ€™Ã©tat de lâ€™objet\nCrÃ©ez une classe CompteBancaire avec :\nAttributs publics : titulaire (String), solde (double) Un constructeur qui prend le titulaire et le solde initial Une mÃ©thode deposer(double montant) qui ajoute au solde Une mÃ©thode retirer(double montant) qui retire du solde Une mÃ©thode afficherSolde() qui affiche le titulaire et le solde Testez :\nCompteBancaire compte = new CompteBancaire(\"Alice\", 1000.0); compte.afficherSolde(); compte.deposer(500.0); compte.retirer(200.0); compte.afficherSolde(); Exercice 1.4 â€” Classe Cercle Objectifs : Utilisation de Math.PI et de mÃ©thodes mathÃ©matiques\nCrÃ©ez une classe Cercle avec :\nAttribut public : rayon (double) Un constructeur Une mÃ©thode calculerAire() qui retourne Ï€ Ã— rayonÂ² Une mÃ©thode calculerCirconference() qui retourne 2 Ã— Ï€ Ã— rayon Une mÃ©thode calculerDiametre() qui retourne 2 Ã— rayon Indice : Utilisez Math.PI pour Ï€\nExercice 1.5 â€” Classe Produit Objectifs : Classes avec plusieurs mÃ©thodes\nCrÃ©ez une classe Produit avec :\nAttributs publics : nom (String), prix (double), quantite (int) Un constructeur Une mÃ©thode calculerValeurStock() qui retourne prix Ã— quantitÃ© Une mÃ©thode appliquerRemise(double pourcentage) qui rÃ©duit le prix Une mÃ©thode ajouterStock(int quantite) qui augmente la quantitÃ© Une mÃ©thode afficherInfo() Testez :\nProduit p = new Produit(\"Laptop\", 1200.0, 5); p.afficherInfo(); System.out.println(\"Valeur stock: \" + p.calculerValeurStock()); p.appliquerRemise(10); // 10% de rÃ©duction p.ajouterStock(3); p.afficherInfo(); Exercice 1.6 â€” Classe Personne Objectifs : Manipulation de strings et calculs dâ€™Ã¢ge\nCrÃ©ez une classe Personne avec :\nAttributs publics : nom (String), prenom (String), anneeNaissance (int) Un constructeur Une mÃ©thode getNomComplet() qui retourne â€œPrÃ©nom Nomâ€ Une mÃ©thode calculerAge() qui retourne lâ€™Ã¢ge actuel (utilisez 2025 comme annÃ©e actuelle) Une mÃ©thode estMajeur() qui retourne true si Ã¢ge â‰¥ 18 Exercice 1.7 â€” Classe Temperature Objectifs : Conversions et calculs\nCrÃ©ez une classe Temperature avec :\nAttribut public : celsius (double) Un constructeur Une mÃ©thode toFahrenheit() qui retourne la tempÃ©rature en Fahrenheit (F = C Ã— 9/5 + 32) Une mÃ©thode toKelvin() qui retourne la tempÃ©rature en Kelvin (K = C + 273.15) Une mÃ©thode afficher() qui affiche dans les 3 unitÃ©s Exercice 1.8 â€” Tableau dâ€™objets Objectifs : CrÃ©er et manipuler un tableau dâ€™objets\nRÃ©utilisez la classe Livre de lâ€™exercice 1.1.\nDans votre Main :\nCrÃ©ez un tableau de 5 livres Remplissez le tableau avec diffÃ©rents livres Affichez tous les livres avec une boucle Trouvez et affichez le livre avec le plus de pages Calculez le nombre moyen de pages Exercices Niveau IntermÃ©diaire â­â­ Exercice 2.1 â€” Encapsulation complÃ¨te Objectifs : Private, getters, setters avec validation\nReprenez la classe CompteBancaire et modifiez-la :\nRendez tous les attributs private CrÃ©ez des getters pour tous les attributs CrÃ©ez un setter pour titulaire (ne doit pas Ãªtre vide) Modifiez deposer() pour refuser les montants nÃ©gatifs ou zÃ©ro Modifiez retirer() pour vÃ©rifier les fonds insuffisants Ajoutez une mÃ©thode transferer(CompteBancaire destination, double montant) Testez :\nCompteBancaire c1 = new CompteBancaire(\"Alice\", 1000.0); CompteBancaire c2 = new CompteBancaire(\"Bob\", 500.0); c1.transferer(c2, 300.0); c1.afficherSolde(); // 700.0 c2.afficherSolde(); // 800.0 c1.transferer(c2, 1000.0); // Doit afficher une erreur Exercice 2.2 â€” HÃ©ritage : VÃ©hicules Objectifs : HÃ©ritage, super, redÃ©finition\nCrÃ©ez une hiÃ©rarchie de classes :\nClasse parent Vehicule :\nAttributs privÃ©s : marque, modele, annee Constructeur MÃ©thode afficherInfo() MÃ©thode calculerAge() (retourne 2025 - annee) Classe enfant Voiture (extends Vehicule) :\nAttribut privÃ© supplÃ©mentaire : nombrePortes Constructeur qui appelle super() RedÃ©finition de afficherInfo() pour inclure le nombre de portes Classe enfant Moto (extends Vehicule) :\nAttribut privÃ© supplÃ©mentaire : cylindree Constructeur qui appelle super() RedÃ©finition de afficherInfo() pour inclure la cylindrÃ©e Testez dans un tableau polymorphe :\nVehicule[] flotte = new Vehicule[3]; flotte[0] = new Voiture(\"Toyota\", \"Corolla\", 2020, 4); flotte[1] = new Moto(\"Harley\", \"Sportster\", 2019, 883); flotte[2] = new Voiture(\"Honda\", \"Civic\", 2022, 4); for (Vehicule v : flotte) { v.afficherInfo(); System.out.println(\"Age: \" + v.calculerAge() + \" ans\\n\"); } Exercice 2.3 â€” Surcharge de mÃ©thodes Objectifs : Overloading de mÃ©thodes\nCrÃ©ez une classe Calculatrice avec plusieurs versions de la mÃ©thode additionner() :\nadditionner(int a, int b) â†’ retourne la somme de 2 entiers additionner(int a, int b, int c) â†’ retourne la somme de 3 entiers additionner(double a, double b) â†’ retourne la somme de 2 doubles additionner(int[] nombres) â†’ retourne la somme dâ€™un tableau dâ€™entiers Testez :\nCalculatrice calc = new Calculatrice(); System.out.println(calc.additionner(2, 3)); System.out.println(calc.additionner(2, 3, 4)); System.out.println(calc.additionner(2.5, 3.7)); System.out.println(calc.additionner(new int[]{1, 2, 3, 4, 5})); Exercice 2.4 â€” Surcharge de constructeurs Objectifs : ChaÃ®nage de constructeurs avec this()\nCrÃ©ez une classe Employe avec :\nAttributs privÃ©s : nom, prenom, salaire, departement Constructeur 1 : Employe(String nom, String prenom, double salaire, String departement) Constructeur 2 : Employe(String nom, String prenom, double salaire) â†’ appelle constructeur 1 avec â€œNon assignÃ©â€ pour le dÃ©partement Constructeur 3 : Employe(String nom, String prenom) â†’ appelle constructeur 2 avec salaire de 30000.0 MÃ©thode afficherInfo() Testez les 3 constructeurs :\nEmploye e1 = new Employe(\"Dupont\", \"Alice\", 50000.0, \"IT\"); Employe e2 = new Employe(\"Martin\", \"Bob\", 45000.0); Employe e3 = new Employe(\"Tremblay\", \"Charlie\"); e1.afficherInfo(); e2.afficherInfo(); e3.afficherInfo(); Exercice 2.5 â€” Static : Compteur dâ€™instances Objectifs : Variables et mÃ©thodes statiques\nCrÃ©ez une classe Etudiant avec :\nAttributs privÃ©s : nom, numeroEtudiant Attribut static : compteur (initialisÃ© Ã  0) Attribut static final : UNIVERSITE = \"UdeM\" Constructeur qui incrÃ©mente compteur et assigne automatiquement un numÃ©ro (compteur actuel) MÃ©thode static : getNombreEtudiants() qui retourne le compteur MÃ©thode normale : afficherInfo() Testez :\nSystem.out.println(\"Universite: \" + Etudiant.UNIVERSITE); System.out.println(\"Nombre initial: \" + Etudiant.getNombreEtudiants()); Etudiant e1 = new Etudiant(\"Alice\"); Etudiant e2 = new Etudiant(\"Bob\"); Etudiant e3 = new Etudiant(\"Charlie\"); System.out.println(\"Nombre apres creation: \" + Etudiant.getNombreEtudiants()); e1.afficherInfo(); e2.afficherInfo(); Sortie attendue :\nUniversite: UdeM\rNombre initial: 0\rNombre apres creation: 3\rNom: Alice, Numero: 1\rNom: Bob, Numero: 2 Exercice 2.6 â€” Final : Configuration Objectifs : Constantes finales, mÃ©thodes finales\nCrÃ©ez une classe Configuration avec :\nConstantes static final : VERSION = \"1.0.0\" MAX_CONNEXIONS = 100 TIMEOUT_SECONDES = 30 Une mÃ©thode finale afficherConfig() qui affiche toutes les constantes Une mÃ©thode normale validerConnexions(int nombre) qui retourne true si nombre â‰¤ MAX_CONNEXIONS CrÃ©ez une classe ConfigurationAvancee qui hÃ©rite de Configuration et essayez (pour voir lâ€™erreur) de redÃ©finir afficherConfig().\nExercice 2.7 â€” ArrayList basique Objectifs : Utilisation de ArrayList\nCrÃ©ez un programme qui :\nCrÃ©e une ArrayList\u003cString\u003e de prÃ©noms Ajoute 5 prÃ©noms Affiche tous les prÃ©noms avec une boucle Demande Ã  lâ€™utilisateur un prÃ©nom Ã  chercher (utilisez Scanner) Affiche si le prÃ©nom existe dans la liste Supprime un prÃ©nom et affiche la nouvelle liste Affiche la taille finale de la liste Exercice 2.8 â€” ArrayList dâ€™objets Objectifs : ArrayList avec objets personnalisÃ©s\nRÃ©utilisez la classe Produit de lâ€™exercice 1.5.\nDans votre Main :\nCrÃ©ez une ArrayList\u003cProduit\u003e Ajoutez 6 produits diffÃ©rents Affichez tous les produits Calculez la valeur totale du stock (somme de toutes les valeurs) Trouvez le produit le plus cher Trouvez tous les produits avec un prix \u003e 50.0 et affichez-les Supprimez tous les produits avec quantitÃ© = 0 Exercice 2.9 â€” HashMap : Dictionnaire Objectifs : Utilisation de HashMap\nCrÃ©ez un programme â€œdictionnaire franÃ§ais-anglaisâ€ avec :\nUn HashMap\u003cString, String\u003e qui associe mots franÃ§ais â†’ mots anglais Ajoutez 10 paires (ex: â€œchatâ€ â†’ â€œcatâ€, â€œchienâ€ â†’ â€œdogâ€, etc.) Demandez Ã  lâ€™utilisateur un mot franÃ§ais (Scanner) Affichez la traduction si elle existe, sinon â€œMot introuvableâ€ Affichez tous les mots du dictionnaire Comptez combien de mots commencent par â€œcâ€ Exercices Niveau AvancÃ© â­â­â­ Exercice 3.1 â€” Polymorphisme : Animaux Objectifs : Polymorphisme, redÃ©finition, tableaux polymorphes\nCrÃ©ez une hiÃ©rarchie :\nClasse Animal (normale, pas abstraite) :\nAttributs privÃ©s : nom, age Constructeur MÃ©thode faireDuBruit() qui affiche â€œLâ€™animal fait du bruitâ€ MÃ©thode afficherInfo() Classes enfants :\nChien : redÃ©finit faireDuBruit() pour afficher â€œOuaf!â€ Chat : redÃ©finit faireDuBruit() pour afficher â€œMiaou!â€ Vache : redÃ©finit faireDuBruit() pour afficher â€œMeuh!â€ Dans Main :\nCrÃ©ez un tableau Animal[] de 6 animaux (mÃ©lange de chiens, chats, vaches) Parcourez le tableau et appelez faireDuBruit() pour chacun Comptez combien il y a de chiens (utilisez instanceof) Calculez lâ€™Ã¢ge moyen de tous les animaux Exercice 3.2 â€” Classe abstraite : Formes gÃ©omÃ©triques Objectifs : Classes abstraites, mÃ©thodes abstraites\nCrÃ©ez une hiÃ©rarchie :\nClasse abstraite Forme :\nAttribut protÃ©gÃ© : couleur Constructeur MÃ©thodes abstraites : calculerAire(), calculerPerimetre() MÃ©thode normale : afficherCouleur() Classes concrÃ¨tes :\nRectangle : attributs largeur, hauteur Cercle : attribut rayon Triangle : attributs base, hauteur, cote1, cote2 Dans Main :\nCrÃ©ez un tableau Forme[] avec 5 formes diffÃ©rentes Affichez lâ€™aire et le pÃ©rimÃ¨tre de chaque forme Trouvez la forme avec la plus grande aire Calculez lâ€™aire totale de toutes les formes Formules :\nRectangle : aire = lÃ—h, pÃ©rimÃ¨tre = 2(l+h) Cercle : aire = Ï€rÂ², pÃ©rimÃ¨tre = 2Ï€r Triangle : aire = (bÃ—h)/2, pÃ©rimÃ¨tre = b+c1+c2 Exercice 3.3 â€” Interface : Ã‰lectronique Objectifs : Interfaces, implÃ©mentation multiple\nCrÃ©ez les interfaces :\nInterface Rechargeable :\nvoid recharger() int getNiveauBatterie() boolean estCharge() (retourne true si batterie â‰¥ 80) Interface Connecte :\nvoid connecterWifi(String reseau) void deconnecterWifi() boolean estConnecte() Classe Smartphone (implements Rechargeable, Connecte) :\nAttributs privÃ©s : marque, modele, batterie, reseauActuel ImplÃ©mentez toutes les mÃ©thodes des interfaces Ajoutez une mÃ©thode utiliser(int minutes) qui diminue la batterie de 1% par 10 minutes Classe Ordinateur (implements Rechargeable, Connecte) :\nMÃªme structure que Smartphone Classe Montre (implements Rechargeable seulement) :\nPas de connexion wifi Dans Main :\nCrÃ©ez un tableau Rechargeable[] avec 5 appareils Rechargez tous les appareils Affichez lesquels sont connectÃ©s au wifi (utilisez instanceof Connecte) Exercice 3.4 â€” Exceptions : Gestion bancaire robuste Objectifs : Try-catch, exceptions personnalisÃ©es\nCrÃ©ez une exception personnalisÃ©e :\nSoldeInsuffisantException (extends Exception) :\nAttributs : soldeActuel, montantDemande Constructeur qui prend ces valeurs Message : â€œSolde insuffisant: {soldeActuel} \u003c {montantDemande}â€ Modifiez CompteBancaire :\nMÃ©thode retirer() qui lance SoldeInsuffisantException si fonds insuffisants MÃ©thode transferer() qui lance lâ€™exception si transfert impossible Dans Main :\nCompteBancaire c1 = new CompteBancaire(\"Alice\", 1000.0); CompteBancaire c2 = new CompteBancaire(\"Bob\", 500.0); try { c1.retirer(1500.0); } catch (SoldeInsuffisantException e) { System.out.println(\"Erreur: \" + e.getMessage()); System.out.println(\"Solde actuel: \" + e.getSoldeActuel()); } try { c1.transferer(c2, 800.0); c1.transferer(c2, 500.0); // Ceci devrait Ã©chouer } catch (SoldeInsuffisantException e) { System.out.println(\"Transfert impossible: \" + e.getMessage()); } Exercice 3.5 â€” Enum : SystÃ¨me de rÃ©servation Objectifs : Ã‰numÃ©rations avec attributs\nCrÃ©ez un enum JourSemaine :\nValeurs : LUNDI, MARDI, MERCREDI, JEUDI, VENDREDI, SAMEDI, DIMANCHE Attributs : numero (1-7), estWeekend (boolean) Constructeur privÃ© MÃ©thodes : getNumero(), estWeekend(), getJourSuivant() CrÃ©ez une classe Reservation :\nAttributs : nom, jour (JourSemaine), nombrePersonnes MÃ©thode calculerPrix() : 50$ par personne en semaine, 70$ par personne le weekend Dans Main :\nCrÃ©ez 5 rÃ©servations pour diffÃ©rents jours Affichez le prix total de chaque rÃ©servation Calculez le revenu total Affichez combien de rÃ©servations sont en weekend Exercice 3.6 â€” Collections : Gestion dâ€™Ã©tudiants Objectifs : ArrayList, HashMap, tri\nCrÃ©ez une classe Etudiant :\nAttributs : nom, prenom, numeroEtudiant, moyenne Constructeur, getters, toString() Dans Main, crÃ©ez :\nUne ArrayList\u003cEtudiant\u003e avec 10 Ã©tudiants Un HashMap\u003cInteger, Etudiant\u003e qui associe numÃ©ro â†’ Ã©tudiant Affichez les Ã©tudiants triÃ©s par moyenne (ordre dÃ©croissant) Trouvez et affichez le top 3 Calculez la moyenne gÃ©nÃ©rale de la classe CrÃ©ez un HashSet\u003cString\u003e des noms de famille uniques Affichez combien dâ€™Ã©tudiants ont une moyenne â‰¥ 80 Exercice 3.7 â€” TreeSet : Classement Objectifs : TreeSet, Comparable\nCrÃ©ez une classe Joueur (implements Comparable) :\nAttributs : pseudo, score ImplÃ©mentez compareTo() pour trier par score dÃ©croissant (score le plus Ã©levÃ© en premier) Si scores Ã©gaux, trier alphabÃ©tiquement par pseudo Dans Main :\nCrÃ©ez un TreeSet\u003cJoueur\u003e Ajoutez 8 joueurs avec diffÃ©rents scores Affichez le classement (TreeSet affiche automatiquement triÃ©) Affichez le top 3 Ajoutez un nouveau joueur et montrez le nouveau classement Exercice 3.8 â€” HashMap avancÃ© : Statistiques de texte Objectifs : HashMap, analyse de donnÃ©es\nCrÃ©ez un programme qui :\nLit un texte long (utilisez un String avec plusieurs phrases) Compte la frÃ©quence de chaque mot (HashMap\u003cString, Integer\u003e) Affiche les 5 mots les plus frÃ©quents Compte combien de mots diffÃ©rents il y a Trouve le mot le plus long CrÃ©e un HashMap\u003cInteger, ArrayList\u003e qui groupe les mots par longueur Exemple de texte :\nString texte = \"le chat et le chien jouent dans le jardin le chat aime le soleil \" + \"le chien aime courir le jardin est grand et beau\"; Exercices Niveau Expert â­â­â­â­ Exercice 4.1 â€” Projet : SystÃ¨me de bibliothÃ¨que Objectifs : IntÃ©gration de plusieurs concepts\nCrÃ©ez un systÃ¨me complet avec :\nClasse abstraite Document :\nAttributs : titre, auteur, annee, estEmprunte MÃ©thode abstraite : calculerFraisRetard(int joursRetard) MÃ©thodes normales : emprunter(), retourner() Classes concrÃ¨tes :\nLivre : attribut nombrePages, frais = 0.50$ par jour DVD : attribut duree, frais = 1.00$ par jour Magazine : attribut numero, frais = 0.25$ par jour Classe Membre :\nAttributs : nom, numeroMembre, documentsEmpruntes (ArrayList) MÃ©thodes : emprunterDocument(), retournerDocument(), afficherEmprunts() Classe Bibliotheque :\nAttributs : nom, documents (ArrayList), membres (HashMap\u003cInteger, Membre\u003e) MÃ©thodes : ajouterDocument() ajouterMembre() rechercherDocument(String titre) afficherDocumentsDisponibles() genererRapport() (nombre total de documents, nombre empruntÃ©, etc.) CrÃ©ez un menu interactif permettant de :\nAjouter un document Ajouter un membre Emprunter un document Retourner un document Afficher tous les documents Afficher les emprunts dâ€™un membre GÃ©nÃ©rer un rapport Quitter Exercice 4.2 â€” Projet : SystÃ¨me de commande en ligne Objectifs : POO complÃ¨te, collections avancÃ©es\nInterface Livrable :\ndouble calculerFraisLivraison() int estimerDelaiLivraison() Classe Produit :\nAttributs : nom, prix, poids, categorie Classe Panier :\nHashMap\u003cProduit, Integer\u003e pour stocker produit â†’ quantitÃ© MÃ©thodes : ajouter(), retirer(), calculerTotal(), vider() Classe Commande (implements Livrable) :\nAttributs : numero, client, panier, adresse, statut (enum) MÃ©thode calculerFraisLivraison() basÃ©e sur le poids total MÃ©thode appliquerCodePromo(String code) (HashMap des codes promo) Enum StatutCommande :\nEN_PREPARATION, EXPEDIEE, EN_LIVRAISON, LIVREE, ANNULEE Classe Client :\nAttributs : nom, email, adresse, historiqueCommandes (ArrayList) MÃ©thodes : passerCommande(), afficherHistorique(), calculerTotalDepense() ImplÃ©mentez un systÃ¨me complet avec menu permettant de :\nCrÃ©er un compte client Ajouter des produits au panier Passer une commande Voir lâ€™historique des commandes Calculer les statistiques (total dÃ©pensÃ©, commandes par statut, etc.) Exercice 4.3 â€” SOLID : Refactoring Objectifs : Appliquer les principes SOLID\nVoici du mauvais code qui viole plusieurs principes SOLID :\npublic class Employee { private String name; private double salary; private String type; // \"manager\", \"developer\", \"designer\" public double calculatePay() { if (type.equals(\"manager\")) { return salary * 1.5; } else if (type.equals(\"developer\")) { return salary * 1.2; } else { return salary; } } public void saveToDatabase() { // Code SQL pour sauvegarder System.out.println(\"INSERT INTO employees...\"); } public void generateReport() { // GÃ©nÃ¨re un rapport System.out.println(\"=== Employee Report ===\"); System.out.println(\"Name: \" + name); System.out.println(\"Salary: \" + salary); } } Votre mission :\nIdentifiez quels principes SOLID sont violÃ©s Refactorisez le code pour respecter les principes SOLID : S : SÃ©parez les responsabilitÃ©s O : Rendez extensible sans modification L : Assurez la substituabilitÃ© I : CrÃ©ez des interfaces spÃ©cifiques D : Inversez les dÃ©pendances CrÃ©ez :\nUne classe abstraite ou interface pour les employÃ©s Des classes sÃ©parÃ©es pour Manager, Developer, Designer Une classe sÃ©parÃ©e pour la sauvegarde (EmployeeRepository) Une classe sÃ©parÃ©e pour les rapports (EmployeeReportGenerator) Des interfaces appropriÃ©es Exercice 4.4 â€” Composition vs HÃ©ritage : VÃ©hicules Objectifs : Comprendre quand utiliser composition plutÃ´t quâ€™hÃ©ritage\nPartie 1 : Mauvaise conception avec hÃ©ritage\nCrÃ©ez cette hiÃ©rarchie (pour voir le problÃ¨me) :\nVehicule\râ”œâ”€â”€ VehiculeAMoteur\râ”‚ â”œâ”€â”€ Voiture\râ”‚ â””â”€â”€ Moto\râ””â”€â”€ VehiculeSansMoteur\râ”œâ”€â”€ Velo\râ””â”€â”€ Trottinette ProblÃ¨me : Et si on a une voiture Ã©lectrique ? Un vÃ©lo Ã©lectrique ?\nPartie 2 : Bonne conception avec composition\nRefactorisez en utilisant la composition :\nInterface Propulsion :\nvoid avancer() void arreter() String getType() Classes de propulsion :\nMoteurEssence implements Propulsion MoteurElectrique implements Propulsion PedaleHumaine implements Propulsion Classe Vehicule :\nAttribut : Propulsion propulsion (composition!) Constructeur qui prend une Propulsion MÃ©thode demarrer() qui dÃ©lÃ¨gue Ã  propulsion CrÃ©ez ensuite :\nVoiture avec MoteurEssence VoitureElectrique avec MoteurElectrique Velo avec PedaleHumaine VeloElectrique avec MoteurElectrique Montrez que câ€™est beaucoup plus flexible !\nExercice 4.5 â€” Projet intÃ©grateur : Jeu de cartes Objectifs : Projet complet utilisant tous les concepts\nCrÃ©ez un jeu de BlackJack avec :\nEnum Couleur :\nCOEUR, CARREAU, TREFLE, PIQUE Attribut : symbole (\"â™¥\", â€œâ™¦â€, â€œâ™£â€, â€œâ™ â€) Enum Valeur :\nAS, DEUX, TROIS, â€¦, DIX, VALET, DAME, ROI Attributs : points (1-13), affichage (â€œAâ€, â€œ2â€, â€¦, â€œKâ€) Classe Carte :\nAttributs : couleur, valeur MÃ©thode getValeurBlackjack() (As=1 ou 11, figures=10) Classe Paquet :\nArrayList avec les 52 cartes MÃ©thodes : melanger(), piocher(), estVide() Classe abstraite Joueur :\nAttributs : nom, main (ArrayList) MÃ©thode abstraite : decidePiocher(int scoreActuel, Carte carteVisible) MÃ©thodes normales : recevoirCarte(), calculerScore(), afficherMain() Classes concrÃ¨tes :\nJoueurHumain : demande Ã  lâ€™utilisateur Croupier : pioche si score \u003c 17 Classe PartieBlackjack :\nGÃ¨re le dÃ©roulement du jeu HashMap\u003cJoueur, Integer\u003e pour les scores MÃ©thodes : distribuerCartes(), jouer(), determinerGagnant() Statistiques (classe sÃ©parÃ©e) :\nNombre de parties jouÃ©es Nombre de victoires du joueur Pourcentage de victoire ImplÃ©mentez un jeu complet avec plusieurs manches !\nExercice 4.6 â€” Collections avancÃ©es : RÃ©seau social Objectifs : Collections complexes, graphes\nCrÃ©ez un mini rÃ©seau social avec :\nClasse Utilisateur :\nAttributs : pseudo, nom, age, amis (HashSet) MÃ©thodes : ajouterAmi(), retirerAmi(), estAmiAvec() Classe Publication :\nAttributs : auteur, contenu, date, likes (HashSet) MÃ©thodes : aimer(), retirerLike(), getNombreLikes() Classe ReseauSocial :\nHashMap\u003cString, Utilisateur\u003e : pseudo â†’ utilisateur ArrayList : toutes les publications MÃ©thodes avancÃ©es : suggererAmis(Utilisateur u) : retourne les amis dâ€™amis qui ne sont pas encore amis trouverCheminAmitie(Utilisateur u1, Utilisateur u2) : algorithme de parcours utilisateursPopulaires(int seuil) : utilisateurs avec \u003e seuil amis publicationsPopulaires() : publications avec le plus de likes calculerDegrÃ©Separation(Utilisateur u1, Utilisateur u2) : â€œ6 degrees of separationâ€ ImplÃ©mentez des algorithmes de parcours de graphe pour trouver les chemins dâ€™amitiÃ© !\nSolutions - Exercices DÃ©butants Solution 1.1 â€” Classe Livre public class Livre { public String titre; public String auteur; public int nombrePages; public Livre(String titre, String auteur, int nombrePages) { this.titre = titre; this.auteur = auteur; this.nombrePages = nombrePages; } public void afficherInfo() { System.out.println(\"Titre: \" + titre + \", Auteur: \" + auteur + \", Pages: \" + nombrePages); } } // Main public class Main { public static void main(String[] args) { Livre livre1 = new Livre(\"1984\", \"George Orwell\", 328); Livre livre2 = new Livre(\"Le Petit Prince\", \"Antoine de Saint-ExupÃ©ry\", 96); livre1.afficherInfo(); livre2.afficherInfo(); } } Solution 1.2 â€” Classe Rectangle public class Rectangle { public double largeur; public double hauteur; public Rectangle(double largeur, double hauteur) { this.largeur = largeur; this.hauteur = hauteur; } public double calculerAire() { return largeur * hauteur; } public double calculerPerimetre() { return 2 * (largeur + hauteur); } public boolean estCarre() { return largeur == hauteur; } } // Main public class Main { public static void main(String[] args) { Rectangle r1 = new Rectangle(5.0, 3.0); Rectangle r2 = new Rectangle(4.0, 4.0); System.out.println(\"Aire: \" + r1.calculerAire()); System.out.println(\"Perimetre: \" + r1.calculerPerimetre()); System.out.println(\"Est carre: \" + r2.estCarre()); } } Solution 1.3 â€” Classe CompteBancaire Simple public class CompteBancaire { public String titulaire; public double solde; public CompteBancaire(String titulaire, double solde) { this.titulaire = titulaire; this.solde = solde; } public void deposer(double montant) { solde += montant; System.out.println(\"Depot de \" + montant + \" effectue\"); } public void retirer(double montant) { solde -= montant; System.out.println(\"Retrait de \" + montant + \" effectue\"); } public void afficherSolde() { System.out.println(titulaire + \" - Solde: \" + solde); } } // Main public class Main { public static void main(String[] args) { CompteBancaire compte = new CompteBancaire(\"Alice\", 1000.0); compte.afficherSolde(); compte.deposer(500.0); compte.retirer(200.0); compte.afficherSolde(); } } Solution 1.4 â€” Classe Cercle public class Cercle { public double rayon; public Cercle(double rayon) { this.rayon = rayon; } public double calculerAire() { return Math.PI * rayon * rayon; } public double calculerCirconference() { return 2 * Math.PI * rayon; } public double calculerDiametre() { return 2 * rayon; } } // Main public class Main { public static void main(String[] args) { Cercle c = new Cercle(5.0); System.out.printf(\"Aire: %.2f%n\", c.calculerAire()); System.out.printf(\"Circonference: %.2f%n\", c.calculerCirconference()); System.out.printf(\"Diametre: %.2f%n\", c.calculerDiametre()); } } Solution 1.8 â€” Tableau dâ€™objets public class Main { public static void main(String[] args) { // 1. CrÃ©er un tableau de 5 livres Livre[] bibliotheque = new Livre[5]; // 2. Remplir le tableau bibliotheque[0] = new Livre(\"1984\", \"George Orwell\", 328); bibliotheque[1] = new Livre(\"Le Petit Prince\", \"Antoine de Saint-ExupÃ©ry\", 96); bibliotheque[2] = new Livre(\"Harry Potter\", \"J.K. Rowling\", 450); bibliotheque[3] = new Livre(\"Le Seigneur des Anneaux\", \"J.R.R. Tolkien\", 1200); bibliotheque[4] = new Livre(\"Fondation\", \"Isaac Asimov\", 255); // 3. Afficher tous les livres System.out.println(\"=== Tous les livres ===\"); for (Livre livre : bibliotheque) { livre.afficherInfo(); } // 4. Trouver le livre avec le plus de pages Livre plusLong = bibliotheque[0]; for (Livre livre : bibliotheque) { if (livre.nombrePages \u003e plusLong.nombrePages) { plusLong = livre; } } System.out.println(\"\\nLivre le plus long:\"); plusLong.afficherInfo(); // 5. Calculer le nombre moyen de pages int totalPages = 0; for (Livre livre : bibliotheque) { totalPages += livre.nombrePages; } double moyenne = (double) totalPages / bibliotheque.length; System.out.printf(\"\\nNombre moyen de pages: %.2f%n\", moyenne); } } Solutions - Exercices IntermÃ©diaires Solution 2.1 â€” Encapsulation complÃ¨te public class CompteBancaire { private String titulaire; private double solde; public CompteBancaire(String titulaire, double solde) { this.titulaire = titulaire; this.solde = solde; } // Getters public String getTitulaire() { return titulaire; } public double getSolde() { return solde; } // Setter avec validation public void setTitulaire(String titulaire) { if (titulaire == null || titulaire.trim().isEmpty()) { System.out.println(\"Erreur: le titulaire ne peut pas etre vide\"); return; } this.titulaire = titulaire; } public void deposer(double montant) { if (montant \u003c= 0) { System.out.println(\"Erreur: le montant doit etre positif\"); return; } solde += montant; System.out.println(\"Depot de \" + montant + \" effectue\"); } public void retirer(double montant) { if (montant \u003c= 0) { System.out.println(\"Erreur: le montant doit etre positif\"); return; } if (montant \u003e solde) { System.out.println(\"Erreur: fonds insuffisants\"); return; } solde -= montant; System.out.println(\"Retrait de \" + montant + \" effectue\"); } public void transferer(CompteBancaire destination, double montant) { if (montant \u003e solde) { System.out.println(\"Erreur: fonds insuffisants pour le transfert\"); return; } this.retirer(montant); destination.deposer(montant); System.out.println(\"Transfert de \" + montant + \" vers \" + destination.getTitulaire()); } public void afficherSolde() { System.out.println(titulaire + \" - Solde: \" + solde); } } Solution 2.2 â€” HÃ©ritage : VÃ©hicules // Classe parent public class Vehicule { private String marque; private String modele; private int annee; public Vehicule(String marque, String modele, int annee) { this.marque = marque; this.modele = modele; this.annee = annee; } public void afficherInfo() { System.out.println(marque + \" \" + modele + \" (\" + annee + \")\"); } public int calculerAge() { return 2025 - annee; } // Getters public String getMarque() { return marque; } public String getModele() { return modele; } public int getAnnee() { return annee; } } // Classe enfant Voiture public class Voiture extends Vehicule { private int nombrePortes; public Voiture(String marque, String modele, int annee, int nombrePortes) { super(marque, modele, annee); this.nombrePortes = nombrePortes; } @Override public void afficherInfo() { super.afficherInfo(); System.out.println(\" Nombre de portes: \" + nombrePortes); } public int getNombrePortes() { return nombrePortes; } } // Classe enfant Moto public class Moto extends Vehicule { private int cylindree; public Moto(String marque, String modele, int annee, int cylindree) { super(marque, modele, annee); this.cylindree = cylindree; } @Override public void afficherInfo() { super.afficherInfo(); System.out.println(\" Cylindree: \" + cylindree + \" cc\"); } public int getCylindree() { return cylindree; } } // Main public class Main { public static void main(String[] args) { Vehicule[] flotte = new Vehicule[3]; flotte[0] = new Voiture(\"Toyota\", \"Corolla\", 2020, 4); flotte[1] = new Moto(\"Harley\", \"Sportster\", 2019, 883); flotte[2] = new Voiture(\"Honda\", \"Civic\", 2022, 4); for (Vehicule v : flotte) { v.afficherInfo(); System.out.println(\"Age: \" + v.calculerAge() + \" ans\\n\"); } } } Solution 2.5 â€” Static : Compteur dâ€™instances public class Etudiant { private String nom; private int numeroEtudiant; private static int compteur = 0; public static final String UNIVERSITE = \"UdeM\"; public Etudiant(String nom) { this.nom = nom; compteur++; this.numeroEtudiant = compteur; } public static int getNombreEtudiants() { return compteur; } public void afficherInfo() { System.out.println(\"Nom: \" + nom + \", Numero: \" + numeroEtudiant); } } // Main public class Main { public static void main(String[] args) { System.out.println(\"Universite: \" + Etudiant.UNIVERSITE); System.out.println(\"Nombre initial: \" + Etudiant.getNombreEtudiants()); Etudiant e1 = new Etudiant(\"Alice\"); Etudiant e2 = new Etudiant(\"Bob\"); Etudiant e3 = new Etudiant(\"Charlie\"); System.out.println(\"Nombre apres creation: \" + Etudiant.getNombreEtudiants()); e1.afficherInfo(); e2.afficherInfo(); e3.afficherInfo(); } } Note sur les solutions Les solutions complÃ¨tes pour les exercices avancÃ©s et experts sont volontairement omises pour encourager la pratique autonome. Voici quelques conseils :\nPour les exercices avancÃ©s (â­â­â­) :\nCommencez par dessiner un diagramme de classes ImplÃ©mentez une fonctionnalitÃ© Ã  la fois Testez chaque mÃ©thode avant de passer Ã  la suivante Nâ€™hÃ©sitez pas Ã  crÃ©er des mÃ©thodes helper privÃ©es Pour les exercices experts (â­â­â­â­) :\nPlanifiez votre architecture avant de coder Utilisez des noms de variables et mÃ©thodes descriptifs Commentez les parties complexes Testez avec diffÃ©rents scÃ©narios Refactorisez si le code devient trop complexe Debugging Tips :\nUtilisez System.out.println() pour tracer lâ€™exÃ©cution VÃ©rifiez toujours les cas limites (listes vides, valeurs nulles, etc.) Testez avec des donnÃ©es variÃ©es Utilisez le dÃ©bogueur de votre IDE",
    "description": "Exercices de Programmation OrientÃ©e Objet - Complet Ce document contient des exercices dÃ©taillÃ©s couvrant toutes les notions de POO vues dans les cours, organisÃ©s par niveau de difficultÃ©.\nTable des matiÃ¨res Niveau DÃ©butant (â­) Classes et objets basiques Attributs et mÃ©thodes Constructeurs Getters et Setters Niveau IntermÃ©diaire (â­â­) Encapsulation HÃ©ritage Surcharge de mÃ©thodes Static et Final Collections de base Niveau AvancÃ© (â­â­â­) Polymorphisme Classes abstraites Interfaces Exceptions Collections avancÃ©es Enum Niveau Expert (â­â­â­â­) Projets intÃ©grateurs Principes SOLID Composition vs HÃ©ritage Exercices Niveau DÃ©butant â­ Exercice 1.1 â€” Classe Livre Objectifs : Classes, attributs, constructeur basique",
    "tags": [],
    "title": "Exercices - POO",
    "uri": "/420-210/exos_poo/index.html"
  },
  {
    "breadcrumb": "Programmation orientÃ©e objet",
    "content": "ğŸ® PROJET CODEX ARCANUM - Lâ€™AVENTURE COMPLÃˆTE DE LA POO ! ğŸŒŸ Bienvenue dans lâ€™Aventure des BibliothÃ¨ques LÃ©gendaires ! ğŸŒŸ ğŸµ Musique dâ€™Aventure Ã‰pique ğŸµ ğŸµ ThÃ¨me d'aventure Ã©pique\rğŸ§ Active le son pour une expÃ©rience immersive !\rğŸ“Š Ton Tableau de Bord ğŸ® Statistiques du Joueur\rğŸ† Points Totaux : 0\nâ­ Niveau Actuel : 1 - Apprenti Codeur\nğŸ¯ Prochain niveau : 30 points\nğŸ—ºï¸ CARTE COMPLÃˆTE DE Lâ€™AVENTURE ğŸ NIVEAU 1 âš”ï¸ NIVEAU 2 ğŸ° NIVEAU 3 ğŸ”® NIVEAU 4\rPremier Livre Bouclier Magique Royaume Livres Grimoire Dynamique\r[15 pts] [15 pts] [20 pts] [20 pts]\rğŸ‰ NIVEAU 5 ğŸŒˆ NIVEAU 6 ğŸ›ï¸ NIVEAU 7 ğŸ‘‘ NIVEAU 8\rDragon HÃ©ritage MÃ©tamorphose Temple Abstrait Boss Final\r[25 pts] [25 pts] [30 pts] [50 pts]\rTOTAL : 200 POINTS POSSIBLES ! ğŸ¯ SystÃ¨me de progression: â­ Bronze (0-30 pts) : Apprenti Codeur â­â­ Argent (31-60 pts) : Codeur CompÃ©tent â­â­â­ Or (61-100 pts) : MaÃ®tre POO â­â­â­â­ Platine (101-150 pts) : Grand Architecte ğŸ‘‘ LÃ©gende (151+ pts) : LÃ©gende Vivante ! ğŸ›ï¸ Choisis ta bibliothÃ¨que lÃ©gendaire ! ğŸ”® Codex Arcanum\rSortilÃ¨ges de code\nâš”ï¸ Grimoire du Guerrier\rCombat contre bugs\nğŸŒŠ OcÃ©an Connaissance\rAlgorithmes fluides\nğŸ”¥ Forge du Phoenix\rCrÃ©ateurs passionnÃ©s\nğŸ® NIVEAU 1 - LE PREMIER LIVRE MAGIQUE ğŸµ Musique Niveau 1\rğŸ“œ Histoire â€œBienvenue jeune apprenti ! La bibliothÃ¨que est videâ€¦ Ta premiÃ¨re mission : crÃ©er ton premier livre magique qui pourra Ãªtre empruntÃ© !â€\nğŸ’ Points: 15 pts | â±ï¸ Temps estimÃ©: 1-2 heures ğŸ¯ Mission 1.1 : CrÃ©er la classe Livre Attributs Ã  crÃ©er (tous private): Attribut Type Valeur initiale titre String Via constructeur auteur String Via constructeur annee int Via constructeur estEmprunte boolean false ğŸ“ Concept POO : Lâ€™ENCAPSULATION FÃ©licitations ! En dÃ©clarant tes attributs private, tu viens dâ€™appliquer le principe dâ€™ENCAPSULATION !\nCâ€™est quoi lâ€™encapsulation ?\nCacher les dÃ©tails internes dâ€™une classe EmpÃªcher lâ€™accÃ¨s direct aux attributs depuis lâ€™extÃ©rieur private = les attributs sont protÃ©gÃ©s âœ… Pourquoi câ€™est important ?\nProtÃ¨ge les donnÃ©es contre les modifications non contrÃ´lÃ©es On peut changer lâ€™implÃ©mentation interne sans casser le code externe Câ€™est un des 4 piliers de la POO ! Note : Au Niveau 2, tu ajouteras des getters/setters pour permettre un accÃ¨s contrÃ´lÃ© Ã  ces attributs privÃ©s.\nConstructeur: ParamÃ¨tres: String titre, String auteur, int annee Actions: Initialiser titre, auteur, annee avec les paramÃ¨tres Mettre estEmprunte Ã  false Afficher: \"âœ¨ NOUVEAU LIVRE CRÃ‰Ã‰ : \" + titre ğŸ’¡ Aide syntaxe\rpublic class Livre { private Type attribut; public Livre(Type param) { this.attribut = param; } } ğŸ¯ Mission 1.2 : MÃ©thode afficher() Signature: public void afficher()\nActions Ã  faire:\nAfficher une ligne: â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•— Afficher: \" ğŸ“š \" + titre Afficher: \" âœï¸ \" + auteur Afficher: \" ğŸ“… \" + annee SI estEmprunte est vrai: Afficher: \" ğŸ”´ EMPRUNTÃ‰\" SINON: Afficher: \" ğŸŸ¢ DISPONIBLE\" Afficher une ligne: â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ğŸ¯ Mission 1.3 : MÃ©thode emprunter() Signature: public void emprunter()\nLogique:\nSI le livre EST DÃ‰JÃ€ empruntÃ©:\rAfficher \"âŒ Oups ! '[titre]' est dÃ©jÃ  empruntÃ© !\"\rSINON:\rMettre estEmprunte Ã  true\rAfficher \"âœ… Super ! Tu as empruntÃ© '[titre]' !\"\rAfficher \"ğŸ‰ +1 emprunt rÃ©ussi !\" ğŸ¯ Mission 1.4 : MÃ©thode retourner() Signature: public void retourner()\nLogique:\nSI le livre EST empruntÃ©:\rMettre estEmprunte Ã  false\rAfficher \"âœ… Merci ! '[titre]' est de retour !\"\rAfficher \"â­ +1 point de karma !\"\rSINON:\rAfficher \"âš ï¸ Hmm... '[titre]' n'Ã©tait pas empruntÃ© !\" ğŸ§ª Test Niveau 1 CrÃ©e TestNiveau1.java et complÃ¨te:\npublic class TestNiveau1 { public static void main(String[] args) { // ğŸ¯ MISSION : CrÃ©e 3 livres diffÃ©rents Livre livre1 = // TON CODE Livre livre2 = // TON CODE Livre livre3 = // TON CODE // Affiche les 3 livres // Emprunte livre1 // Essaie d'emprunter livre1 Ã  nouveau // Retourne livre1 // Essaie de retourner livre3 (pas empruntÃ©) System.out.println(\"\\nğŸ† NIVEAU 1 TERMINÃ‰ !\"); } } âœ… Checklist: 3 livres crÃ©Ã©s 3 livres affichÃ©s 1 emprunt rÃ©ussi 1 tentative sur livre dÃ©jÃ  empruntÃ© (erreur attendue) 1 retour rÃ©ussi 1 tentative de retour sur livre non empruntÃ© (erreur attendue) ğŸ† DÃ©fis Bonus (+5 pts chacun) DÃ©fi 1.A : Attribut nombrePages Ajoute attribut private int nombrePages Modifie constructeur pour lâ€™accepter Affiche-le dans afficher() CrÃ©e mÃ©thode public boolean isLong() qui retourne true si \u003e 400 pages DÃ©fi 1.B : 5 livres de genres variÃ©s CrÃ©e 5 livres : Fantasy, SF, Romance, Horreur, Classique\nDÃ©fi 1.C : Combo parfait 3 emprunts rÃ©ussis dâ€™affilÃ©e sans erreur\nğŸ”‘ NIVEAU 2 - LES PORTES Dâ€™ACCÃˆS (GETTERS/SETTERS) ğŸµ Musique Niveau 2\rğŸ“œ Histoire â€œTes attributs sont dÃ©jÃ  protÃ©gÃ©s (private = ENCAPSULATION âœ…), mais maintenant on ne peut plus les lire ! CrÃ©e des PORTES Dâ€™ACCÃˆS CONTRÃ”LÃ‰ES (getters/setters) avec des GARDIENS (validations) !â€\nğŸ“ Rappel Important Tu as DÃ‰JÃ€ lâ€™encapsulation depuis le Niveau 1 !\nğŸ†• Maintenant : Ajouter des accesseurs (getters/setters) ğŸ†• Bonus : Ajouter des validations dans les setters ğŸ’ Points: 15 pts | â±ï¸ Temps: 1-2 heures ğŸ¯ Mission 2.1 : Ajouter les Getters ğŸ“ Concept : Les Getters (Accesseurs) ProblÃ¨me actuel :\nTes attributs sont private (encapsulation âœ…) Impossible de les lire depuis lâ€™extÃ©rieur ! livre.titre â†’ ERREUR âŒ Solution : Les Getters\nMÃ©thodes public qui retournent la valeur des attributs privÃ©s Permettent un accÃ¨s en lecture contrÃ´lÃ© Convention : get + nom de lâ€™attribut (ex: getTitre()) Exception pour boolean : on utilise is (ex: isEstEmprunte()) CrÃ©e ces mÃ©thodes dans Livre.java:\nMÃ©thode Retour Action getTitre() String Retourne titre getAuteur() String Retourne auteur getAnnee() int Retourne annee getNombrePages() int Retourne nombrePages isEstEmprunte() boolean Retourne estEmprunte ğŸ’¡ Template getter\rpublic Type getNom() { return attribut; } // Pour boolean: public boolean isNom() { return attributBoolean; } ğŸ¯ Mission 2.2 : Setter setAnnee() avec validation ğŸ“ Concept : Les Setters (Mutateurs) Ã€ quoi servent les setters ?\nPermettent de modifier les attributs privÃ©s depuis lâ€™extÃ©rieur MAIS avec des validations ! Câ€™est Ã§a le pouvoir ! Sans setter (problÃ¨me) :\n// Impossible de modifier, attribut private livre.annee = 2025; // ERREUR âŒ Avec setter simple (pas terrible) :\npublic void setAnnee(int annee) { this.annee = annee; // N'importe quelle valeur acceptÃ©e } // ProblÃ¨me : on pourrait mettre annee = -500 ou 9999 ! Avec setter + VALIDATION (ğŸ† MEILLEUR) :\npublic void setAnnee(int annee) { if (annee \u003e= 1000 \u0026\u0026 annee \u003c= 2024) { this.annee = annee; // Valeur valide âœ… } else { // Refuser la valeur invalide âŒ } } Avantages :\nâœ… ProtÃ¨ge les donnÃ©es (pas de valeurs absurdes) âœ… Attribut reste private âœ… ContrÃ´le total sur les modifications Signature: public void setAnnee(int annee)\nLogique:\nSI annee est entre 1000 ET 2024 (inclus):\rModifier this.annee\rAfficher \"âœ… AnnÃ©e validÃ©e : [annee]\"\rSINON:\rAfficher \"âš ï¸ ALERTE ! AnnÃ©e invalide dÃ©tectÃ©e !\"\rAfficher \"ğŸ›¡ï¸ Bouclier activÃ© ! AnnÃ©e rÃ©initialisÃ©e Ã  2000\"\rMettre this.annee Ã  2000 ğŸ¯ Mission 2.3 : Setter setNombrePages() avec validation Signature: public void setNombrePages(int nombrePages)\nLogique:\nSI nombrePages est entre 1 ET 2000 (inclus):\rModifier this.nombrePages\rAfficher \"âœ… Pages validÃ©es : [nombrePages]\"\rSINON:\rAfficher \"âš ï¸ ALERTE ! Nombre de pages bizarre !\"\rAfficher \"ğŸ›¡ï¸ Bouclier activÃ© ! Pages rÃ©initialisÃ©es Ã  100\"\rMettre this.nombrePages Ã  100 ğŸ¯ Mission 2.4 : SystÃ¨me de PopularitÃ© Nouvel attribut: private int niveauPopularite (initialiser Ã  0 dans constructeur) MÃ©thode ajouterEtoile(): Signature: public void ajouterEtoile()\nLogique:\nSI niveauPopularite \u003c 5:\rAugmenter niveauPopularite de 1\rAfficher \"â­ Nouvelle Ã©toile ! [titre] a [niveauPopularite] Ã©toile(s) !\"\rSINON:\rAfficher \"ğŸŒŸ Maximum atteint ! Ce livre est une LÃ‰GENDE !\" MÃ©thode isPopulaire(): Signature: public boolean isPopulaire() Retourne: true si niveauPopularite \u003e= 4, sinon false\nGetter: Signature: public int getNiveauPopularite()\nğŸ¯ Mission 2.5 : Afficher les Ã©toiles Dans afficher(), aprÃ¨s lâ€™annÃ©e, ajoute:\nSystem.out.print(\" â­ \"); for (int i = 0; i \u003c niveauPopularite; i++) { System.out.print(\"â˜…\"); } for (int i = niveauPopularite; i \u003c 5; i++) { System.out.print(\"â˜†\"); } System.out.println(); ğŸ¯ Mission 2.6 : MÃ©thode calculerAge() Signature: public int calculerAge()\nLogique:\nage = 2024 - annee\rSI age \u003e 50:\rAfficher \"ğŸ“œ Livre ANCIEN ! [age] ans !\"\rRetourner age ğŸ§ª Test Niveau 2 public class TestNiveau2 { public static void main(String[] args) { Livre livre = new Livre(\"1984\", \"Orwell\", 1949, 328); // Teste setAnnee avec valeur valide // Teste setAnnee avec 3000 (invalide) // Teste setNombrePages avec 350 // Teste setNombrePages avec -50 (invalide) // Ajoute 4 Ã©toiles // Affiche si populaire // Calcule et affiche l'Ã¢ge // Affiche le livre complet } } ğŸ† DÃ©fis Bonus DÃ©fi 2.A : isClassique() MÃ©thode qui retourne true si livre a plus de 30 ans\nDÃ©fi 2.B : Compteur dâ€™erreurs Attribut qui compte les validations Ã©chouÃ©es\nDÃ©fi 2.C : Livre 5 Ã©toiles Monte un livre Ã  5 Ã©toiles et vois le message spÃ©cial\nğŸ° NIVEAU 3 - LE ROYAUME DES LIVRES (TABLEAUX) ğŸµ Musique Niveau 3\rğŸ“œ Histoire â€œTes livres sont Ã©parpillÃ©s ! Construis un ROYAUME (Bibliotheque) pour les organiser dans un tableau !â€\nğŸ’ Points: 20 pts | â±ï¸ Temps: 2-3 heures ğŸ¯ Mission 3.1 : CrÃ©er la classe Bibliotheque Fichier: Bibliotheque.java\nAttributs (tous private): Attribut Type Description nom String Nom de la bibliothÃ¨que livres Livre[] Tableau de livres nombreLivres int Nombre de livres actuellement ajoutÃ©s pointsGloire int Points du joueur Constructeur: ParamÃ¨tres: String nom, int capacite\nActions:\nInitialiser this.nom = nom CrÃ©er le tableau: this.livres = new Livre[capacite] Initialiser nombreLivres = 0 Initialiser pointsGloire = 0 Afficher message de bienvenue: ğŸ°â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ğŸ°\rLE ROYAUME DE [NOM] EST NÃ‰ !\rCapacitÃ© : [capacite] livres\rğŸ°â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ğŸ° ğŸ¯ Mission 3.2 : MÃ©thode ajouterLivre() Signature: public void ajouterLivre(Livre livre)\nLogique:\nSI nombreLivres \u003c livres.length:\rlivres[nombreLivres] = livre\rnombreLivres++\rpointsGloire += 10\rAfficher \"âœ¨ [titre du livre] a rejoint le royaume !\"\rAfficher \"ğŸ† +10 points de gloire ! Total : [pointsGloire]\"\rSI nombreLivres == 5:\rAfficher \"ğŸ‰ ACHIEVEMENT : 'Collectionneur' !\"\rSI nombreLivres == 10:\rAfficher \"ğŸŠ ACHIEVEMENT : 'Grande BibliothÃ¨que' !\"\rSINON:\rAfficher \"ğŸ’¥ OH NON ! Le royaume est PLEIN !\"\rAfficher \"ğŸ—ï¸ Conseil : Agrandis ton royaume !\" ğŸ’¡ Aide: AccÃ©der au titre du livre\rString titre = livre.getTitre(); ğŸ¯ Mission 3.3 : MÃ©thode afficherCarte() Signature: public void afficherCarte()\nActions:\nAfficher le titre: â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\râ•‘ ğŸ—ºï¸ CARTE DU ROYAUME : [NOM]\râ•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• Afficher: \"ğŸ“Š Livres : \" + nombreLivres + \"/\" + livres.length\nAfficher: \"ğŸ† Gloire : \" + pointsGloire + \" points\"\nLigne vide\nSI nombreLivres == 0:\nAfficher: \"ğŸœï¸ Le royaume est vide... Ajoute des livres !\" SINON:\nBoucle for de i=0 Ã  i \u003c nombreLivres: CrÃ©er variable: statut = livres[i].isEstEmprunte() ? \"ğŸ”´\" : \"ğŸŸ¢\"\rAfficher: \"[i+1]. [statut] [titre] - [auteur]\" Ligne vide\nğŸ’¡ Template boucle\rfor (int i = 0; i \u003c nombreLivres; i++) { Livre livre = livres[i]; String statut = livre.isEstEmprunte() ? \"ğŸ”´\" : \"ğŸŸ¢\"; System.out.println((i+1) + \". \" + statut + \" \" + livre.getTitre() + \" - \" + livre.getAuteur()); } ğŸ¯ Mission 3.4 : MÃ©thode afficherDisponibles() Signature: public void afficherDisponibles()\nLogique:\nAfficher \"ğŸ’ â•â•â• TRÃ‰SORS DISPONIBLES â•â•â• ğŸ’\"\raucun = true\rPour chaque livre de 0 Ã  nombreLivres:\rSI livre n'est PAS empruntÃ©:\rAfficher \" âœ¨ [titre]\"\raucun = false\rSI aucun est restÃ© true:\rAfficher \" ğŸ˜± Tous les trÃ©sors sont empruntÃ©s !\"\rLigne vide ğŸ¯ Mission 3.5 : MÃ©thode chercherLivre() Signature: public Livre chercherLivre(String titre)\nLogique:\nAfficher \"ğŸ” Recherche de '[titre]'...\"\rPour i de 0 Ã  nombreLivres:\rSI livres[i].getTitre().equalsIgnoreCase(titre):\rAfficher \"âœ… TROUVÃ‰ ! Position : [i+1]\"\rRetourner livres[i]\rAfficher \"âŒ TrÃ©sor introuvable...\"\rRetourner null ğŸ¯ Mission 3.6 : MÃ©thode emprunterLivre() Signature: public void emprunterLivre(String titre)\nLogique:\nAfficher \"ğŸ® â•â•â• MISSION D'EMPRUNT â•â•â•\"\rlivre = chercherLivre(titre)\rSI livre != null:\rAppeler livre.emprunter()\rSI livre.isEstEmprunte() est true:\rpointsGloire += 15\rAfficher \"ğŸ‰ +15 points ! Total : [pointsGloire]\"\rSINON:\rpointsGloire -= 5\rAfficher \"ğŸ˜¢ -5 points...\" ğŸ¯ Mission 3.7 : Getter Signature: public int getPointsGloire() Retourne: pointsGloire\nğŸ§ª Test Niveau 3 public class TestNiveau3 { public static void main(String[] args) { // CrÃ©e une bibliothÃ¨que (choisis un nom Ã©pique!) Bibliotheque biblio = new Bibliotheque(\"Codex Arcanum\", 10); // Ajoute 5 livres minimum // Affiche la carte // Emprunte 3 livres // Affiche les disponibles // Affiche les points System.out.println(\"Points: \" + biblio.getPointsGloire()); } } ğŸ† DÃ©fis Bonus DÃ©fi 3.A : 100 points de gloire Optimise pour atteindre 100 points !\nDÃ©fi 3.B : Royaume complet Remplis les 10 emplacements\nDÃ©fi 3.C : Combo 5 5 emprunts sans erreur dâ€™affilÃ©e\nğŸ”® NIVEAU 4 - LE GRIMOIRE DYNAMIQUE (ARRAYLIST) ğŸ“œ Histoire â€œUn sorcier tâ€™offre le GRIMOIRE DYNAMIQUE - un tableau INFINI ! Plus de limite de capacitÃ© !â€\nğŸ’ Points: 20 pts | â±ï¸ Temps: 2 heures ğŸ¯ Mission 4.1 : Convertir en ArrayList Modifications dans Bibliotheque.java: Ã‰tape 1: Ajoute en haut du fichier:\nimport java.util.ArrayList; Ã‰tape 2: Change les attributs:\nâŒ EnlÃ¨ve: private Livre[] livres; âŒ EnlÃ¨ve: private int nombreLivres; âœ… Ajoute: private ArrayList\u003cLivre\u003e livres; Ã‰tape 3: Modifie le constructeur:\nParamÃ¨tres: Seulement String nom (plus de capacitÃ©!) Initialisation: this.livres = new ArrayList\u003cLivre\u003e(); Message: Change â€œCapacitÃ©: â€¦â€ pour â€œâœ¨ CapacitÃ© : ILLIMITÃ‰E ! âœ¨â€ ğŸ¯ Mission 4.2 : Adapter ajouterLivre() Nouvelle logique:\nlivres.add(livre) // Plus besoin de vÃ©rifier la capacitÃ©!\rpointsGloire += 10\rAfficher \"âœ¨ [titre] invoquÃ© dans le grimoire !\"\rAfficher \"ğŸ† +10 points ! Total : [pointsGloire]\"\rSI livres.size() == 5:\rAfficher \"ğŸ‰ ACHIEVEMENT : 'Collectionneur' !\"\rSI livres.size() == 15:\rAfficher \"ğŸŠ MEGA ACHIEVEMENT : 'BibliothÃ¨que LÃ©gendaire' !\"\rpointsGloire += 50 ğŸ¯ Mission 4.3 : Adapter afficherCarte() Changements:\nRemplace nombreLivres par livres.size() Remplace livres.length par â€œâˆâ€ Boucle: for (int i = 0; i \u003c livres.size(); i++) AccÃ¨s: Livre livre = livres.get(i); Ou utilise for-each:\nint compteur = 1; for (Livre livre : livres) { // Afficher avec compteur++ } ğŸ¯ Mission 4.4 : Adapter afficherDisponibles() Changements:\nUtilise for (Livre livre : livres) au lieu de boucle avec index ğŸ¯ Mission 4.5 : Adapter chercherLivre() Nouvelle version avec for-each:\nfor (Livre livre : livres) { if (livre.getTitre().equalsIgnoreCase(titre)) { System.out.println(\"âœ… TROUVÃ‰ !\"); return livre; } } System.out.println(\"âŒ Introuvable...\"); return null; ğŸ¯ Mission 4.6 : NOUVELLE MÃ©thode supprimerLivre() Signature: public void supprimerLivre(String titre)\nLogique:\nlivre = chercherLivre(titre)\rSI livre != null:\rlivres.remove(livre)\rAfficher \"ğŸ’¨ [titre] a Ã©tÃ© banni du grimoire !\"\rAfficher \"ğŸ“Š Livres restants : [livres.size()]\" ğŸ¯ Mission 4.7 : NOUVELLE MÃ©thode rechercherParAuteur() Signature: public void rechercherParAuteur(String auteur)\nLogique:\nAfficher \"ğŸ¯ â•â•â• QUÃŠTE : Livres de [auteur] â•â•â•\"\rtrouve = false\rcompte = 0\rPour chaque livre dans livres:\rSI livre.getAuteur().equalsIgnoreCase(auteur):\rAfficher \" âœ¨ [titre] ([annÃ©e])\"\rtrouve = true\rcompte++\rSI trouve:\rpointsGloire += (compte * 5)\rAfficher \"ğŸ‰ QuÃªte rÃ©ussie ! [compte] livre(s) trouvÃ©(s) !\"\rAfficher \"ğŸ† +[compte*5] points !\"\rSINON:\rAfficher \"ğŸ˜¢ QuÃªte Ã©chouÃ©e...\" ğŸ§ª Test Niveau 4 public class TestNiveau4 { public static void main(String[] args) { // CrÃ©e bibliothÃ¨que SANS limite ! Bibliotheque grimoire = new Bibliotheque(\"Le Grimoire Infini\"); // Ajoute 7+ livres (teste l'illimitÃ©!) // Recherche par auteur // Supprime un livre // Affiche la carte finale } } ğŸ‰ NIVEAU 5 - LE DRAGON DE Lâ€™HÃ‰RITAGE ğŸ“œ Histoire â€œLa bibliothÃ¨que a des DVDs, Magazines ! Utilise lâ€™HÃ‰RITAGE pour crÃ©er diffÃ©rents types de documents !â€\nğŸ’ Points: 25 pts | â±ï¸ Temps: 3 heures ğŸ¯ Mission 5.1 : CrÃ©er la classe parent Document Fichier: Document.java\nAttributs (tous private): String titre int annee boolean estEmprunte Constructeur: ParamÃ¨tres: String titre, int annee Actions: Initialiser les 3 attributs (estEmprunte Ã  false)\nMÃ©thodes Ã  crÃ©er: Getters: public String getTitre() public int getAnnee() public boolean isEstEmprunte() emprunter(): SI estEmprunte:\rAfficher \"âŒ '[titre]' dÃ©jÃ  empruntÃ© !\"\rSINON:\restEmprunte = true\rAfficher \"âœ… '[titre]' empruntÃ© !\" retourner(): SI estEmprunte:\restEmprunte = false\rAfficher \"âœ… '[titre]' retournÃ© !\"\rSINON:\rAfficher \"âš ï¸ '[titre]' pas empruntÃ©.\" afficher(): Afficher \"Titre: [titre]\"\rAfficher \"AnnÃ©e: [annee]\"\rSI estEmprunte:\rAfficher \"Statut: EmpruntÃ©\"\rSINON:\rAfficher \"Statut: Disponible\" ğŸ¯ Mission 5.2 : CrÃ©er Livre qui hÃ©rite de Document Fichier: Modifier Livre.java\nChangement de dÃ©claration:\npublic class Livre extends Document { // ... } Nouveaux attributs privÃ©s (en plus de ceux hÃ©ritÃ©s): String auteur int nombrePages Nouveau constructeur: public Livre(String titre, String auteur, int annee, int nombrePages) { super(titre, annee); // Appelle constructeur parent this.auteur = auteur; this.nombrePages = nombrePages; } Getters spÃ©cifiques: public String getAuteur() public int getNombrePages() MÃ©thode spÃ©cifique: public boolean isLong() { return nombrePages \u003e 400; } RedÃ©finir afficher(): @Override public void afficher() { super.afficher(); // Appelle version parent System.out.println(\"Auteur: \" + auteur); System.out.println(\"Pages: \" + nombrePages); } ğŸ¯ Mission 5.3 : CrÃ©er la classe Magazine Fichier: Magazine.java\nDÃ©claration: public class Magazine extends Document\nAttributs privÃ©s: int numero String mois Constructeur: ParamÃ¨tres: String titre, int annee, int numero, String mois Action:\nsuper(titre, annee); this.numero = numero; this.mois = mois; Getters: public int getNumero() public String getMois() RedÃ©finir afficher(): @Override public void afficher() { super.afficher(); System.out.println(\"NumÃ©ro: \" + numero); System.out.println(\"Mois: \" + mois); } RedÃ©finir emprunter(): @Override public void emprunter() { super.emprunter(); if (isEstEmprunte()) { System.out.println(\"ğŸ“° Ã€ retourner dans 7 jours !\"); } } ğŸ¯ Mission 5.4 : CrÃ©er la classe DVD Fichier: DVD.java\nDÃ©claration: public class DVD extends Document\nAttributs privÃ©s: String realisateur int dureeMinutes Constructeur: ParamÃ¨tres: String titre, int annee, String realisateur, int dureeMinutes\nGetters: public String getRealisateur() public int getDureeMinutes() MÃ©thode spÃ©ciale getDureeFormatee(): Signature: public String getDureeFormatee() Logique:\nheures = dureeMinutes / 60\rminutes = dureeMinutes % 60\rRetourner heures + \"h\" + minutes RedÃ©finir afficher(): Appelle parent puis affiche rÃ©alisateur et durÃ©e formatÃ©e\nğŸ§ª Test Niveau 5 public class TestNiveau5 { public static void main(String[] args) { // CrÃ©e 1 livre Livre livre = new Livre(\"Dune\", \"Herbert\", 1965, 688); // CrÃ©e 1 magazine Magazine mag = new Magazine(\"Wired\", 2024, 345, \"Mars\"); // CrÃ©e 1 DVD DVD dvd = new DVD(\"Matrix\", 1999, \"Wachowski\", 136); // Affiche les 3 // Emprunte les 3 (observe les messages diffÃ©rents!) // Teste isLong() sur le livre // Teste getDureeFormatee() sur le DVD } } ğŸ† DÃ©fis Bonus DÃ©fi 5.A : Classe BD CrÃ©e BD extends Livre avec attribut dessinateur\nDÃ©fi 5.B : Classe CD CrÃ©e CD extends Document avec artiste et nombrePistes\nğŸŒˆ NIVEAU 6 - LA MÃ‰TAMORPHOSE (POLYMORPHISME) ğŸ“œ Histoire â€œModifie Bibliotheque pour gÃ©rer TOUS les types de documents avec polymorphisme !â€\nğŸ’ Points: 25 pts | â±ï¸ Temps: 2-3 heures ğŸ¯ Mission 6.1 : Modifier Bibliotheque Dans Bibliotheque.java:\nChangement dâ€™attribut:\nâŒ EnlÃ¨ve: private ArrayList\u003cLivre\u003e livres; âœ… Ajoute: private ArrayList\u003cDocument\u003e documents; Dans le constructeur:\nthis.documents = new ArrayList\u003cDocument\u003e(); ğŸ¯ Mission 6.2 : Renommer et adapter ajouterDocument() Anciennement ajouterLivre()\nNouvelle signature: public void ajouterDocument(Document doc)\nLogique:\ndocuments.add(doc)\rpointsGloire += 10\rAfficher \"â• '[doc.getTitre()]' ajoutÃ© !\"\rAfficher \"ğŸ† +10 points ! Total : [pointsGloire]\" ğŸ¯ Mission 6.3 : Adapter afficherCatalogue() Anciennement afficherCarte()\nLogique:\nAfficher titre catalogue\rPour i de 0 Ã  documents.size():\rdoc = documents.get(i)\rCrÃ©er variable type:\rSI doc instanceof Livre:\rtype = \"[LIVRE]\"\rSINON SI doc instanceof Magazine:\rtype = \"[MAGAZINE]\"\rSINON SI doc instanceof DVD:\rtype = \"[DVD]\"\rSINON:\rtype = \"[DOCUMENT]\"\rAfficher \"[i+1]. [type] [titre]\" ğŸ’¡ Aide instanceof\rif (doc instanceof Livre) { // C'est un livre } else if (doc instanceof Magazine) { // C'est un magazine } ğŸ¯ Mission 6.4 : MÃ©thode afficherLivres() Signature: public void afficherLivres()\nLogique:\nAfficher \"ğŸ“š â•â•â• LIVRES â•â•â•\"\rPour chaque doc dans documents:\rSI doc instanceof Livre:\rCaster: Livre livre = (Livre) doc\rAfficher \"- [titre] par [auteur]\" ğŸ’¡ Aide casting\rif (doc instanceof Livre) { Livre livre = (Livre) doc; // Maintenant on peut utiliser livre.getAuteur() } ğŸ¯ Mission 6.5 : MÃ©thode afficherMagazines() Signature: public void afficherMagazines()\nLogique similaire Ã  afficherLivres() mais pour Magazine\nğŸ¯ Mission 6.6 : MÃ©thode afficherStatistiques() Signature: public void afficherStatistiques()\nLogique:\nnbLivres = 0\rnbMagazines = 0\rnbDVDs = 0\rPour chaque doc dans documents:\rSI doc instanceof Livre: nbLivres++\rSINON SI doc instanceof Magazine: nbMagazines++\rSINON SI doc instanceof DVD: nbDVDs++\rAfficher les totaux ğŸ¯ Mission 6.7 : Adapter emprunterDocument() Changements:\nRemplace livres par documents Cherche dans documents au lieu de livres ğŸ§ª Test Niveau 6 public class TestNiveau6 { public static void main(String[] args) { Bibliotheque biblio = new Bibliotheque(\"Le Nexus Polymorphe\"); // Ajoute 2 livres, 2 magazines, 2 DVDs // Affiche le catalogue complet // Affiche seulement les livres // Affiche seulement les magazines // Affiche les statistiques } } ğŸ›ï¸ NIVEAU 7 - LE TEMPLE ABSTRAIT ğŸ“œ Histoire â€œCrÃ©e des rÃ¨gles STRICTES que tous les documents DOIVENT suivre avec classes abstraites et interfaces !â€\nğŸ’ Points: 30 pts | â±ï¸ Temps: 3-4 heures ğŸ¯ Mission 7.1 : CrÃ©er DocumentAbstrait Fichier: DocumentAbstrait.java\nDÃ©claration: public abstract class DocumentAbstrait\nAttributs privÃ©s: String titre int annee boolean estEmprunte Constructeur (normal): Comme Document du niveau 5\nMÃ©thodes ABSTRAITES Ã  dÃ©clarer: public abstract void afficher(); public abstract int getDureeEmprunt(); public abstract String getIcone(); ğŸ’¡ Syntaxe mÃ©thode abstraite\rpublic abstract Type nomMethode(parametres); // Pas de { }, juste un ; MÃ©thodes CONCRÃˆTES: emprunter(): Comme avant mais utilise getDureeEmprunt():\nSystem.out.println(\"EmpruntÃ© pour \" + getDureeEmprunt() + \" jours !\"); retourner(): Comme avant\nGetters: Comme avant\nğŸ¯ Mission 7.2 : CrÃ©er lâ€™interface Evaluable Fichier: Evaluable.java\nDÃ©claration: public interface Evaluable\nMÃ©thodes Ã  dÃ©clarer:\nvoid attribuerNote(int note); int getNote(); void afficherEvaluation(); ğŸ’¡ Syntaxe interface\rpublic interface NomInterface { void methode1(); Type methode2(); // Toutes les mÃ©thodes sont automatiquement public abstract } ğŸ¯ Mission 7.3 : CrÃ©er LivreComplet Fichier: LivreComplet.java\nDÃ©claration: public class LivreComplet extends DocumentAbstrait implements Evaluable\nAttributs privÃ©s: String auteur int nombrePages int note Constructeur: public LivreComplet(String titre, String auteur, int annee, int nombrePages) { super(titre, annee); this.auteur = auteur; this.nombrePages = nombrePages; this.note = 0; } ImplÃ©menter mÃ©thodes abstraites: getDureeEmprunt(): @Override public int getDureeEmprunt() { return 21; // 3 semaines } getIcone(): @Override public String getIcone() { return \"ğŸ“š\"; } afficher(): @Override public void afficher() { System.out.println(\"=== LIVRE ===\"); System.out.println(\"Titre: \" + getTitre()); System.out.println(\"Auteur: \" + auteur); // etc. } ImplÃ©menter interface Evaluable: attribuerNote(int note): SI note entre 0 et 5:\rthis.note = note\rAfficher \"Note de [note]/5 attribuÃ©e\"\rSINON:\rAfficher \"Note invalide !\" getNote(): Retourne note\nafficherEvaluation(): Afficher \"Ã‰valuation: \"\rPour i de 0 Ã  note:\rAfficher \"â˜…\"\rPour i de note Ã  5:\rAfficher \"â˜†\"\rAfficher \" ([note]/5)\" ğŸ¯ Mission 7.4 : CrÃ©er MagazineComplet Fichier: MagazineComplet.java\nDÃ©claration: public class MagazineComplet extends DocumentAbstrait\nAttributs: int numero String mois ImplÃ©menter: getDureeEmprunt() â†’ retourne 7 getIcone() â†’ retourne â€œğŸ“°â€ afficher() â†’ affiche infos magazine ğŸ¯ Mission 7.5 : CrÃ©er DVDComplet Fichier: DVDComplet.java\nDÃ©claration: public class DVDComplet extends DocumentAbstrait implements Evaluable\nAttributs: String realisateur int dureeMinutes int note ImplÃ©menter: Toutes les mÃ©thodes abstraites Interface Evaluable getDureeEmprunt() â†’ retourne 14 ğŸ§ª Test Niveau 7 public class TestNiveau7 { public static void main(String[] args) { // Essaie de crÃ©er DocumentAbstrait directement // DocumentAbstrait doc = new DocumentAbstrait(...); // ERREUR! // CrÃ©e LivreComplet LivreComplet livre = new LivreComplet(\"Dune\", \"Herbert\", 1965, 688); // Affiche // Emprunte (vois le message avec durÃ©e!) // Attribue note // Affiche Ã©valuation // CrÃ©e MagazineComplet (pas Evaluable!) // CrÃ©e DVDComplet (Evaluable!) } } ğŸ‘‘ NIVEAU 8 - LE BOSS FINAL (PROJET COMPLET) ğŸ“œ Histoire â€œCâ€™est lâ€™heure de lâ€™Ã©preuve ultime ! CrÃ©e un systÃ¨me COMPLET de gestion avec TOUTES les fonctionnalitÃ©s !â€\nğŸ’ Points: 50 pts | â±ï¸ Temps: 8-12 heures ğŸ¯ FonctionnalitÃ©s Ã  implÃ©menter Partie A : Classe Membre (10 pts) Fichier: Membre.java\nAttributs:\nString nom, prenom String numeroMembre ArrayList\u003cDocumentAbstrait\u003e documentsEmpruntes double fraisAccumules MÃ©thodes Ã  crÃ©er:\najouterEmprunt(DocumentAbstrait doc) - limite 5 emprunts retirerEmprunt(DocumentAbstrait doc) ajouterFrais(double montant) payerFrais(double montant) afficherEmprunts() Partie B : Menu Interactif (15 pts) Fichier: MenuPrincipal.java\nCrÃ©e un menu avec Scanner qui permet:\nâ•â•â• MENU PRINCIPAL â•â•â•\r1. Ajouter un document\r2. Afficher catalogue\r3. Emprunter document\r4. Retourner document\r5. Inscrire membre\r6. Rechercher\r7. Statistiques\r0. Quitter Instructions dÃ©taillÃ©es:\nUtilise Scanner scanner = new Scanner(System.in); Boucle while qui continue jusquâ€™Ã  choix 0 switch/case pour chaque option Gestion dâ€™erreurs avec try/catch Partie C : SystÃ¨me de Recherche (10 pts) MÃ©thodes Ã  ajouter dans Bibliotheque:\nrechercherParMotCle(String motCle): Cherche dans titre ET auteur (pour les livres)\nafficherDocumentsParAnnee(int anneeDebut, int anneeFin): Filtre par plage dâ€™annÃ©es\nPartie D : Statistiques AvancÃ©es (10 pts) MÃ©thodes:\ndocumentsLesPlusEmpruntes() - top 5 membresLesPlusActifs() - top 3 calculerRevenus() - total des frais Partie E : Sauvegarde/Chargement (5 pts - BONUS) Avec PrintWriter et Scanner:\nSauvegarde les documents dans fichier texte Recharge au dÃ©marrage ğŸ“ Grille dâ€™Ã‰valuation Finale Concepts POO (40 pts): Classes bien conÃ§ues (5 pts) Encapsulation (5 pts) HÃ©ritage (5 pts) Polymorphisme (5 pts) Classes abstraites (5 pts) Interfaces (5 pts) ArrayList (5 pts) Organisation (5 pts) FonctionnalitÃ©s (35 pts): Gestion documents (10 pts) Gestion membres (10 pts) Menu interactif (10 pts) Recherche (5 pts) QualitÃ© (25 pts): Code commentÃ© (10 pts) Nommage (5 pts) Gestion erreurs (5 pts) Tests (5 pts) ğŸŠ FÃ‰LICITATIONS ! Si tu es arrivÃ© ici, tu es maintenant un MAÃTRE DE LA POO ! ğŸ‰ğŸ‘‘\nTu maÃ®trises: âœ… Classes et objets âœ… Encapsulation âœ… Tableaux et ArrayList âœ… HÃ©ritage âœ… Polymorphisme âœ… Classes abstraites âœ… Interfaces âœ… Composition\nTu es prÃªt pour nâ€™importe quel projet Java ! ğŸš€\nğŸµ Playlist ComplÃ¨te ğŸ§ Musiques dâ€™Aventure ğŸ® Aventure Principale - Pour coder âš”ï¸ Combat Bugs - Pour dÃ©bugger ğŸ° Exploration - Pour lire du code ğŸŠ Victoire - Pour les tests rÃ©ussis âœ¨ Magie POO - Pour refactorer ğŸš€ Boss Final - Pour le projet final",
    "description": "ğŸ® PROJET CODEX ARCANUM - Lâ€™AVENTURE COMPLÃˆTE DE LA POO ! ğŸŒŸ Bienvenue dans lâ€™Aventure des BibliothÃ¨ques LÃ©gendaires ! ğŸŒŸ ğŸµ Musique dâ€™Aventure Ã‰pique ğŸµ ğŸµ ThÃ¨me d'aventure Ã©pique\rğŸ§ Active le son pour une expÃ©rience immersive !",
    "tags": [],
    "title": "BiblioAventure",
    "uri": "/420-210/biblioGame/index.html"
  },
  {
    "breadcrumb": "Programmation orientÃ©e objet",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Categories",
    "uri": "/420-210/categories/index.html"
  },
  {
    "breadcrumb": "",
    "content": "Plans de cours ğŸ“‹ Samuel FostinÃ© : Plan de cours\nHoraire et disponibilitÃ©s des enseignants âœ”ï¸ Samuel FostinÃ© : Lien vers mon horaire et mes disponibilitÃ©s\nSamuel FostinÃ© Nom de lâ€™Ã©valuation PondÃ©ration Semaine de lâ€™Ã©valuation 10 quiz (Wooclap) (Les 8 meilleures quiz) 10 % Semaine 2 Ã  14 Examen 1 15% Semaine 5 Examen 2 20 % Semaine 11 Laboratoire 10 % Semaine 8 Projet remise final 15 % Semaine 14 Examen final 30 % Semaine 15",
    "description": "Plans de cours ğŸ“‹ Samuel FostinÃ© : Plan de cours\nHoraire et disponibilitÃ©s des enseignants âœ”ï¸ Samuel FostinÃ© : Lien vers mon horaire et mes disponibilitÃ©s\nSamuel FostinÃ© Nom de lâ€™Ã©valuation PondÃ©ration Semaine de lâ€™Ã©valuation 10 quiz (Wooclap) (Les 8 meilleures quiz) 10 % Semaine 2 Ã  14 Examen 1 15% Semaine 5 Examen 2 20 % Semaine 11 Laboratoire 10 % Semaine 8 Projet remise final 15 % Semaine 14 Examen final 30 % Semaine 15",
    "tags": [],
    "title": "Programmation orientÃ©e objet",
    "uri": "/420-210/index.html"
  },
  {
    "breadcrumb": "Programmation orientÃ©e objet",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tags",
    "uri": "/420-210/tags/index.html"
  }
]
