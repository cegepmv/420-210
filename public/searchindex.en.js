var relearn_searchindex = [
  {
    "breadcrumb": "Programmation orientÃ©e objet",
    "content": "1. Quâ€™est-ce que Java ? Java est Ã  la fois un langage de programmation orientÃ© objet et une plateforme informatique. Sa philosophie principale est le WORA (Write Once, Run Anywhere) : Ã©crivez votre code une fois, et exÃ©cutez-le nâ€™importe oÃ¹ sans modification.\nLes trois piliers de Java : JDK, JRE et JVM Pour comprendre comment Java fonctionne, il faut distinguer ces trois composants essentiels :\nJDK (Java Development Kit) : Câ€™est la boÃ®te Ã  outils complÃ¨te pour le dÃ©veloppeur. Elle contient le compilateur (javac), les bibliothÃ¨ques de base et le JRE. JRE (Java Runtime Environment) : Câ€™est lâ€™environnement nÃ©cessaire pour exÃ©cuter un programme Java. Il contient les bibliothÃ¨ques de classes et la JVM. JVM (Java Virtual Machine) : Câ€™est le cÅ“ur du systÃ¨me. Elle interprÃ¨te le â€œBytecodeâ€ pour que lâ€™ordinateur puisse le comprendre. ğŸ”— Ressource complÃ©mentaire : Java : Les fondamentaux expliquÃ©s (JDK, JRE et JVM)\n2. CaractÃ©ristiques principales du langage OrientÃ© Objet (POO) : Tout est considÃ©rÃ© comme un â€œobjetâ€ (une entitÃ© avec des caractÃ©ristiques et des comportements). Gestion automatique de la mÃ©moire : GrÃ¢ce au Garbage Collector (Ramasse-miettes), Java libÃ¨re automatiquement la mÃ©moire inutilisÃ©e. SÃ©curitÃ© : ConÃ§u pour les environnements rÃ©seaux, il possÃ¨de des barriÃ¨res strictes contre les accÃ¨s mÃ©moire non autorisÃ©s. Multi-thread : Java permet dâ€™exÃ©cuter plusieurs parties dâ€™un programme simultanÃ©ment. 3. Installation, compilation et exÃ©cution Installation Vous devez installer un JDK (comme OpenJDK ou Oracle JDK). VÃ©rifiez lâ€™installation avec la commande : java -version\nCompilation et exÃ©cution dâ€™un programme Java Dâ€™abord, tu dois tâ€™assurer que Java est bien installÃ© sur ton ordinateur\nOuvre une invite de commandes (cmd) sous Windows (Terminal sous Mac/Linux). Tape la commande java -version. Cette commande devrait vous dire la version de Java qui est installÃ© sur votre ordinateur. Tape aussi la commande javac -version. Cette commande devrait te dire la version du compilateur de Java installÃ© sur ton ordinateur Note: Ces commandes fonctionnent seulement si Java et le compilateur de Java sont installÃ©s et que le chemin oÃ¹ le rÃ©pertoire de Java se trouve est mis dans le PATH des variables dâ€™environnement (Ã€ expliquer en classe pour que ce soit plus clair) ExÃ©cution du code dans le fichier Main.java Ouvre une invite de commandes (cmd) sous Windows (Terminal sous Mac/Linux). Navigue vers le dossier oÃ¹ se trouve votre fichier .java ExÃ©cute la commande java Main.java. Traditionnellement, Java fonctionne en deux Ã©tapes :\nCompilation : Le code source (.java) est transformÃ© en bytecode (.class) grÃ¢ce Ã  la commande :\njavac Main.java ExÃ©cution : Le bytecode est ensuite exÃ©cutÃ© avec la commande :\njava Main ğŸ’¡ Astuce : Depuis une version relativement rÃ©cente de Java, il est aussi possible dâ€™exÃ©cuter directement un fichier .java sans passer explicitement par lâ€™Ã©tape de compilation (javac).\njava Main.java Cela permet dâ€™exÃ©cuter rapidement un programme, mais Ã  noter :\nLe fichier .class est gÃ©nÃ©rÃ© temporairement. Il est ensuite supprimÃ© automatiquement aprÃ¨s lâ€™exÃ©cution. ğŸ“ Cette mÃ©thode est pratique pour tester du code rapidement, mais dans un projet structurÃ©, on utilise gÃ©nÃ©ralement javac suivi de java.\nCompilation et exÃ©cution sans le PATH configurÃ© Si vous recevez lâ€™erreur : 'javac' n'est pas reconnu en tant que commande interne..., cela signifie que votre systÃ¨me ne sait pas oÃ¹ se trouve le dossier bin du JDK. Vous devez alors utiliser le chemin absolu.\nCompiler le fichier: Il faut appeler lâ€™exÃ©cutable javac directement. Sur Windows : \"C:\\Program Files\\Java\\jdk-21\\bin\\javac\" Main.java Sur macOS / Linux : /usr/lib/jvm/jdk-21/bin/javac Main.java RÃ©sultat : Un fichier Main.class apparaÃ®t dans votre dossier.\nExÃ©cuter le programme : Il faut appeler lâ€™exÃ©cutable java (la JVM). Sur Windows : \"C:\\Program Files\\Java\\jdk-21\\bin\\java\" Main Sur macOS / Linux : /usr/lib/jvm/jdk-21/bin/java Main RÃ©soudre lâ€™erreur de Classpath (-cp) Câ€™est lâ€™erreur la plus frustrante pour les dÃ©butants : Could not find or load main class. Cela arrive quand la JVM ne sait pas oÃ¹ chercher vos fichiers .class.\nLâ€™option -cp (ou -classpath) Cette option force Java Ã  regarder dans des rÃ©pertoires prÃ©cis.\nChercher dans le dossier actuel (.) : java -cp . Main Chercher dans un dossier spÃ©cifique (ex: bin) : java -cp bin Main Chercher dans plusieurs dossiers ou JARs : Windows : java -cp \".;lib/mysql.jar\" Main (sÃ©parateur ;) Linux/Mac : java -cp .:lib/mysql.jar Main (sÃ©parateur :) 4. Les outils de dÃ©veloppement (IDE) Bien que vous puissiez Ã©crire du Java dans un simple bloc-notes, les dÃ©veloppeurs utilisent des IDE (Environnements de DÃ©veloppement IntÃ©grÃ©s) pour Ãªtre plus efficaces. Ces logiciels regroupent lâ€™Ã©dition de code, la compilation automatique et le dÃ©bogage.\nIDE Points forts IntelliJ IDEA DÃ©veloppÃ© par JetBrains. Câ€™est le plus moderne et le plus intelligent (recommandÃ© pour la productivitÃ©). Eclipse Historique, entiÃ¨rement gratuit et open-source. TrÃ¨s utilisÃ© dans les grandes entreprises. VS Code TrÃ¨s lÃ©ger et polyvalent. NÃ©cessite lâ€™installation du â€œJava Extension Packâ€ pour fonctionner.",
    "description": "1. Quâ€™est-ce que Java ? Java est Ã  la fois un langage de programmation orientÃ© objet et une plateforme informatique. Sa philosophie principale est le WORA (Write Once, Run Anywhere) : Ã©crivez votre code une fois, et exÃ©cutez-le nâ€™importe oÃ¹ sans modification.\nLes trois piliers de Java : JDK, JRE et JVM Pour comprendre comment Java fonctionne, il faut distinguer ces trois composants essentiels :",
    "tags": [],
    "title": "Introduction",
    "uri": "/420-210/intro/index.html"
  },
  {
    "breadcrumb": "Programmation orientÃ©e objet",
    "content": "ğŸ¯ Quâ€™est-ce quâ€™une variable? Une variable, câ€™est comme un casier dans votre vestiaire du cÃ©gep. Vous pouvez y mettre vos affaires, les changer, les oublier (oups), et mÃªme y mettre nâ€™importe quoi (tant que Ã§a rentre et que câ€™est du bon type).\nLâ€™identificateur (Le nom) : Câ€™est lâ€™Ã©tiquette sur le casier (ex: 304). Câ€™est ce qui permet au programme de retrouver lâ€™endroit exact en mÃ©moire.\nLa valeur (Le contenu) : Câ€™est ce que tu dÃ©poses Ã  lâ€™intÃ©rieur (ton manuel de programmation, ton ordinateur).\nLe type (Le format) : Câ€™est la taille et la configuration du casier. Un casier pour un vÃ©lo nâ€™a pas la mÃªme forme quâ€™un casier pour un manteau.\nAutre dÃ©finition: Une variable, câ€™est comme une boÃ®te dans laquelle on range une valeur. Elle a toujours trois Ã©lÃ©ments essentiels :\nğŸ‘‰ type nom = valeur;\nPar exemple :\nint var1 = 42; Ici :\nğŸ§¾ int â†’ le type de la variable (entier) ğŸ·ï¸ var1 â†’ le nom de la variable ğŸ 42 â†’ la valeur quâ€™elle contient Les types En Java, les types de donnÃ©es sont divisÃ©s en deux grandes familles :\nğŸ§± Les types primitifs (8 types) ğŸ§© Les types rÃ©fÃ©rences (classes comme String, Scanner, etc.) Les types primitifs sont les briques de base de tout programme Java. Ils permettent de reprÃ©senter les informations simples : nombres, caractÃ¨res, boolÃ©ens.\nğŸ§®a. Les nombres entiers Ils servent Ã  stocker des valeurs sans virgule, positives ou nÃ©gatives. Chaque type utilise un certain nombre dâ€™octets et a une plage de valeurs dÃ©finie :\nType Taille (bits / octets) Valeur minimale Valeur maximale Exemple byte 8 bits (1 octet) -128 127 byte b = 10; short 16 bits (2 octets) -32 768 32 767 short s = 1000; int 32 bits (4 octets) -2â€¯147â€¯483â€¯648 2â€¯147â€¯483â€¯647 int i = 42; long 64 bits (8 octets) -9â€¯223â€¯372â€¯036â€¯854â€¯775â€¯808 9â€¯223â€¯372â€¯036â€¯854â€¯775â€¯807 long l = 100L; Il existe des constantes utiles comme Integer.MAX_VALUE ou Long.MIN_VALUE pour obtenir ces limites sans les retenir. ğŸŒŠ b. Les nombres Ã  virgule (flottants) Ils permettent de reprÃ©senter des valeurs dÃ©cimales (â‰ˆ des rÃ©els), avec une approximation en base 2.\nType Taille (bits / octets) PrÃ©cision Valeur min / max Exemple float 32 bits (4 octets) ~7 chiffres significatifs Â±1.4Ã—10â»â´âµ â†’ Â±3.4Ã—10Â³â¸ float f = 3.14f; double 64 bits (8 octets) ~15-16 chiffres significatifs Â±4.9Ã—10â»Â³Â²â´ â†’ Â±1.8Ã—10Â³â°â¸ double d = 2.718; ğŸ’¡ En Java, les littÃ©raux dÃ©cimaux sont des double par dÃ©faut. Pour un float, on ajoute un f Ã  la fin.\nğŸ”¤ c. Le caractÃ¨re Le type char reprÃ©sente un seul caractÃ¨re Unicode (lettre, symbole, emoji, etc.) :\nType Taille (bits) Plage Unicode Exemple char 16 bits 0 Ã  65 535 (U+0000 Ã  U+FFFF) char c = 'A'; ğŸ¨ Les caractÃ¨res sont entourÃ©s de quotes simples ('A') et peuvent contenir aussi des caractÃ¨res spÃ©ciaux ou emojis :\nchar lettre = 'f'; ğŸ”˜ d. Le boolÃ©en Un boolean est un type logique qui reprÃ©sente vrai ou faux, souvent utilisÃ© dans les conditions :\nType Valeurs possibles Exemple boolean true ou false boolean actif = false; ğŸ’¬ TrÃ¨s utile pour reprÃ©senter des Ã©tats binaires : activÃ©/dÃ©sactivÃ©, visible/cachÃ©, connectÃ©/non connectÃ©â€¦\nboolean estPret = true; boolean estFini = false; âœ¨ RÃ©cap visuel CatÃ©gorie Types RÃ´le principal ğŸ§® Entiers byte, short, int, long Stocker des nombres sans virgule ğŸŒŠ Flottants float, double ReprÃ©senter des valeurs dÃ©cimales ğŸ”¤ CaractÃ¨res char ReprÃ©senter un caractÃ¨re Unicode ğŸ”˜ BoolÃ©ens boolean ReprÃ©senter une valeur vraie ou fausse Les chaÃ®nes de caractÃ¨res (String ) câ€™est quoi? ğŸ¥ Lien vers la classe String de lâ€™API Java\nEn Java, une chaÃ®ne de caractÃ¨res (ou String) est un objet qui reprÃ©sente une sÃ©quence de caractÃ¨res. Contrairement Ã  certains langages oÃ¹ les chaÃ®nes sont simplement des tableaux de caractÃ¨res (char[]), en Java, elles sont des objets de la classe String.\nExemple :\nString message = \"Bonjour !\"; Utilisation simple CrÃ©er une chaÃ®ne :\nString nom = \"Alice\"; //Afficher une chaÃ®ne : System.out.println(nom); ConnaÃ®tre la longueur :\nint longueur = nom.length(); // renvoie 5 ConcatÃ©nation La concatÃ©nation permet de combiner plusieurs chaÃ®nes en une seule.\nUtilisation de lâ€™opÃ©rateur + : String prenom = \"Alice\"; String message = \"Bonjour, \" + prenom + \" !\"; System.out.println(message); // Bonjour, Alice ! ConcatÃ©nation avec des nombres : int age = 20; String info = \"Elle a \" + age + \" ans.\"; System.out.println(info); // Elle a 20 ans. 1. MÃ©thodes Statistiques de la classe String Les mÃ©thodes statiques de la classe String ne nÃ©cessitent pas de crÃ©er une instance de String pour les utiliser. Vous les appelez directement sur la classe elle-mÃªme. Voici quelques exemples de mÃ©thodes statiques courantes :\nExemple 1 : String.format() Cette mÃ©thode statique permet de formater une chaÃ®ne de caractÃ¨res en utilisant des espaces rÃ©servÃ©s (placeholders).\npublic class ExempleStringStatic { public static void main(String[] args) { String name = \"Alice\"; int age = 30; String formattedString = String.format(\"Nom : %s, Ã‚ge : %d\", name, age); System.out.println(formattedString); } } Sortie attendue :\nNom : Alice, Ã‚ge : 30 2. MÃ©thodes Non Statiques de la classe String Les mÃ©thodes non-statiques nÃ©cessitent une instance de la classe String pour Ãªtre utilisÃ©es. Vous devez crÃ©er un objet String pour appeler ces mÃ©thodes. Voici quelques exemples :\nExemple 1 : length() Cette mÃ©thode retourne la longueur (nombre de caractÃ¨res) de la chaÃ®ne de caractÃ¨res.\npublic class ExempleStringNonStatic { public static void main(String[] args) { String message = \"Bonjour\"; int length = message.length(); // Appel de la mÃ©thode non statique System.out.println(\"La longueur de la chaÃ®ne est : \" + length); } } Sortie attendue :\nLa longueur de la chaÃ®ne est : 7 Exemple 2 : charAt() Cette mÃ©thode retourne le caractÃ¨re situÃ© Ã  une position spÃ©cifiÃ©e dans la chaÃ®ne.\npublic class ExempleStringNonStatic { public static void main(String[] args) { String message = \"Java\"; char character = message.charAt(2); // RÃ©cupÃ¨re le caractÃ¨re Ã  l'indice 2 System.out.println(\"Le caractÃ¨re Ã  l'indice 2 est : \" + character); } } Sortie attendue :\nLe caractÃ¨re Ã  l'indice 2 est : v Exemple 3 : substring() Cette mÃ©thode retourne une sous-chaÃ®ne de la chaÃ®ne principale en fonction des indices donnÃ©s.\npublic class ExempleStringNonStatic { public static void main(String[] args) { String message = \"Bienvenue\"; String substring = message.substring(3, 7); // Extrait de l'indice 3 Ã  6 System.out.println(\"Sous-chaÃ®ne : \" + substring); } } Sortie attendue :\nSous-chaÃ®ne : nven Exemple 4 : toLowerCase() et toUpperCase() Ces mÃ©thodes convertissent tous les caractÃ¨res de la chaÃ®ne en minuscules ou en majuscules.\npublic class ExempleStringNonStatic { public static void main(String[] args) { String message = \"Java Programming\"; String lower = message.toLowerCase(); // Convertir en minuscules String upper = message.toUpperCase(); // Convertir en majuscules System.out.println(\"En minuscules : \" + lower); System.out.println(\"En majuscules : \" + upper); } } Sortie attendue :\nEn minuscules : java programming En majuscules : JAVA PROGRAMMING Exemple 5 : contains() Cette mÃ©thode permet de vÃ©rifier si une chaÃ®ne contient une sous-chaÃ®ne spÃ©cifiÃ©e.\npublic class ExempleStringNonStatic { public static void main(String[] args) { String message = \"Java est gÃ©nial!\"; boolean contains = message.contains(\"gÃ©nial\"); // VÃ©rifie si \"gÃ©nial\" est dans la chaÃ®ne System.out.println(\"La chaÃ®ne contient 'gÃ©nial' ? \" + contains); } } Sortie attendue :\nLa chaÃ®ne contient 'gÃ©nial' ? true RÃ©sumÃ© des diffÃ©rences entre les mÃ©thodes statiques et non-statiques : MÃ©thodes statiques :\nAppelÃ©es sur la classe elle-mÃªme, pas besoin dâ€™instance. Exemples : String.valueOf(), String.format(), String.join(). MÃ©thodes non-statiques :\nAppelÃ©es sur une instance de la classe String. Exemples : length(), charAt(), substring(), toLowerCase(). ğŸ”„ Conversion implicite vs explicite en Java La conversion permet de changer le type dâ€™une donnÃ©e pour lâ€™adapter Ã  une autre variable ou expression.\na. Conversion implicite (promotion automatique) Java effectue automatiquement la conversion quand il nâ€™y a pas de risque de perte de donnÃ©es. Se produit souvent quand on passe dâ€™un type plus petit Ã  un type plus grand. Exemples classiques : De Vers Exemple int double double d = 5; byte int int x = 10; int a = 10; double b = a; // Conversion implicite b. Conversion explicite (casting) NÃ©cessaire quand il y a un risque de perte de donnÃ©es ou incompatibilitÃ©. Le programmeur doit forcer la conversion avec un cast (type). Exemples classiques : De Vers Exemple double int int x = (int) 9.99; long int int y = (int) 100000L; double x = 9.99; int y = (int) x; // Conversion explicite, dÃ©cimale perdue c. DiffÃ©rences clÃ©s Aspect Conversion implicite Conversion explicite NÃ©cessite une action ? Non, automatique Oui, cast obligatoire (type) Risque de perte Non Oui Sens Du plus petit au plus grand Du plus grand au plus petit Exemples int â†’ double double â†’ int d. En rÃ©sumÃ© Conversion implicite = sÃ»re, automatique, du type petit vers grand. Conversion explicite = risquÃ©e, forcÃ©e, du type grand vers petit. Utilise toujours le casting explicite pour Ã©viter les erreurs de compilation. ğŸ§  Ã€ retenir Java convertit tout seul quand câ€™est sÃ»r. Pour tout ce qui peut perdre des infos, il faut caster manuellement. Sois vigilant avec les conversions explicites, elles peuvent tronquer ou modifier la valeur. Conversion des types Le terme le plus utilisÃ© pour la technique de conversion est Â« Casting Â».\nCas 1 Conversion 1 : String vers les numÃ©riques Conversion 2 : Les numÃ©riques vers une String en utilisant la mÃ©thode valueOf() Conversion 3 : Les numÃ©riques vers une String en utilisant la mÃ©thode toString() Conversion 4 : String vers les primitifs Conversion 5 : Primitifs vers String Conversion 6 : Les primitifs vers une String en utilisant la mÃ©thode valueOf() Automatique vs manuelle Conversion automatique : il sâ€™agit dâ€™une conversion dâ€™un type plus petit en un type plus grand\nbyte -\u003e short -\u003e char -\u003e int -\u003e long -\u003e float -\u003e double\nCas 2 Conversion manuelle :\nil sâ€™agit de la conversion dâ€™un type plus grand en un type de taille plus petite. Il suffit de rajouter le casting du type voulu Ã  droite.\ndouble -\u003e float -\u003e long -\u003e int -\u003e char -\u003e short -\u003e byte double d = 2000.23; float f = (float)d; long l = (long) f;\nQuand on diminue la taille il y a parfois une perte dâ€™information comme si lâ€™on passe de float Ã  int:\nfloat a = 4.53F; System.out.println((int) a); //4 Pour rÃ©sumer : Dans le cas dâ€™une conversion de petit vers grand â” on ne fait rien. Dans le cas dâ€™une conversion dâ€™un grand vers un petit â” il faut Â« Caster Â» la partie droite en type du petit.",
    "description": "ğŸ¯ Quâ€™est-ce quâ€™une variable? Une variable, câ€™est comme un casier dans votre vestiaire du cÃ©gep. Vous pouvez y mettre vos affaires, les changer, les oublier (oups), et mÃªme y mettre nâ€™importe quoi (tant que Ã§a rentre et que câ€™est du bon type).\nLâ€™identificateur (Le nom) : Câ€™est lâ€™Ã©tiquette sur le casier (ex: 304). Câ€™est ce qui permet au programme de retrouver lâ€™endroit exact en mÃ©moire.",
    "tags": [],
    "title": "Variables",
    "uri": "/420-210/variables/index.html"
  },
  {
    "breadcrumb": "Programmation orientÃ©e objet",
    "content": "OpÃ©rateurs ArithmÃ©tiques en Java OpÃ©rateur Nom Description Exemple RÃ©sultat + Addition Somme de deux valeurs int x = 10 + 5; 15 - Soustraction DiffÃ©rence entre deux valeurs int x = 20 - 8; 12 * Multiplication Produit de deux valeurs double x = 5.5 * 2; 11.0 / Division Quotient de la division int x = 10 / 3; 3 (Entier) % Modulo Reste de la division entiÃ¨re int x = 10 % 3; 1 OpÃ©rateurs dâ€™incrÃ©mentation et de dÃ©crÃ©mentation OpÃ©rateur Nom Position Description Exemple RÃ©sultat (x) ++x PrÃ©-incrÃ©mentation Avant IncrÃ©mente, puis retourne la valeur int y = ++x; AugmentÃ© de 1 x++ Post-incrÃ©mentation AprÃ¨s Retourne la valeur, puis incrÃ©mente int y = x++; AugmentÃ© de 1 --x PrÃ©-dÃ©crÃ©mentation Avant DÃ©crÃ©mente, puis retourne la valeur int y = --x; DiminuÃ© de 1 x-- Post-dÃ©crÃ©mentation AprÃ¨s Retourne la valeur, puis dÃ©crÃ©mente int y = x--; DiminuÃ© de 1 Pourquoi la position est-elle importante ? La diffÃ©rence rÃ©side dans la valeur retournÃ©e par lâ€™expression au moment de lâ€™exÃ©cution :\nPrÃ© (++x) : Mise Ã  jour dâ€™abord, puis utilisation immÃ©diate. Post (x++) : Utilisation de la valeur actuelle, puis mise Ã  jour juste aprÃ¨s. Exemple de comparaison : int a = 10; int b = 10; int resultatA = ++a; // a devient 11, puis resultatA reÃ§oit 11 int resultatB = b++; // resultatB reÃ§oit 10, puis b devient 11 // Ã€ la fin : // a est 11, resultatA est 11 // b est 11, resultatB est 10 OpÃ©rateurs Logiques en Java Les opÃ©rateurs logiques permettent de tester plusieurs conditions Ã  la fois et retournent toujours une valeur boolÃ©enne (true ou false).\nOpÃ©rateur Nom Description Exemple \u0026\u0026 ET (AND) Retourne true si toutes les conditions sont vraies (age \u003e= 18 \u0026\u0026 aPermis) || OU (OR) Retourne true si au moins une condition est vraie (estSamedi || estDimanche) ! NON (NOT) Inverse la valeur logique !estConnecte ^ OU exclusif (XOR) Retourne true si une seule condition est vraie (optionA ^ optionB) Tables de vÃ©ritÃ© (RÃ©sumÃ©) A B A \u0026\u0026 B A || B A ^ B !A true true true true false false true false false true true false false true false true true true false false false false false true Le concept de â€œCourt-circuitâ€ (Short-circuit) Les opÃ©rateurs \u0026\u0026 et || sont dits Ã  court-circuit en Java :\nAvec \u0026\u0026 : Si la premiÃ¨re condition est fausse, la seconde nâ€™est pas Ã©valuÃ©e. Avec || : Si la premiÃ¨re condition est vraie, Java sâ€™arrÃªte immÃ©diatement. Astuce : Placez toujours la condition la plus risquÃ©e ou coÃ»teuse en deuxiÃ¨me position.\nOpÃ©rateurs logiques : Court-circuit vs Ã‰valuation complÃ¨te Type ET OU Comportement Court-circuit \u0026\u0026 || Ã‰value la 2e condition uniquement si nÃ©cessaire Ã‰valuation complÃ¨te \u0026 | Ã‰value toujours les deux conditions Pourquoi utiliser lâ€™Ã©valuation complÃ¨te (\u0026 et |) ? Ces opÃ©rateurs sont utilisÃ©s lorsque la deuxiÃ¨me condition contient un effet de bord qui doit absolument Ãªtre exÃ©cutÃ© (incrÃ©mentation, appel de mÃ©thode, etc.).\nExemple de diffÃ©rence int compteur = 0; boolean conditionFausse = false; // Cas 1 : Court-circuit (\u0026\u0026) if (conditionFausse \u0026\u0026 ++compteur \u003e 0) { } System.out.println(compteur); // Affiche 0 // Cas 2 : Ã‰valuation complÃ¨te (\u0026) if (conditionFausse \u0026 ++compteur \u003e 0) { } System.out.println(compteur); // Affiche 1 OpÃ©rateurs de comparaison en Java Les opÃ©rateurs de comparaison permettent de vÃ©rifier la relation entre deux expressions.\nLe rÃ©sultat est toujours une valeur boolÃ©enne (true ou false).\nOpÃ©rateur Nom Description Exemple RÃ©sultat == Ã‰galitÃ© true si les valeurs primitives sont identiques 5 == 5 true != InÃ©galitÃ© true si les valeurs sont diffÃ©rentes 5 != 3 true \u003e Plus grand que true si la valeur de gauche est strictement supÃ©rieure 10 \u003e 5 true \u003c Plus petit que true si la valeur de gauche est strictement infÃ©rieure 2 \u003c 1 false \u003e= Plus grand ou Ã©gal true si la valeur de gauche est supÃ©rieure ou Ã©gale 5 \u003e= 5 true \u003c= Plus petit ou Ã©gal true si la valeur de gauche est infÃ©rieure ou Ã©gale 4 \u003c= 3 false Confusion entre = et == Erreur frÃ©quente chez les dÃ©butants :\n= est lâ€™opÃ©rateur dâ€™assignation. == est lâ€™opÃ©rateur de comparaison. Comparaison de chaÃ®nes de caractÃ¨res (String) en Java âš ï¸ En Java, lâ€™opÃ©rateur == compare les rÃ©fÃ©rences, pas le contenu des chaÃ®nes. Pour comparer les valeurs des chaines de caractÃ¨res, il faut utiliser la fonction equals ou sa version ``equalsIgnoreCase`\nString nomUn = \"Bob\"; String nomDeux = \"bob\"; boolean sontEgaux = nomUn.equals(nomDeux); // false (sensible Ã  la casse) boolean sontEgauxNonSensible = nomUn.equals(nomDeux); // true (ignore les casses)",
    "description": "OpÃ©rateurs ArithmÃ©tiques en Java OpÃ©rateur Nom Description Exemple RÃ©sultat + Addition Somme de deux valeurs int x = 10 + 5; 15 - Soustraction DiffÃ©rence entre deux valeurs int x = 20 - 8; 12 * Multiplication Produit de deux valeurs double x = 5.5 * 2; 11.0 / Division Quotient de la division int x = 10 / 3; 3 (Entier) % Modulo Reste de la division entiÃ¨re int x = 10 % 3; 1 OpÃ©rateurs dâ€™incrÃ©mentation et de dÃ©crÃ©mentation OpÃ©rateur Nom Position Description Exemple RÃ©sultat (x) ++x PrÃ©-incrÃ©mentation Avant IncrÃ©mente, puis retourne la valeur int y = ++x; AugmentÃ© de 1 x++ Post-incrÃ©mentation AprÃ¨s Retourne la valeur, puis incrÃ©mente int y = x++; AugmentÃ© de 1 --x PrÃ©-dÃ©crÃ©mentation Avant DÃ©crÃ©mente, puis retourne la valeur int y = --x; DiminuÃ© de 1 x-- Post-dÃ©crÃ©mentation AprÃ¨s Retourne la valeur, puis dÃ©crÃ©mente int y = x--; DiminuÃ© de 1 Pourquoi la position est-elle importante ? La diffÃ©rence rÃ©side dans la valeur retournÃ©e par lâ€™expression au moment de lâ€™exÃ©cution :",
    "tags": [],
    "title": "OpÃ©rateurs",
    "uri": "/420-210/operateurs/index.html"
  },
  {
    "breadcrumb": "Programmation orientÃ©e objet",
    "content": "Les structures de contrÃ´le en Java Introduction Jusquâ€™Ã  prÃ©sent, vos programmes sâ€™exÃ©cutaient ligne par ligne, de haut en bas, comme une recette suivie Ã  la lettre.\nLes structures de contrÃ´le permettent de prendre des dÃ©cisions et de rÃ©pÃ©ter des actions.\nğŸ‘‰ GrÃ¢ce Ã  elles, un programme devient intelligent, dynamique et utile dans la vraie vie.\nOn distingue trois grandes familles :\nLes structures conditionnelles (faire un choix) Les structures rÃ©pÃ©titives (rÃ©pÃ©ter une action) Les structures de contrÃ´le de flux (modifier le dÃ©roulement) 1. Les structures conditionnelles Les structures conditionnelles permettent dâ€™exÃ©cuter du code seulement si une condition est vraie.\n1.1 La structure if Syntaxe if (condition) { // instructions exÃ©cutÃ©es si la condition est vraie } RÃ¨gle importante :\nLa condition doit toujours Ãªtre une expression boolÃ©enne, câ€™est-Ã -dire une expression qui retourne true ou false.\n1.1 La structure if Syntaxe if (condition) { // instructions exÃ©cutÃ©es si la condition est vraie } La condition est Ã©valuÃ©e :\nsi elle est true, le bloc est exÃ©cutÃ©\nsi elle est false, le bloc est ignorÃ©\nExemple int age = 18; if (age \u003e= 18) { System.out.println(\"AccÃ¨s autorisÃ©\"); } 1.2 La structure if / else Permet de choisir entre deux chemins possibles.\nSyntaxe if (condition) { // exÃ©cutÃ© si la condition est vraie } else { // exÃ©cutÃ© si la condition est fausse } Exemple int temperature = 15; if (temperature \u003e= 20) { System.out.println(\"Il fait chaud\"); } else { System.out.println(\"Il fait frais\"); } Un seul des deux blocs sera exÃ©cutÃ©.\n1.3 La structure if / else if / else UtilisÃ©e lorsquâ€™il y a plusieurs choix possibles.\nSyntaxe if (condition1) { // cas 1 } else if (condition2) { // cas 2 } else { // cas par dÃ©faut } Exemple int note = 72; if (note \u003e= 90) { System.out.println(\"Excellent\"); } else if (note \u003e= 60) { System.out.println(\"RÃ©ussi\"); } else { System.out.println(\"Ã‰chec\"); } Les conditions sont testÃ©es dans lâ€™ordre, et Java sâ€™arrÃªte dÃ¨s quâ€™une condition est vraie.\n1.4 Erreurs frÃ©quentes avec les conditions Confusion entre = et ==\nif (x = 5) { } // ERREUR if (x == 5) { } // CORRECT Oubli des accolades\nif (x \u003e 0) System.out.println(\"Positif\"); System.out.println(\"Fin\"); Dans ce cas, â€œFinâ€ sâ€™affiche toujours.\n2. Les structures rÃ©pÃ©titives (boucles) Les boucles permettent de rÃ©pÃ©ter un bloc de code tant quâ€™une condition est respectÃ©e.\n2.1 La boucle while La condition est testÃ©e avant chaque rÃ©pÃ©tition.\nSyntaxe while (condition) { // instructions rÃ©pÃ©tÃ©es } Exemple int compteur = 1; while (compteur \u003c= 5) { System.out.println(compteur); compteur++; } 2.2 La boucle do / while Le bloc sâ€™exÃ©cute au moins une fois, puis la condition est testÃ©e.\nSyntaxe do { // instructions } while (condition); Exemple int choix; do { System.out.println(\"Menu affichÃ©\"); choix = 0; } while (choix != 0); 2.3 La boucle for UtilisÃ©e lorsque le nombre de rÃ©pÃ©titions est connu Ã  lâ€™avance.\nSyntaxe for (initialisation; condition; incrÃ©mentation) { // instructions } Exemple for (int i = 0; i \u003c 5; i++) { System.out.println(i); } 2.4 Comparaison des boucles Boucle Utilisation recommandÃ©e while Nombre de rÃ©pÃ©titions inconnu do/while Au moins une exÃ©cution nÃ©cessaire for Nombre de rÃ©pÃ©titions connu 3. Les structures de contrÃ´le du flux 3.1 Lâ€™instruction break Permet de sortir immÃ©diatement dâ€™une boucle.\nfor (int i = 1; i \u003c= 10; i++) { if (i == 5) { break; } System.out.println(i); } 3.2 Lâ€™instruction continue Permet de passer directement Ã  lâ€™itÃ©ration suivante.\nfor (int i = 1; i \u003c= 5; i++) { if (i == 3) { continue; } System.out.println(i); }",
    "description": "Les structures de contrÃ´le en Java Introduction Jusquâ€™Ã  prÃ©sent, vos programmes sâ€™exÃ©cutaient ligne par ligne, de haut en bas, comme une recette suivie Ã  la lettre.\nLes structures de contrÃ´le permettent de prendre des dÃ©cisions et de rÃ©pÃ©ter des actions.\nğŸ‘‰ GrÃ¢ce Ã  elles, un programme devient intelligent, dynamique et utile dans la vraie vie.",
    "tags": [],
    "title": "Structures de contrÃ´le",
    "uri": "/420-210/structures/index.html"
  },
  {
    "breadcrumb": "Programmation orientÃ©e objet",
    "content": "ğŸ› ï¸ Les MÃ©thodes en Java : Segmenter pour mieux rÃ©gner En programmation, une mÃ©thode est un bloc de code nommÃ© qui contient une sÃ©quence dâ€™instructions. Au lieu dâ€™Ã©crire tout votre code dans le bloc principal (main), vous crÃ©ez des unitÃ©s de travail spÃ©cialisÃ©es que vous pouvez appeler au besoin.\nLâ€™analogie de la boÃ®te : Imaginez une mÃ©thode comme une boÃ®te fermÃ©e. Vous ne voyez pas forcÃ©ment lâ€™engrenage Ã  lâ€™intÃ©rieur, mais vous savez comment lâ€™utiliser en appuyant sur un bouton ou en y insÃ©rant des donnÃ©es.\n1. La boÃ®te dâ€™action simple (void sans paramÃ¨tre) Il sâ€™agit du type de mÃ©thode le plus Ã©lÃ©mentaire. Elle ne demande aucune information et ne renvoie aucune donnÃ©e. Elle exÃ©cute simplement une tÃ¢che prÃ©dÃ©finie.\nvoid : Ce mot-clÃ© signifie â€œvideâ€. Il indique que la mÃ©thode ne rend rien au programme. () : Les parenthÃ¨ses vides indiquent que la boÃ®te ne nÃ©cessite aucune donnÃ©e dâ€™entrÃ©e pour fonctionner. public static void afficherEntete() { System.out.println(\"******************************\"); System.out.println(\" BIENVENUE AU SYSTÃˆME \"); System.out.println(\"******************************\"); } 2. La boÃ®te avec instructions (void avec paramÃ¨tres) Cette mÃ©thode a besoin dâ€™informations pour fonctionner (des paramÃ¨tres), mais elle ne renvoie toujours pas de rÃ©sultat au programme. Elle utilise les entrÃ©es pour effectuer une action, comme un affichage personnalisÃ©.\nParamÃ¨tres : Ce sont les variables dÃ©clarÃ©es entre les parenthÃ¨ses. Elles servent de â€œfiches dâ€™instructionsâ€ pour la mÃ©thode. public static void saluerUtilisateur(String prenom, int age) { System.out.println(\"Bonjour \" + prenom + \" !\"); System.out.println(\"Vous avez \" + age + \" ans.\"); } 3. La boÃ®te de calcul (Avec paramÃ¨tres et retour) Câ€™est lâ€™analogie complÃ¨te de la machine distributrice :\nVous insÃ©rez des donnÃ©es (lâ€™argent) : ce sont les ParamÃ¨tres. La machine transforme lâ€™entrÃ©e : câ€™est le Traitement. Elle vous Ã©jecte un produit (le bonbon) : câ€™est le Retour. Type de retour : On remplace void par le type de la donnÃ©e qui sortira de la boÃ®te (ex: int, double, String). Instruction return : Câ€™est le mÃ©canisme qui permet dâ€™expulser la valeur finale hors de la mÃ©thode. public static double calculerTaxe(double montantBrut) { double taxe = montantBrut * 0.15; // Calcul de la taxe de 15% return taxe; // On Ã©jecte le rÃ©sultat vers l'appelant } 4. SynthÃ¨se : Quel type de boÃ®te choisir ? Pour dÃ©terminer la structure de votre mÃ©thode, vous devez vous poser deux questions fondamentales avant mÃªme de commencer Ã  coder.\nLe guide de dÃ©cision EntrÃ©e (ParamÃ¨tres) : Est-ce que ma machine a besoin de donnÃ©es extÃ©rieures pour fonctionner ? Sortie (Retour) : Est-ce que ma machine doit fournir une rÃ©ponse que je vais rÃ©utiliser plus tard dans mon code ? Tableau rÃ©capitulatif des structures Type de mÃ©thode Type de retour ParamÃ¨tres Analogie de la boÃ®te Action pure void Aucun () Le bouton â€œAlarmeâ€ : on appuie, le son sort, aucune information nâ€™est demandÃ©e. Action paramÃ©trÃ©e void PrÃ©sents Le haut-parleur : on lui donne un texte, il le diffuse, mais il ne nous redonne rien en main. Calculatrice int, double, etc. PrÃ©sents La machine distributrice : on insÃ¨re de lâ€™argent, la machine traite, et nous redonne un produit. ğŸ’¡ La rÃ¨gle dâ€™or : â€œUne tÃ¢che, une boÃ®teâ€ Une erreur frÃ©quente est de vouloir crÃ©er une boÃ®te qui fait trop de choses (ex: calculer, afficher, et sauvegarder).\nMauvaise pratique : Une mÃ©thode gÃ©ante difficile Ã  corriger. Bonne pratique : Plusieurs petites mÃ©thodes simples qui sâ€™appellent entre elles. Cela rend votre code modulaire et beaucoup plus facile Ã  dÃ©boguer pour vos travaux pratiques. 5. Exemples supplÃ©mentaires par mise en situation A. La boÃ®te â€œVÃ©rificatriceâ€ (Type boolean) Cette boÃ®te reÃ§oit une information et rÃ©pond simplement par Vrai ou Faux. Câ€™est trÃ¨s utile pour valider des conditions de jeu.\nEntrÃ©e : Lâ€™Ã¢ge de lâ€™utilisateur. Sortie : Un signal (Vrai/Faux) indiquant si lâ€™accÃ¨s est permis. public static boolean estMajeur(int age) { if (age \u003e= 18) { return true; } else { return false; } }",
    "description": "ğŸ› ï¸ Les MÃ©thodes en Java : Segmenter pour mieux rÃ©gner En programmation, une mÃ©thode est un bloc de code nommÃ© qui contient une sÃ©quence dâ€™instructions. Au lieu dâ€™Ã©crire tout votre code dans le bloc principal (main), vous crÃ©ez des unitÃ©s de travail spÃ©cialisÃ©es que vous pouvez appeler au besoin.\nLâ€™analogie de la boÃ®te : Imaginez une mÃ©thode comme une boÃ®te fermÃ©e. Vous ne voyez pas forcÃ©ment lâ€™engrenage Ã  lâ€™intÃ©rieur, mais vous savez comment lâ€™utiliser en appuyant sur un bouton ou en y insÃ©rant des donnÃ©es.",
    "tags": [],
    "title": "MÃ©thodes",
    "uri": "/420-210/methodes/index.html"
  },
  {
    "breadcrumb": "Programmation orientÃ©e objet",
    "content": "Mini-Projets Java - Exercices Complets Variables, OpÃ©rateurs, Structures de ContrÃ´le et MÃ©thodes ğŸ® Projet 1 : SystÃ¨me de Gestion de Notes Scolaires ğŸ“‹ Contexte Vous devez crÃ©er un systÃ¨me pour gÃ©rer et analyser les notes dâ€™une classe dâ€™Ã©tudiants. Le systÃ¨me permettra de calculer des statistiques, dâ€™attribuer des mentions et de gÃ©nÃ©rer des rapports.\nğŸ¯ Objectifs pÃ©dagogiques Manipulation de tableaux Calculs statistiques (moyenne, min, max) Structures conditionnelles pour la classification Boucles pour parcourir des donnÃ©es MÃ©thodes avec paramÃ¨tres et valeurs de retour ğŸ“ Instructions dÃ©taillÃ©es CrÃ©ez une classe GestionNotes avec les mÃ©thodes suivantes :\n1. MÃ©thode calculerMoyenne But : Calculer la moyenne arithmÃ©tique dâ€™un tableau de notes.\nParamÃ¨tres :\nnotes : un tableau de double contenant les notes Retour : La moyenne sous forme de double\nAlgorithme :\nParcourir toutes les notes du tableau Additionner toutes les notes Diviser la somme par le nombre de notes Retourner le rÃ©sultat Exemple : Pour les notes [15.5, 12.0, 18.0], la moyenne est (15.5 + 12.0 + 18.0) / 3 = 15.17\n2. MÃ©thode trouverMaximum But : Trouver la note la plus Ã©levÃ©e dans le tableau.\nParamÃ¨tres :\nnotes : un tableau de double Retour : La note maximale (double)\nAlgorithme :\nInitialiser une variable avec la premiÃ¨re note Parcourir toutes les autres notes Si une note est supÃ©rieure au maximum actuel, la remplacer Retourner le maximum trouvÃ© 3. MÃ©thode trouverMinimum But : Trouver la note la plus basse dans le tableau.\nParamÃ¨tres :\nnotes : un tableau de double Retour : La note minimale (double)\nAlgorithme : Similaire Ã  trouverMaximum, mais en cherchant la plus petite valeur.\n4. MÃ©thode compterReussites But : Compter combien dâ€™Ã©tudiants ont une note supÃ©rieure ou Ã©gale Ã  10 (seuil de rÃ©ussite).\nParamÃ¨tres :\nnotes : un tableau de double Retour : Le nombre dâ€™Ã©tudiants ayant rÃ©ussi (int)\nAlgorithme :\nInitialiser un compteur Ã  0 Parcourir toutes les notes Pour chaque note \u003e= 10, incrÃ©menter le compteur Retourner le compteur 5. MÃ©thode obtenirMention But : DÃ©terminer la mention obtenue selon la moyenne dâ€™un Ã©tudiant.\nParamÃ¨tres :\nmoyenne : la moyenne de lâ€™Ã©tudiant (double) Retour : Une chaÃ®ne de caractÃ¨res (String) reprÃ©sentant la mention\nRÃ¨gles de mentions :\nmoyenne \u003e= 16 : â€œTrÃ¨s Bienâ€ moyenne \u003e= 14 : â€œBienâ€ moyenne \u003e= 12 : â€œAssez Bienâ€ moyenne \u003e= 10 : â€œPassableâ€ moyenne \u003c 10 : â€œÃ‰checâ€ Algorithme :\nUtiliser une sÃ©rie de conditions if/else if/else Comparer la moyenne aux seuils (du plus Ã©levÃ© au plus bas) Retourner la mention correspondante 6. MÃ©thode afficherRapport But : GÃ©nÃ©rer et afficher un rapport complet des statistiques de la classe.\nParamÃ¨tres :\nnotes : un tableau de double Retour : void (la mÃ©thode affiche directement Ã  lâ€™Ã©cran)\nInformations Ã  afficher :\nNombre total dâ€™Ã©tudiants (taille du tableau) Moyenne gÃ©nÃ©rale de la classe (utiliser calculerMoyenne) Note maximale et minimale (utiliser les mÃ©thodes correspondantes) Taux de rÃ©ussite en pourcentage : (nombre de rÃ©ussites / total) Ã— 100 Distribution des mentions : Compter combien dâ€™Ã©tudiants ont chaque mention Pour cela, parcourir toutes les notes, calculer la mention de chaque note, et compter Format dâ€™affichage attendu :\n===== RAPPORT DE NOTES ===== Nombre d'Ã©tudiants : 10 Moyenne gÃ©nÃ©rale : 12.60 Note maximale : 18.00 Note minimale : 7.50 Taux de rÃ©ussite : 70.00% Distribution des mentions : - TrÃ¨s Bien : 2 - Bien : 2 - Assez Bien : 2 - Passable : 1 - Ã‰chec : 3 7. MÃ©thode main But : Tester toutes les fonctionnalitÃ©s du systÃ¨me.\nInstructions :\nCrÃ©er un tableau de notes de test : {15.5, 8.0, 12.5, 18.0, 9.5, 14.0, 16.5, 11.0, 7.5, 13.5} Appeler la mÃ©thode afficherRapport avec ce tableau Tester Ã©galement les mÃ©thodes individuellement pour vÃ©rifier leur bon fonctionnement âœ… CritÃ¨res de validation Toutes les mÃ©thodes sont crÃ©Ã©es avec les bons paramÃ¨tres et types de retour La moyenne est calculÃ©e correctement Le maximum et minimum sont trouvÃ©s correctement Le comptage des rÃ©ussites fonctionne Les mentions sont attribuÃ©es selon les bons seuils Le rapport affiche toutes les informations demandÃ©es Le code est lisible avec des noms de variables significatifs ğŸ’¡ Conseils Testez chaque mÃ©thode individuellement avant de crÃ©er le rapport complet Utilisez System.out.printf(\"%.2f\", nombre) pour formater les nombres avec 2 dÃ©cimales Pour calculer un pourcentage : (partieDouble / totalDouble) * 100.0 ğŸ’° Projet 2 : Calculateur de Salaire et ImpÃ´ts ğŸ“‹ Contexte DÃ©veloppez un systÃ¨me de calcul de salaire net avec diffÃ©rentes dÃ©ductions, heures supplÃ©mentaires, bonus et impÃ´ts. Ce systÃ¨me doit gÃ©nÃ©rer une fiche de paie complÃ¨te.\nğŸ¯ Objectifs pÃ©dagogiques Calculs arithmÃ©tiques complexes Conditions imbriquÃ©es pour les tranches dâ€™imposition Formules mathÃ©matiques appliquÃ©es Organisation de code en mÃ©thodes rÃ©utilisables ğŸ“ Instructions dÃ©taillÃ©es CrÃ©ez une classe CalculateurSalaire avec les mÃ©thodes suivantes :\n1. MÃ©thode calculerSalaireBrut But : Calculer le salaire brut mensuel en prenant en compte les heures supplÃ©mentaires.\nParamÃ¨tres :\ntauxHoraire : taux horaire en euros (double) heuresTravaillees : nombre dâ€™heures travaillÃ©es dans le mois (int) Retour : Le salaire brut (double)\nRÃ¨gles :\nLe nombre dâ€™heures normales par mois est 151.67 heures Les heures au-delÃ  sont des heures supplÃ©mentaires Les heures supplÃ©mentaires sont payÃ©es avec un bonus de 25% Algorithme :\nSi heuresTravaillees \u003c= 151.67 : salaire = tauxHoraire Ã— heuresTravaillees Sinon : Calculer le salaire des heures normales : 151.67 Ã— tauxHoraire Calculer les heures supplÃ©mentaires : heuresTravaillees - 151.67 Calculer le salaire des heures sup : heuresSup Ã— tauxHoraire Ã— 1.25 Additionner les deux montants Exemple : Si tauxHoraire = 15â‚¬ et heures = 170\nHeures normales : 151.67 Ã— 15 = 2275.05â‚¬ Heures supplÃ©mentaires : 18.33 Ã— 15 Ã— 1.25 = 343.69â‚¬ Total brut : 2618.74â‚¬ 2. MÃ©thode calculerCotisations But : Calculer le montant des cotisations sociales.\nParamÃ¨tres :\nsalaireBrut : salaire brut mensuel (double) Retour : Montant des cotisations (double)\nRÃ¨gle : Les cotisations reprÃ©sentent 22% du salaire brut\nFormule : salaireBrut * 0.22\n3. MÃ©thode calculerImpot But : Calculer lâ€™impÃ´t sur le revenu annuel selon le systÃ¨me de tranches progressives.\nParamÃ¨tres :\nsalaireAnnuelNet : salaire net annuel aprÃ¨s cotisations (double) Retour : Montant total de lâ€™impÃ´t annuel (double)\nTranches dâ€™imposition :\n0 Ã  10 000â‚¬ : 0% 10 001â‚¬ Ã  25 000â‚¬ : 11% 25 001â‚¬ Ã  50 000â‚¬ : 30% Au-delÃ  de 50 000â‚¬ : 41% Algorithme (systÃ¨me de tranches) :\nLâ€™impÃ´t se calcule tranche par tranche Exemple pour un salaire de 30 000â‚¬ : Tranche 1 (0-10000) : 10000 Ã— 0% = 0â‚¬ Tranche 2 (10001-25000) : 15000 Ã— 11% = 1650â‚¬ Tranche 3 (25001-30000) : 5000 Ã— 30% = 1500â‚¬ Total impÃ´t : 3150â‚¬ Pseudo-code :\nimpot = 0 reste = salaireAnnuelNet Si reste \u003e 10000: impot += (min(reste, 25000) - 10000) Ã— 0.11 Si reste \u003e 25000: impot += (min(reste, 50000) - 25000) Ã— 0.30 Si reste \u003e 50000: impot += (reste - 50000) Ã— 0.41 4. MÃ©thode calculerBonus But : Calculer le bonus annuel selon lâ€™anciennetÃ© et la performance.\nParamÃ¨tres :\nsalaireBrut : salaire brut mensuel (double) anciennete : annÃ©es dâ€™anciennetÃ© (int) performance : note de performance de 0 Ã  10 (int) Retour : Montant du bonus mensuel (double)\nRÃ¨gles :\nSi performance \u003c 7 : aucun bonus (retourner 0) Si performance \u003e= 7 : Bonus de base : 5% du salaire brut Bonus dâ€™anciennetÃ© : +1% par annÃ©e dâ€™anciennetÃ© (maximum +10%) Le bonus total ne peut pas dÃ©passer 15% du salaire brut Exemple :\nSalaire brut = 2000â‚¬, anciennetÃ© = 8 ans, performance = 8 Bonus de base : 2000 Ã— 5% = 100â‚¬ Bonus anciennetÃ© : 2000 Ã— 8% = 160â‚¬ (limitÃ© Ã  10% = 200â‚¬) Total bonus : 100 + 160 = 260â‚¬ 5. MÃ©thode genererFichePaie But : GÃ©nÃ©rer et afficher une fiche de paie complÃ¨te.\nParamÃ¨tres :\nnom : nom de lâ€™employÃ© (String) tauxHoraire : taux horaire (double) heuresTravaillees : heures travaillÃ©es (int) anciennete : annÃ©es dâ€™anciennetÃ© (int) performance : note de performance (int) Retour : void\nCalculs Ã  effectuer et afficher :\nCalculer le salaire brut (utiliser calculerSalaireBrut) Calculer le nombre dâ€™heures supplÃ©mentaires : max(0, heuresTravaillees - 151.67) Calculer les cotisations (utiliser calculerCotisations) Calculer le salaire net avant impÃ´t : salaireBrut - cotisations Calculer le bonus mensuel (utiliser calculerBonus) Calculer le salaire annuel net : (salaire net + bonus) Ã— 12 Calculer lâ€™impÃ´t annuel estimÃ© (utiliser calculerImpot) Calculer lâ€™impÃ´t mensuel : impÃ´t annuel / 12 Calculer le salaire net mensuel final : salaire net + bonus - impÃ´t mensuel Format dâ€™affichage :\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•— â•‘ FICHE DE PAIE â•‘ â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• EmployÃ© : Jean Dupont PÃ©riode : Janvier 2026 --- DÃ‰TAILS DES HEURES --- Heures travaillÃ©es : 170h Heures supplÃ©mentaires : 18.33h Taux horaire : 15.50â‚¬ --- CALCUL DU SALAIRE --- Salaire brut : 2618.74â‚¬ Cotisations sociales (22%) : 576.12â‚¬ Salaire net avant impÃ´t : 2042.62â‚¬ Bonus de performance : 131.00â‚¬ Salaire net avant impÃ´t : 2173.62â‚¬ --- IMPÃ”TS (estimation annuelle) --- Salaire annuel net : 26083.44â‚¬ ImpÃ´t annuel estimÃ© : 1765.17â‚¬ ImpÃ´t mensuel : 147.10â‚¬ --- NET Ã€ PAYER --- Salaire net mensuel : 2026.52â‚¬ 6. MÃ©thode main But : Tester le systÃ¨me avec plusieurs cas.\nTests Ã  effectuer :\nCas 1 : EmployÃ© standard sans heures sup Cas 2 : EmployÃ© avec heures supplÃ©mentaires Cas 3 : EmployÃ© avec haute performance et anciennetÃ© Cas 4 : EmployÃ© avec basse performance (pas de bonus) âœ… CritÃ¨res de validation Les heures supplÃ©mentaires sont calculÃ©es avec le bon taux (25%) Les cotisations sont correctement appliquÃ©es (22%) Le systÃ¨me de tranches dâ€™imposition fonctionne correctement Le bonus est calculÃ© selon les rÃ¨gles (performance et anciennetÃ©) La fiche de paie affiche tous les Ã©lÃ©ments demandÃ©s Les montants sont arrondis Ã  2 dÃ©cimales ğŸ’¡ Conseils Testez chaque mÃ©thode sÃ©parÃ©ment avec des valeurs simples Utilisez System.out.printf(\"%.2fâ‚¬%n\", montant) pour lâ€™affichage Faites attention aux conversions int/double dans les calculs VÃ©rifiez les cas limites (0 heures sup, performance minimale, etc.) ğŸ² Projet 3 : Jeu de Devinette AvancÃ© ğŸ“‹ Contexte CrÃ©ez un jeu oÃ¹ lâ€™ordinateur gÃ©nÃ¨re un nombre alÃ©atoire et le joueur doit le deviner. Le jeu donne des indices de proximitÃ© et calcule un score selon la performance.\nğŸ¯ Objectifs pÃ©dagogiques Utilisation de la classe Random Boucles while pour le jeu Conditions multiples pour les indices Interaction avec lâ€™utilisateur (Scanner) Calcul de scores ğŸ“ Instructions dÃ©taillÃ©es CrÃ©ez une classe JeuDevinette avec les mÃ©thodes suivantes :\n1. MÃ©thode genererNombre But : GÃ©nÃ©rer un nombre alÃ©atoire dans un intervalle.\nParamÃ¨tres :\nmin : valeur minimale (int) max : valeur maximale (int) Retour : Nombre alÃ©atoire entre min et max inclus (int)\nAlgorithme :\nRandom random = new Random(); // GÃ©nÃ©rer un nombre entre 0 et (max-min) // Ajouter min pour obtenir un nombre entre min et max Formule : random.nextInt(max - min + 1) + min\n2. MÃ©thode calculerDifference But : Calculer la diffÃ©rence absolue entre deux nombres.\nParamÃ¨tres :\nnombre1 : premier nombre (int) nombre2 : deuxiÃ¨me nombre (int) Retour : DiffÃ©rence absolue (int)\nFormule : Math.abs(nombre1 - nombre2)\n3. MÃ©thode donnerIndice But : Fournir un indice textuel selon la proximitÃ© de la proposition.\nParamÃ¨tres :\nproposition : nombre proposÃ© par le joueur (int) secret : nombre Ã  deviner (int) Retour : Message dâ€™indice (String)\nRÃ¨gles :\nCalculer la diffÃ©rence avec calculerDifference Selon la diffÃ©rence : \u003c= 5 : â€œğŸ”¥ BrÃ»lant ! Vous Ãªtes trÃ¨s proche !â€ \u003c= 10 : â€œâ™¨ï¸ Chaud ! Vous approchez !â€ \u003c= 20 : â€œğŸŒ¡ï¸ TiÃ¨deâ€¦ continuez dans cette directionâ€ 20 : â€œâ„ï¸ Froid ! Vous Ãªtes loinâ€\nBonus : Ajouter aussi si le nombre est trop grand ou trop petit :\nâ€œLe nombre secret est plus petitâ€ â€œLe nombre secret est plus grandâ€ 4. MÃ©thode calculerScore But : Calculer le score final selon le nombre dâ€™essais et la difficultÃ©.\nParamÃ¨tres :\nnombreEssais : nombre de tentatives utilisÃ©es (int) difficulte : niveau choisi : â€œFacileâ€, â€œMoyenâ€ ou â€œDifficileâ€ (String) Retour : Score (entre 0 et 1000+) (int)\nFormule de base : 1000 - (nombreEssais Ã— 50)\nMultiplicateurs de difficultÃ© :\nâ€œFacileâ€ : Ã—1 (pas de bonus) â€œMoyenâ€ : Ã—1.5 â€œDifficileâ€ : Ã—2 Score minimum : 0 (ne peut pas Ãªtre nÃ©gatif)\nExemple :\n8 essais en mode Difficile Score de base : 1000 - (8 Ã— 50) = 600 Avec multiplicateur Ã—2 : 600 Ã— 2 = 1200 Algorithme :\nscoreBase = 1000 - (nombreEssais Ã— 50) Si scoreBase \u003c 0 alors scoreBase = 0 Selon difficulte: \"Facile\" : multiplicateur = 1.0 \"Moyen\" : multiplicateur = 1.5 \"Difficile\" : multiplicateur = 2.0 scoreFinal = scoreBase Ã— multiplicateur 5. MÃ©thode jouerPartie But : GÃ©rer une partie complÃ¨te du jeu.\nParamÃ¨tres :\ndifficulte : niveau choisi (â€œFacileâ€, â€œMoyenâ€, â€œDifficileâ€) (String) Retour : Score obtenu (int)\nRÃ¨gles selon la difficultÃ© :\nFacile : nombre entre 1 et 50 Moyen : nombre entre 1 et 100 Difficile : nombre entre 1 et 200 Algorithme dÃ©taillÃ© :\nDÃ©terminer min et max selon la difficultÃ©\nGÃ©nÃ©rer le nombre secret avec genererNombre\nInitialiser le compteur dâ€™essais Ã  0\nCrÃ©er un Scanner pour lire les entrÃ©es\nBoucle de jeu (tant que pas trouvÃ©) :\nIncrÃ©menter le compteur dâ€™essais\nAfficher â€œEssai #X - Entrez un nombre :â€\nLire la proposition du joueur\nSi proposition == secret :\nAfficher â€œğŸ‰ Bravo ! Vous avez trouvÃ© en X essais !â€ Sortir de la boucle Sinon :\nAppeler donnerIndice et afficher le message Continuer la boucle Calculer le score avec calculerScore\nAfficher â€œScore obtenu : X pointsâ€\nRetourner le score\n6. MÃ©thode afficherMenu But : Afficher le menu de sÃ©lection de difficultÃ©.\nRetour : void\nAffichage :\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•— â•‘ JEU DE DEVINETTE ğŸ² â•‘ â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• Choisissez votre difficultÃ© : 1. ğŸ˜Š Facile (1-50) 2. ğŸ¤” Moyen (1-100) 3. ğŸ˜ˆ Difficile (1-200) 4. ğŸšª Quitter Votre choix : 7. MÃ©thode main But : GÃ©rer le programme principal avec menu et statistiques.\nAlgorithme :\nInitialiser : - scoreTotal = 0 - nombreParties = 0 - Scanner scanner Boucle principale (continuer = true) : 1. Afficher le menu 2. Lire le choix du joueur 3. Selon le choix : - 1 : jouer en mode Facile - 2 : jouer en mode Moyen - 3 : jouer en mode Difficile - 4 : sortir de la boucle - Autre : afficher \"Choix invalide\" 4. Si une partie a Ã©tÃ© jouÃ©e : - Ajouter le score Ã  scoreTotal - IncrÃ©menter nombreParties - Demander \"Voulez-vous rejouer ? (o/n)\" - Lire la rÃ©ponse - Si \"n\" : continuer = false AprÃ¨s la boucle : Afficher les statistiques finales : - Nombre de parties jouÃ©es - Score total - Score moyen (si parties \u003e 0) - Meilleur type de partie jouÃ©e âœ… CritÃ¨res de validation Le nombre secret est bien gÃ©nÃ©rÃ© alÃ©atoirement Les indices de proximitÃ© sont corrects Le score est calculÃ© selon la formule avec multiplicateur Le jeu se termine quand le joueur trouve Les statistiques finales sont correctes Le menu fonctionne avec tous les choix Le joueur peut rejouer ou quitter ğŸ’¡ Conseils Testez dâ€™abord avec un nombre fixe au lieu dâ€™alÃ©atoire pour dÃ©boguer Ajoutez des System.out.println pour suivre la progression GÃ©rez les cas oÃ¹ lâ€™utilisateur entre des lettres au lieu de nombres (try-catch) AmÃ©liorez lâ€™expÃ©rience avec des emojis et des couleurs ANSI ğŸ Extensions possibles Ajouter un nombre maximum de tentatives CrÃ©er un mode â€œduelâ€ (2 joueurs) Sauvegarder les meilleurs scores dans un fichier Ajouter un mode â€œExpertâ€ avec intervalle trÃ¨s large ğŸ“… Projet 4 : Calculateur de Dates ğŸ“‹ Contexte CrÃ©ez un systÃ¨me complet de manipulation de dates sans utiliser les classes Java de dates (LocalDate, etc.). Tout doit Ãªtre calculÃ© manuellement avec des algorithmes.\nğŸ¯ Objectifs pÃ©dagogiques Algorithmes mathÃ©matiques Conditions complexes imbriquÃ©es Manipulation de nombres Validation de donnÃ©es ğŸ“ Instructions dÃ©taillÃ©es CrÃ©ez une classe CalculateurDates avec les mÃ©thodes suivantes :\n1. MÃ©thode estBissextile But : DÃ©terminer si une annÃ©e est bissextile.\nParamÃ¨tres :\nannee : annÃ©e Ã  tester (int) Retour : true si bissextile, false sinon (boolean)\nRÃ¨gle officielle : Une annÃ©e est bissextile si :\nElle est divisible par 4 ET (non divisible par 100 OU divisible par 400) Exemples :\n2024 : divisible par 4 et pas par 100 â†’ bissextile 2000 : divisible par 400 â†’ bissextile 1900 : divisible par 100 mais pas par 400 â†’ non bissextile 2023 : pas divisible par 4 â†’ non bissextile Formule logique :\n(annee % 4 == 0) \u0026\u0026 ((annee % 100 != 0) || (annee % 400 == 0)) 2. MÃ©thode nombreJoursDansMois But : Retourner le nombre de jours dans un mois donnÃ©.\nParamÃ¨tres :\nmois : numÃ©ro du mois (1-12) (int) annee : annÃ©e (pour gÃ©rer fÃ©vrier) (int) Retour : Nombre de jours (int)\nRÃ¨gles :\nJanvier (1), Mars (3), Mai (5), Juillet (7), AoÃ»t (8), Octobre (10), DÃ©cembre (12) : 31 jours Avril (4), Juin (6), Septembre (9), Novembre (11) : 30 jours FÃ©vrier (2) : 28 jours (29 si annÃ©e bissextile) Algorithme :\nSi mois == 2: Si estBissextile(annee): retourner 29 Sinon: retourner 28 Si mois == 4 ou 6 ou 9 ou 11: retourner 30 Sinon: retourner 31 3. MÃ©thode dateValide But : VÃ©rifier si une date est valide.\nParamÃ¨tres :\njour : jour (1-31) (int) mois : mois (1-12) (int) annee : annÃ©e (int) Retour : true si valide, false sinon (boolean)\nVÃ©rifications :\nLe mois doit Ãªtre entre 1 et 12 Lâ€™annÃ©e doit Ãªtre positive (\u003e 0) Le jour doit Ãªtre entre 1 et le nombre de jours du mois (utiliser nombreJoursDansMois) Exemples :\n29/02/2024 : valide (annÃ©e bissextile) 29/02/2023 : invalide (pas bissextile) 31/04/2024 : invalide (avril a 30 jours) 15/13/2024 : invalide (mois 13 nâ€™existe pas) 4. MÃ©thode jourDeLannee But : Calculer le numÃ©ro du jour dans lâ€™annÃ©e (1-366).\nParamÃ¨tres :\njour, mois, annee : la date (int) Retour : NumÃ©ro du jour (1er janvier = 1) (int)\nAlgorithme :\nVÃ©rifier que la date est valide Initialiser total = 0 Pour chaque mois avant le mois actuel : Ajouter le nombre de jours de ce mois au total Ajouter le jour du mois actuel Retourner le total Exemple : 15 mars 2024\nJanvier : 31 jours FÃ©vrier : 29 jours (bissextile) Mars : 15 jours Total : 31 + 29 + 15 = 75Ã¨me jour de lâ€™annÃ©e 5. MÃ©thode jourDeLaSemaine But : DÃ©terminer quel jour de la semaine correspond Ã  une date.\nParamÃ¨tres :\njour, mois, annee : la date (int) Retour : Nom du jour (â€œLundiâ€, â€œMardiâ€, etc.) (String)\nAlgorithme simplifiÃ© (formule de Zeller modifiÃ©e) :\nPour simplifier, utilisez cette formule :\nSi mois \u003c 3: mois = mois + 12 annee = annee - 1 q = jour m = mois k = annee % 100 j = annee / 100 h = (q + (13*(m+1))/5 + k + k/4 + j/4 - 2*j) % 7 Convertir h en jour :\nh = 0 : Samedi h = 1 : Dimanche h = 2 : Lundi h = 3 : Mardi h = 4 : Mercredi h = 5 : Jeudi h = 6 : Vendredi Alternative plus simple : Vous pouvez aussi crÃ©er un tableau de rÃ©fÃ©rence avec des dates connues et calculer la diffÃ©rence en jours.\n6. MÃ©thode calculerAge But : Calculer lâ€™Ã¢ge exact dâ€™une personne.\nParamÃ¨tres :\njourNaissance, moisNaissance, anneeNaissance : date de naissance jourActuel, moisActuel, anneeActuel : date actuelle Retour : Ã‚ge en annÃ©es (int)\nAlgorithme :\nage = anneeActuel - anneeNaissance Si moisActuel \u003c moisNaissance: age = age - 1 Sinon si moisActuel == moisNaissance et jourActuel \u003c jourNaissance: age = age - 1 retourner age Exemple :\nNÃ© le 15/03/2000 Date actuelle : 28/01/2026 DiffÃ©rence dâ€™annÃ©es : 2026 - 2000 = 26 Mais le mois (01) est avant mars (03) â†’ encore 25 ans Ã‚ge : 25 ans 7. MÃ©thode determinerSaison But : DÃ©terminer la saison selon la date.\nParamÃ¨tres :\njour, mois : la date (sans lâ€™annÃ©e) (int) Retour : Nom de la saison (String)\nRÃ¨gles (hÃ©misphÃ¨re nord) :\nPrintemps : du 21 mars au 20 juin Ã‰tÃ© : du 21 juin au 20 septembre Automne : du 21 septembre au 20 dÃ©cembre Hiver : du 21 dÃ©cembre au 20 mars Algorithme :\nSi (mois == 3 et jour \u003e= 21) ou (mois == 4 ou 5) ou (mois == 6 et jour \u003c 21): retourner \"Printemps\" Si (mois == 6 et jour \u003e= 21) ou (mois == 7 ou 8) ou (mois == 9 et jour \u003c 21): retourner \"Ã‰tÃ©\" Si (mois == 9 et jour \u003e= 21) ou (mois == 10 ou 11) ou (mois == 12 et jour \u003c 21): retourner \"Automne\" Sinon: retourner \"Hiver\" 8. MÃ©thode differenceEnJours But : Calculer le nombre de jours entre deux dates.\nParamÃ¨tres :\nDate 1 : jour1, mois1, annee1 Date 2 : jour2, mois2, annee2 Retour : Nombre de jours de diffÃ©rence (int)\nAlgorithme (mÃ©thode simplifiÃ©e) :\nVÃ©rifier que les deux dates sont valides Convertir chaque date en â€œnombre de jours depuis une rÃ©fÃ©renceâ€ Par exemple, depuis lâ€™an 1 ou depuis lâ€™an 2000 Calculer la diffÃ©rence absolue Pour convertir une date en jours depuis lâ€™an 2000 :\njoursDepuis2000 = 0 Pour chaque annÃ©e de 2000 Ã  (annee - 1): Si bissextile: joursDepuis2000 += 366 Sinon: joursDepuis2000 += 365 joursDepuis2000 += jourDeLannee(jour, mois, annee) Faire ce calcul pour les deux dates Retourner la diffÃ©rence absolue 9. MÃ©thode afficherRapportDate But : Afficher un rapport complet dâ€™analyse dâ€™une date.\nParamÃ¨tres :\njour, mois, annee : la date Ã  analyser (int) Retour : void\nInformations Ã  afficher :\nLa date au format â€œDD/MM/YYYYâ€ Si la date est valide ou non Le jour de la semaine Le numÃ©ro du jour dans lâ€™annÃ©e La saison Si lâ€™annÃ©e est bissextile Nombre de jours restants dans lâ€™annÃ©e Nombre de jours dans le mois Combien de jours jusquâ€™Ã  la fin du mois Format attendu :\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•— â•‘ ANALYSE DE DATE COMPLÃˆTE â•‘ â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• Date : 15/08/2024 Jour de la semaine : Jeudi Jour de l'annÃ©e : 228/366 Saison : Ã‰tÃ© Informations sur l'annÃ©e : - AnnÃ©e bissextile : Oui - Jours restants : 138 Informations sur le mois : - AoÃ»t a 31 jours - Jours restants ce mois : 16 10. MÃ©thode main But : Tester toutes les fonctionnalitÃ©s.\nTests Ã  effectuer :\nAfficher le rapport pour plusieurs dates Tester calculerAge avec diffÃ©rentes dates de naissance Tester differenceEnJours entre deux dates Tester des dates invalides Tester des annÃ©es bissextiles et non-bissextiles âœ… CritÃ¨res de validation La dÃ©tection dâ€™annÃ©e bissextile fonctionne correctement Le nombre de jours par mois est correct (y compris fÃ©vrier) La validation de date dÃ©tecte toutes les erreurs Le calcul du jour de lâ€™annÃ©e est prÃ©cis Le jour de la semaine est correct Le calcul dâ€™Ã¢ge fonctionne mÃªme pour les dates limites La diffÃ©rence entre dates est exacte Les saisons sont correctement dÃ©terminÃ©es ğŸ’¡ Conseils Testez dâ€™abord les annÃ©es bissextiles : 2000, 2024, 1900, 2100 Testez fÃ©vrier : 28/02 et 29/02 pour annÃ©es bissextiles et non-bissextiles Testez des dates limites : 31/12, 1/1, 29/02 VÃ©rifiez les calculs avec un calendrier rÃ©el ğŸ Extensions possibles Ajouter la conversion entre calendriers (grÃ©gorien, julien) Calculer le nombre de jours ouvrables entre deux dates Trouver les dates de PÃ¢ques (algorithme de Gauss) Calculer les jours fÃ©riÃ©s ğŸ¦ Projet 5 : Simulateur de Compte Bancaire ğŸ“‹ Contexte DÃ©veloppez un systÃ¨me complet de simulation de compte bancaire avec transactions, dÃ©couvert, intÃ©rÃªts, frais et projections dâ€™Ã©pargne.\nğŸ¯ Objectifs pÃ©dagogiques Gestion dâ€™Ã©tat (solde) Validation de transactions Calculs financiers Simulation temporelle ğŸ“ Instructions dÃ©taillÃ©es CrÃ©ez une classe CompteBancaire avec les mÃ©thodes suivantes :\n1. MÃ©thode effectuerDepot But : Effectuer un dÃ©pÃ´t sur le compte.\nParamÃ¨tres :\nsoldeActuel : solde avant lâ€™opÃ©ration (double) montant : montant Ã  dÃ©poser (double) Retour : Nouveau solde aprÃ¨s dÃ©pÃ´t, ou -1 si invalide (double)\nRÃ¨gles de validation :\nLe montant doit Ãªtre strictement positif (\u003e 0) Si invalide, retourner -1 et ne pas modifier le solde Algorithme :\nSi montant \u003c= 0: Afficher \"Erreur : montant invalide\" Retourner -1 nouveauSolde = soldeActuel + montant Afficher \"DÃ©pÃ´t de Xâ‚¬ effectuÃ©. Nouveau solde : Yâ‚¬\" Retourner nouveauSolde 2. MÃ©thode effectuerRetrait But : Effectuer un retrait avec gestion du dÃ©couvert.\nParamÃ¨tres :\nsoldeActuel : solde actuel (double) montant : montant Ã  retirer (double) decouvertAutorise : montant de dÃ©couvert maximum (double) Retour : Nouveau solde, ou -1 si impossible (double)\nRÃ¨gles :\nLe montant doit Ãªtre positif Le solde aprÃ¨s retrait doit rester \u003e= -decouvertAutorise Si impossible, retourner -1 Exemple :\nSolde actuel : 100â‚¬ DÃ©couvert autorisÃ© : 200â‚¬ Retrait possible jusquâ€™Ã  : 100 + 200 = 300â‚¬ Si retrait de 250â‚¬ : possible (nouveau solde = -150â‚¬) Si retrait de 350â‚¬ : impossible Algorithme :\nSi montant \u003c= 0: Retourner -1 nouveauSolde = soldeActuel - montant Si nouveauSolde \u003c -decouvertAutorise: Afficher \"Erreur : dÃ©couvert dÃ©passÃ©\" Retourner -1 Si nouveauSolde \u003c 0: Afficher \"Attention : vous Ãªtes Ã  dÃ©couvert\" Afficher \"Retrait de Xâ‚¬ effectuÃ©\" Retourner nouveauSolde 3. MÃ©thode calculerInterets But : Calculer les intÃ©rÃªts mensuels pour un solde crÃ©diteur.\nParamÃ¨tres :\nsolde : solde du compte (double) tauxAnnuel : taux dâ€™intÃ©rÃªt annuel en pourcentage (double) Retour : Montant des intÃ©rÃªts (double)\nRÃ¨gles :\nLes intÃ©rÃªts ne sont calculÃ©s que si le solde est positif Si solde \u003c= 0 : retourner 0 Formule mensuelle : solde Ã— (tauxAnnuel / 100) / 12 Exemple :\nSolde : 1000â‚¬ Taux annuel : 2% IntÃ©rÃªts mensuels : 1000 Ã— (2 / 100) / 12 = 1.67â‚¬ 4. MÃ©thode calculerFraisDecouvert But : Calculer les frais appliquÃ©s en cas de dÃ©couvert.\nParamÃ¨tres :\nsolde : solde actuel (double) Retour : Montant des frais (double)\nRÃ¨gle :\nSi solde \u003c 0 : frais de 8â‚¬ Sinon : 0â‚¬ Note : Dans une vraie banque, ce serait des frais par jour de dÃ©couvert, mais on simplifie ici.\n5. MÃ©thode determinerTypeCompte But : DÃ©terminer le type de compte selon le solde moyen.\nParamÃ¨tres :\nsoldeMoyen : solde moyen sur la pÃ©riode (double) Retour : Type de compte (String)\nClassification :\n= 5000â‚¬ : â€œPremiumâ€\n= 2000â‚¬ : â€œGoldâ€\n\u003c 2000â‚¬ : â€œStandardâ€ 6. MÃ©thode calculerFraisGestion But : Calculer les frais de gestion mensuels.\nParamÃ¨tres :\ntypeCompte : type du compte (String) nombreTransactions : nombre de transactions du mois (int) Retour : Montant des frais (double)\nGrille tarifaire :\nPremium :\nGratuit (toutes transactions) Gold :\nGratuit si \u003c= 20 transactions 5â‚¬ si \u003e 20 transactions Standard :\n10â‚¬ de frais de base 0,50â‚¬ par transaction au-delÃ  de 10 transactions gratuites Exemples :\nStandard avec 15 transactions : 10 + (5 Ã— 0.50) = 12.50â‚¬ Standard avec 8 transactions : 10â‚¬ Gold avec 25 transactions : 5â‚¬ Premium avec 100 transactions : 0â‚¬ 7. MÃ©thode virementPossible But : VÃ©rifier si un virement est rÃ©alisable.\nParamÃ¨tres :\nsoldeActuel : solde actuel (double) montant : montant du virement (double) decouvertAutorise : dÃ©couvert maximum (double) Retour : true si possible, false sinon (boolean)\nCondition : soldeActuel - montant \u003e= -decouvertAutorise\n8. MÃ©thode simulerMois But : Simuler un mois complet dâ€™opÃ©rations bancaires.\nParamÃ¨tres :\nsoldeInitial : solde au dÃ©but du mois (double) depots : tableau des dÃ©pÃ´ts du mois (double[]) retraits : tableau des retraits du mois (double[]) tauxInteret : taux annuel (double) decouvertAutorise : dÃ©couvert maximum (double) Retour : void (affiche les rÃ©sultats)\nAlgorithme dÃ©taillÃ© :\n1. Initialiser : - solde = soldeInitial - nombreTransactions = 0 - sommePositions = 0 (pour calculer le solde moyen) - compteurJours = 30 2. Afficher l'en-tÃªte \"=== SIMULATION MENSUELLE ===\" \"Solde initial : Xâ‚¬\" 3. Traiter tous les dÃ©pÃ´ts : Pour chaque dÃ©pÃ´t dans le tableau : - nouveauSolde = effectuerDepot(solde, dÃ©pÃ´t) - Si valide : solde = nouveauSolde - nombreTransactions++ - sommePositions += solde 4. Traiter tous les retraits : Pour chaque retrait dans le tableau : - nouveauSolde = effectuerRetrait(solde, retrait, dÃ©couvert) - Si valide : solde = nouveauSolde - nombreTransactions++ - sommePositions += solde 5. Calculer le solde moyen : soldeMoyen = sommePositions / (nombreTransactions + 1) 6. DÃ©terminer le type de compte : typeCompte = determinerTypeCompte(soldeMoyen) 7. Appliquer intÃ©rÃªts ou frais de dÃ©couvert : Si solde \u003e 0 : - interets = calculerInterets(solde, tauxInteret) - solde += interets - Afficher \"IntÃ©rÃªts crÃ©diteurs : +Xâ‚¬\" Sinon : - frais = calculerFraisDecouvert(solde) - solde -= frais - Afficher \"Frais de dÃ©couvert : -Xâ‚¬\" 8. Appliquer les frais de gestion : fraisGestion = calculerFraisGestion(typeCompte, nombreTransactions) solde -= fraisGestion Afficher \"Frais de gestion : -Xâ‚¬\" 9. Afficher le rÃ©capitulatif : - Type de compte - Nombre de transactions - Solde moyen - Solde final Format d'affichage : \"\"\" === SIMULATION MENSUELLE === Solde initial : 1000.00â‚¬ --- OPÃ‰RATIONS DU MOIS --- DÃ©pÃ´t de 500.00â‚¬ effectuÃ©. Nouveau solde : 1500.00â‚¬ DÃ©pÃ´t de 300.00â‚¬ effectuÃ©. Nouveau solde : 1800.00â‚¬ ... Retrait de 150.00â‚¬ effectuÃ©. Nouveau solde : 1650.00â‚¬ ... --- FIN DE MOIS --- IntÃ©rÃªts crÃ©diteurs : +1.67â‚¬ Frais de gestion (Standard) : -10.00â‚¬ === RÃ‰CAPITULATIF === Type de compte : Standard Solde moyen du mois : 1450.00â‚¬ Nombre de transactions : 7 Solde final : 1641.67â‚¬ \"\"\" 9. MÃ©thode projeterEpargne But : Calculer le solde futur avec Ã©pargne rÃ©guliÃ¨re et intÃ©rÃªts composÃ©s.\nParamÃ¨tres :\nsoldeInitial : solde de dÃ©part (double) depotMensuel : montant Ã©pargnÃ© chaque mois (double) tauxInteret : taux annuel (double) nombreMois : durÃ©e de la projection (int) Retour : Solde projetÃ© (double)\nAlgorithme :\nsolde = soldeInitial Pour i de 1 Ã  nombreMois : 1. Ajouter le dÃ©pÃ´t mensuel : solde += depotMensuel 2. Calculer les intÃ©rÃªts du mois : interets = calculerInterets(solde, tauxInteret) solde += interets 3. (Optionnel) Afficher l'Ã©tat aprÃ¨s chaque mois : \"Mois X : +depotMensuelâ‚¬ +interetsâ‚¬ â†’ soldeâ‚¬\" Retourner solde Exemple de calcul manuel :\nSolde initial : 1000â‚¬ DÃ©pÃ´t mensuel : 200â‚¬ Taux annuel : 2% DurÃ©e : 3 mois Mois 1 :\nSolde aprÃ¨s dÃ©pÃ´t : 1000 + 200 = 1200â‚¬ IntÃ©rÃªts : 1200 Ã— 0.02 / 12 = 2â‚¬ Nouveau solde : 1202â‚¬ Mois 2 :\nSolde aprÃ¨s dÃ©pÃ´t : 1202 + 200 = 1402â‚¬ IntÃ©rÃªts : 1402 Ã— 0.02 / 12 = 2.34â‚¬ Nouveau solde : 1404.34â‚¬ Et ainsi de suiteâ€¦\n10. MÃ©thode main But : Tester toutes les fonctionnalitÃ©s avec des scÃ©narios rÃ©alistes.\nScÃ©narios Ã  tester :\nTest 1 : Simulation mensuelle normale\ndouble soldeInitial = 1000.0; double[] depots = {500.0, 300.0, 200.0}; double[] retraits = {150.0, 80.0, 200.0, 50.0}; double tauxInteret = 2.0; double decouvertAutorise = 200.0; simulerMois(soldeInitial, depots, retraits, tauxInteret, decouvertAutorise); Test 2 : Situation de dÃ©couvert\ndouble soldeInitial = 100.0; double[] depots = {}; double[] retraits = {50.0, 80.0, 100.0}; // Solde final devrait Ãªtre nÃ©gatif avec frais Test 3 : Projection dâ€™Ã©pargne\ndouble soldeFutur = projeterEpargne(1000, 200, 2.0, 12); System.out.println(\"AprÃ¨s 12 mois : \" + soldeFutur + \"â‚¬\"); Test 4 : Tests des types de compte\nSystem.out.println(\"Solde 1500â‚¬ â†’ \" + determinerTypeCompte(1500)); System.out.println(\"Solde 3000â‚¬ â†’ \" + determinerTypeCompte(3000)); System.out.println(\"Solde 6000â‚¬ â†’ \" + determinerTypeCompte(6000)); âœ… CritÃ¨res de validation Les dÃ©pÃ´ts et retraits valident correctement les montants Le dÃ©couvert est bien gÃ©rÃ© (pas de dÃ©passement) Les intÃ©rÃªts sont calculÃ©s uniquement sur solde positif Les frais de dÃ©couvert sâ€™appliquent correctement La classification des comptes fonctionne Les frais de gestion sont calculÃ©s selon les bonnes rÃ¨gles La projection dâ€™Ã©pargne inclut les intÃ©rÃªts composÃ©s Tous les montants sont affichÃ©s avec 2 dÃ©cimales ğŸ’¡ Conseils Utilisez System.out.printf(\"%.2fâ‚¬%n\", montant) pour formater Testez dâ€™abord chaque mÃ©thode individuellement VÃ©rifiez les cas limites (solde Ã  0, dÃ©couvert au maximum, etc.) Ajoutez des messages clairs pour suivre les opÃ©rations ğŸ Extensions possibles Ajouter un historique des transactions (tableau ou ArrayList) CrÃ©er une mÃ©thode pour gÃ©nÃ©rer un relevÃ© PDF ImplÃ©menter des virements entre comptes Ajouter des notifications de seuil de solde CrÃ©er un systÃ¨me de budget mensuel avec alertes ğŸ¯ Projet 6 : Analyseur de Texte ğŸ“‹ Contexte CrÃ©ez un outil dâ€™analyse textuelle complet qui peut compter les mots, analyser la structure, calculer des statistiques et transformer le texte.\nğŸ¯ Objectifs pÃ©dagogiques Manipulation de chaÃ®nes de caractÃ¨res (String) MÃ©thodes de String (split, substring, charAt, length, etc.) Boucles sur les caractÃ¨res Conditions pour classification ğŸ“ Instructions dÃ©taillÃ©es CrÃ©ez une classe AnalyseurTexte avec les mÃ©thodes suivantes :\n1. MÃ©thode compterMots But : Compter le nombre de mots dans un texte.\nParamÃ¨tres :\ntexte : texte Ã  analyser (String) Retour : Nombre de mots (int)\nDÃ©finition dâ€™un mot : SÃ©quence de caractÃ¨res sÃ©parÃ©e par des espaces\nAlgorithme :\n1. Supprimer les espaces au dÃ©but et Ã  la fin : texte.trim() 2. Si le texte est vide : retourner 0 3. DÃ©couper le texte en mots : String[] mots = texte.split(\"\\\\s+\") (\\\\s+ signifie : un ou plusieurs espaces) 4. Retourner la longueur du tableau de mots Exemples :\nâ€œBonjour le mondeâ€ â†’ 3 mots â€œJava est gÃ©nialâ€ â†’ 3 mots (espaces multiples) \"\" â†’ 0 mots \" \" â†’ 0 mots 2. MÃ©thode compterPhrases But : Compter le nombre de phrases dans un texte.\nParamÃ¨tres :\ntexte : texte Ã  analyser (String) Retour : Nombre de phrases (int)\nDÃ©finition : Une phrase se termine par . ou ! ou ?\nAlgorithme :\ncompteur = 0 Pour chaque caractÃ¨re c du texte : Si c == '.' ou c == '!' ou c == '?' : compteur++ Retourner compteur Alternative avec mÃ©thode String :\nint compteur = 0; for (int i = 0; i \u003c texte.length(); i++) { char c = texte.charAt(i); if (c == '.' || c == '!' || c == '?') { compteur++; } } return compteur; 3. MÃ©thode compterVoyelles But : Compter le nombre de voyelles dans un texte.\nParamÃ¨tres :\ntexte : texte Ã  analyser (String) Retour : Nombre de voyelles (int)\nVoyelles : a, e, i, o, u, y (et leurs majuscules)\nAlgorithme :\n1. Convertir le texte en minuscules : texte.toLowerCase() 2. Initialiser compteur = 0 3. Pour chaque caractÃ¨re c : Si c est dans \"aeiouy\" : compteur++ 4. Retourner compteur MÃ©thode pour vÃ©rifier si câ€™est une voyelle :\nboolean estVoyelle(char c) { c = Character.toLowerCase(c); return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'y'; } 4. MÃ©thode compterConsonnes But : Compter le nombre de consonnes (lettres qui ne sont pas des voyelles).\nParamÃ¨tres :\ntexte : texte Ã  analyser (String) Retour : Nombre de consonnes (int)\nAlgorithme :\ncompteur = 0 Pour chaque caractÃ¨re c : Si c est une lettre ET ce n'est pas une voyelle : compteur++ Retourner compteur VÃ©rifier si câ€™est une lettre :\nCharacter.isLetter(c) 5. MÃ©thode longueurMoyenneMots But : Calculer la longueur moyenne des mots.\nParamÃ¨tres :\ntexte : texte Ã  analyser (String) Retour : Longueur moyenne (double)\nAlgorithme :\n1. DÃ©couper le texte en mots 2. Si aucun mot : retourner 0.0 3. Initialiser somme = 0 4. Pour chaque mot : somme += longueur du mot (mot.length()) 5. Retourner somme / nombre de mots Exemple :\nâ€œBonjour le mondeâ€ â†’ (7 + 2 + 5) / 3 = 4.67 6. MÃ©thode motLePlusLong But : Trouver le mot le plus long dans le texte.\nParamÃ¨tres :\ntexte : texte Ã  analyser (String) Retour : Le mot le plus long (String)\nAlgorithme :\n1. DÃ©couper le texte en mots 2. Si aucun mot : retourner \"\" 3. Initialiser : motMax = premier mot longueurMax = longueur du premier mot 4. Pour chaque mot suivant : Si longueur du mot \u003e longueurMax : motMax = ce mot longueurMax = longueur de ce mot 5. Retourner motMax En cas dâ€™Ã©galitÃ© : Retourner le premier trouvÃ©\n7. MÃ©thode compterOccurrences But : Compter combien de fois un mot spÃ©cifique apparaÃ®t (insensible Ã  la casse).\nParamÃ¨tres :\ntexte : texte Ã  analyser (String) motCherche : mot Ã  chercher (String) Retour : Nombre dâ€™occurrences (int)\nRÃ¨gles :\nInsensible Ã  la casse (â€œJavaâ€ = â€œjavaâ€ = â€œJAVAâ€) Mot entier seulement (â€œleâ€ ne doit pas compter dans â€œManuelâ€) Algorithme :\n1. Convertir texte et motCherche en minuscules 2. DÃ©couper le texte en mots 3. Initialiser compteur = 0 4. Pour chaque mot : Si mot (en minuscules) == motCherche (en minuscules) : compteur++ 5. Retourner compteur 8. MÃ©thode calculerLisibilite But : Calculer un indice de lisibilitÃ© du texte.\nParamÃ¨tres :\ntexte : texte Ã  analyser (String) Retour : Score de lisibilitÃ© (0-100, plus Ã©levÃ© = plus facile) (double)\nFormule simplifiÃ©e (inspirÃ©e de Flesch) :\n206.835 - (1.015 Ã— mots par phrase) - (84.6 Ã— syllabes par mot) Pour simplifier : Estimez le nombre de syllabes en comptant les voyelles\nAlgorithme :\n1. Compter le nombre de mots (W) 2. Compter le nombre de phrases (S) 3. Compter le nombre de voyelles (V) comme approximation des syllabes 4. Si S == 0, retourner 0 (Ã©viter division par zÃ©ro) 5. motsParPhrase = W / S 6. syllabesParMot = V / W 7. score = 206.835 - (1.015 Ã— motsParPhrase) - (84.6 Ã— syllabesParMot) 8. Limiter le score entre 0 et 100 : Si score \u003e 100 : score = 100 Si score \u003c 0 : score = 0 9. Retourner score 9. MÃ©thode determinerNiveauComplexite But : DÃ©terminer le niveau de complexitÃ© selon lâ€™indice de lisibilitÃ©.\nParamÃ¨tres :\nindiceLisibilite : score calculÃ© (double) Retour : Niveau de complexitÃ© (String)\nClassification :\n= 90 : â€œTrÃ¨s facileâ€\n= 70 : â€œFacileâ€\n= 50 : â€œMoyenâ€\n= 30 : â€œDifficileâ€\n\u003c 30 : â€œTrÃ¨s difficileâ€ 10. MÃ©thode inverserTexte But : Inverser lâ€™ordre des mots dans le texte.\nParamÃ¨tres :\ntexte : texte Ã  inverser (String) Retour : Texte avec mots dans lâ€™ordre inverse (String)\nExemple :\nâ€œBonjour le mondeâ€ â†’ â€œmonde le Bonjourâ€ Algorithme :\n1. DÃ©couper le texte en mots 2. CrÃ©er un nouveau String vide (rÃ©sultat) 3. Parcourir le tableau de mots de la fin au dÃ©but : Pour i de (longueur-1) Ã  0 (dÃ©croissant) : Ajouter mots[i] au rÃ©sultat Ajouter un espace (sauf pour le dernier) 4. Retourner rÃ©sultat 11. MÃ©thode filtrerMotsCourts But : Supprimer tous les mots plus courts quâ€™une longueur donnÃ©e.\nParamÃ¨tres :\ntexte : texte Ã  filtrer (String) longueurMin : longueur minimale (int) Retour : Texte filtrÃ© (String)\nAlgorithme :\n1. DÃ©couper le texte en mots 2. CrÃ©er un String vide pour le rÃ©sultat 3. Pour chaque mot : Si longueur du mot \u003e= longueurMin : Ajouter le mot au rÃ©sultat Ajouter un espace 4. Retirer l'espace final (trim) 5. Retourner rÃ©sultat Exemple :\nTexte : â€œJe suis un dÃ©veloppeur Javaâ€ Longueur min : 4 RÃ©sultat : â€œsuis dÃ©veloppeur Javaâ€ 12. MÃ©thode genererRapport But : GÃ©nÃ©rer et afficher un rapport complet dâ€™analyse.\nParamÃ¨tres :\ntexte : texte Ã  analyser (String) Retour : void\nInformations Ã  afficher :\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•— â•‘ ANALYSE DE TEXTE COMPLÃˆTE â•‘ â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• TEXTE ANALYSÃ‰ : [Afficher le texte] --- STATISTIQUES GÃ‰NÃ‰RALES --- Nombre de caractÃ¨res (avec espaces) : X Nombre de caractÃ¨res (sans espaces) : Y Nombre de mots : Z Nombre de phrases : N Nombre de voyelles : V Nombre de consonnes : C --- ANALYSE DES MOTS --- Longueur moyenne des mots : X.XX caractÃ¨res Mot le plus long : \"XXXXXXXXX\" (X lettres) Mots par phrase (moyenne) : X.XX --- LISIBILITÃ‰ --- Indice de lisibilitÃ© : XX.XX Niveau de complexitÃ© : XXXXXX --- COMPOSITION --- Voyelles : XX% du texte Consonnes : XX% du texte Algorithme dÃ©taillÃ© :\n1. Afficher l'en-tÃªte 2. Afficher le texte 3. Calculer et afficher : - Longueur avec espaces : texte.length() - Longueur sans espaces : texte.replace(\" \", \"\").length() - Appeler compterMots(texte) - Appeler compterPhrases(texte) - Appeler compterVoyelles(texte) - Appeler compterConsonnes(texte) 4. Calculer et afficher : - Appeler longueurMoyenneMots(texte) - Appeler motLePlusLong(texte) - Mots par phrase : compterMots / compterPhrases 5. Calculer et afficher : - Appeler calculerLisibilite(texte) - Appeler determinerNiveauComplexite(indice) 6. Calculer les pourcentages : - % voyelles : (voyelles / longueurSansEspaces) Ã— 100 - % consonnes : (consonnes / longueurSansEspaces) Ã— 100 13. MÃ©thode main But : Tester toutes les fonctionnalitÃ©s.\nTests Ã  effectuer :\nTest 1 : Texte exemple\nString texte = \"Java est un langage de programmation orientÃ© objet. \" + \"Il est largement utilisÃ© pour dÃ©velopper des applications. \" + \"Ce langage offre une grande portabilitÃ© et robustesse.\"; genererRapport(texte); Test 2 : Transformations\nSystem.out.println(\" --- TRANSFORMATIONS ---\"); System.out.println(\"Texte inversÃ© : \" + inverserTexte(texte)); System.out.println(\"Sans mots courts (\u003c4) : \" + filtrerMotsCourts(texte, 4)); Test 3 : Occurrences\nSystem.out.println(\" --- RECHERCHE ---\"); System.out.println(\"Occurrences de 'Java' : \" + compterOccurrences(texte, \"Java\")); System.out.println(\"Occurrences de 'est' : \" + compterOccurrences(texte, \"est\")); Test 4 : Cas limites\nString texteVide = \"\"; String texteUnMot = \"Bonjour\"; String texteEspaces = \" Multiple espaces \"; // Tester avec ces cas âœ… CritÃ¨res de validation Le comptage de mots gÃ¨re les espaces multiples Les voyelles incluent y et sont insensibles Ã  la casse Les consonnes nâ€™incluent que les lettres La recherche dâ€™occurrences est insensible Ã  la casse Lâ€™inversion de texte prÃ©serve lâ€™ordre dans chaque mot Le filtrage conserve les espaces correctement Le rapport affiche toutes les informations demandÃ©es Les pourcentages sont calculÃ©s correctement ğŸ’¡ Conseils Utilisez String.split(\"\\s+\") pour gÃ©rer les espaces multiples Character.isLetter(c) est utile pour identifier les lettres Testez avec des textes en majuscules, minuscules et mixtes GÃ©rez les cas oÃ¹ le texte est vide ou null ğŸ Extensions possibles Ajouter la dÃ©tection de mots-clÃ©s (programmation, Java, etc.) CrÃ©er un correcteur orthographique basique Analyser la ponctuation utilisÃ©e DÃ©tecter les mots rÃ©pÃ©tÃ©s consÃ©cutifs GÃ©nÃ©rer un nuage de mots (afficher les mots les plus frÃ©quents) ğŸ° Projet 7 : Machine Ã  Sous (Slot Machine) ğŸ“‹ Contexte CrÃ©ez un jeu de machine Ã  sous complet avec rouleaux, symboles, calcul de gains, systÃ¨me de crÃ©dits et statistiques de session.\nğŸ¯ Objectifs pÃ©dagogiques GÃ©nÃ©ration de nombres alÃ©atoires Logique de jeu et conditions complexes Gestion dâ€™Ã©tat (crÃ©dits, tours) Interaction utilisateur avec Scanner Calculs de probabilitÃ©s et gains ğŸ“ Instructions dÃ©taillÃ©es CrÃ©ez une classe MachineASous avec les mÃ©thodes suivantes :\n1. MÃ©thode genererSymbole But : GÃ©nÃ©rer alÃ©atoirement un symbole de rouleau.\nParamÃ¨tres : Aucun\nRetour : Un symbole (String)\nSymboles disponibles :\nğŸ’ Cerise ğŸ‹ Citron ğŸŠ Orange ğŸ”” Cloche â­ Ã‰toile ğŸ’ Diamant 7 Sept Algorithme :\n1. CrÃ©er un tableau : String[] symboles = {\"ğŸ’\", \"ğŸ‹\", \"ğŸŠ\", \"ğŸ””\", \"â­\", \"ğŸ’\", \"7\"} 2. GÃ©nÃ©rer un index alÃ©atoire entre 0 et 6 : Random random = new Random(); int index = random.nextInt(7); 3. Retourner symboles[index] Note : Tous les symboles ont la mÃªme probabilitÃ© (1/7).\n2. MÃ©thode lancerRouleaux But : Lancer les trois rouleaux et retourner les symboles.\nParamÃ¨tres : Aucun\nRetour : Tableau de 3 symboles (String[])\nAlgorithme :\n1. CrÃ©er un tableau de taille 3 : String[] rouleaux = new String[3] 2. Pour i de 0 Ã  2 : rouleaux[i] = genererSymbole() 3. Retourner rouleaux 3. MÃ©thode afficherRouleaux But : Afficher les rouleaux de maniÃ¨re visuelle et attractive.\nParamÃ¨tres :\nrouleaux : tableau de 3 symboles (String[]) Retour : void\nFormat dâ€™affichage :\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•— â•‘ ğŸ’ â”‚ ğŸ‹ â”‚ ğŸŠ â•‘ â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• Algorithme :\nSystem.out.println(\"â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\"); System.out.println(\"â•‘ \" + rouleaux[0] + \" â”‚ \" + rouleaux[1] + \" â”‚ \" + rouleaux[2] + \" â•‘\"); System.out.println(\"â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\"); 4. MÃ©thode troisSymbolesIdentiques But : VÃ©rifier si les trois symboles sont identiques.\nParamÃ¨tres :\nrouleaux : tableau de 3 symboles (String[]) Retour : true si les 3 sont identiques, false sinon (boolean)\nAlgorithme :\nRetourner rouleaux[0].equals(rouleaux[1]) \u0026\u0026 rouleaux[1].equals(rouleaux[2]) Note : Utiliser .equals() et non == pour comparer des String\n5. MÃ©thode deuxSymbolesIdentiques But : VÃ©rifier si exactement 2 symboles sur 3 sont identiques.\nParamÃ¨tres :\nrouleaux : tableau de 3 symboles (String[]) Retour : true si 2 sont identiques, false sinon (boolean)\nAlgorithme :\nSi les 3 sont identiques : retourner false Si rouleaux[0] == rouleaux[1] : retourner true Si rouleaux[0] == rouleaux[2] : retourner true Si rouleaux[1] == rouleaux[2] : retourner true Sinon : retourner false 6. MÃ©thode obtenirMultiplicateur But : Retourner le multiplicateur de gain selon le symbole.\nParamÃ¨tres :\nsymbole : le symbole (String) Retour : Multiplicateur (int)\nTable des multiplicateurs :\nğŸ’ (Cerise) : Ã—2 ğŸ‹ (Citron) : Ã—3 ğŸŠ (Orange) : Ã—4 ğŸ”” (Cloche) : Ã—5 â­ (Ã‰toile) : Ã—10 ğŸ’ (Diamant) : Ã—20 7 (Sept) : Ã—50 (JACKPOT!) Algorithme avec switch :\nswitch (symbole) { case \"ğŸ’\": return 2; case \"ğŸ‹\": return 3; case \"ğŸŠ\": return 4; case \"ğŸ””\": return 5; case \"â­\": return 10; case \"ğŸ’\": return 20; case \"7\": return 50; default: return 0; } 7. MÃ©thode calculerGains But : Calculer les gains dâ€™un tour selon les rouleaux et la mise.\nParamÃ¨tres :\nrouleaux : tableau de 3 symboles (String[]) mise : montant misÃ© (double) Retour : Montant gagnÃ© (double)\nRÃ¨gles de gains :\n3 symboles identiques : mise Ã— multiplicateur du symbole 2 symboles identiques : mise Ã— 1.5 Aucune correspondance : 0 Algorithme :\nSi troisSymbolesIdentiques(rouleaux) : symbole = rouleaux[0] multiplicateur = obtenirMultiplicateur(symbole) gains = mise Ã— multiplicateur retourner gains Sinon si deuxSymbolesIdentiques(rouleaux) : gains = mise Ã— 1.5 retourner gains Sinon : retourner 0.0 Exemples :\nğŸ’ ğŸ’ ğŸ’ avec mise de 5â‚¬ â†’ 5 Ã— 2 = 10â‚¬ ğŸ’ ğŸ’ ğŸ’ avec mise de 10â‚¬ â†’ 10 Ã— 20 = 200â‚¬ ğŸ‹ ğŸ‹ ğŸŠ avec mise de 5â‚¬ â†’ 5 Ã— 1.5 = 7.50â‚¬ ğŸ’ ğŸ‹ ğŸŠ avec mise de 5â‚¬ â†’ 0â‚¬ 8. MÃ©thode afficherResultat But : Afficher un message selon les gains.\nParamÃ¨tres :\ngains : montant gagnÃ© (double) mise : montant misÃ© (double) Retour : void\nMessages selon les gains :\ngains == 0 : â€œâŒ Perdu ! Vous perdez Xâ‚¬â€ gains == mise : â€œğŸ¤ RemboursÃ© ! Vous rÃ©cupÃ©rez votre miseâ€ gains \u003c mise Ã— 5 : â€œğŸ’° Petit gain ! Vous gagnez Xâ‚¬â€ gains \u003c mise Ã— 20 : â€œğŸ‰ Beau gain ! Vous gagnez Xâ‚¬â€ gains \u003e= mise Ã— 20 : â€œğŸŠ JACKPOT ! Vous gagnez Xâ‚¬ !!!â€ Algorithme :\nif (gains == 0) { System.out.printf(\"âŒ Perdu ! Vous perdez %.2fâ‚¬%n\", mise); } else if (gains == mise) { System.out.println(\"ğŸ¤ RemboursÃ© ! Vous rÃ©cupÃ©rez votre mise\"); } else if (gains \u003c mise * 5) { System.out.printf(\"ğŸ’° Petit gain ! Vous gagnez %.2fâ‚¬%n\", gains); } else if (gains \u003c mise * 20) { System.out.printf(\"ğŸ‰ Beau gain ! Vous gagnez %.2fâ‚¬%n\", gains); } else { System.out.printf(\"ğŸŠ JACKPOT ! Vous gagnez %.2fâ‚¬ !!!%n\", gains); } 9. MÃ©thode afficherStatistiques But : Afficher les statistiques de la session de jeu.\nParamÃ¨tres :\ntoursJoues : nombre de tours jouÃ©s (int) toursGagnes : nombre de tours avec gains (int) creditsInitiaux : crÃ©dits au dÃ©but (double) creditsFinaux : crÃ©dits Ã  la fin (double) Retour : void\nFormat dâ€™affichage :\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•— â•‘ STATISTIQUES DE SESSION â•‘ â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• Tours jouÃ©s : X Tours gagnÃ©s : Y Taux de rÃ©ussite : Z.Z% CrÃ©dits de dÃ©part : XX.XXâ‚¬ CrÃ©dits finaux : YY.YYâ‚¬ [BÃ©nÃ©fice/Perte] : Â±ZZ.ZZâ‚¬ Algorithme :\n1. Afficher l'en-tÃªte 2. Afficher tours jouÃ©s et tours gagnÃ©s 3. Si toursJoues \u003e 0 : tauxReussite = (toursGagnes / toursJoues) Ã— 100 Afficher le taux 4. Afficher crÃ©dits initiaux et finaux 5. Calculer la diffÃ©rence : difference = creditsFinaux - creditsInitiaux 6. Si diffÃ©rence \u003e 0 : Afficher \"âœ… BÃ©nÃ©fice : +Xâ‚¬\" Si diffÃ©rence \u003c 0 : Afficher \"âŒ Perte : Xâ‚¬\" (valeur absolue) Sinon : Afficher \"ğŸ¤ Ã€ l'Ã©quilibre\" 10. MÃ©thode jouerTour But : Jouer un tour complet de machine Ã  sous.\nParamÃ¨tres :\ncredits : crÃ©dits disponibles (double) mise : montant de la mise (double) Retour : Nouveaux crÃ©dits aprÃ¨s le tour (double)\nAlgorithme dÃ©taillÃ© :\n1. VÃ©rifier si la mise est possible : Si mise \u003e credits : Afficher \"âŒ CrÃ©dits insuffisants !\" Retourner credits (inchangÃ©s) 2. DÃ©duire la mise : credits = credits - mise 3. Afficher l'animation : System.out.println(\" ğŸ° Les rouleaux tournent...\") (Optionnel : ajouter une pause) 4. Lancer les rouleaux : rouleaux = lancerRouleaux() 5. Afficher les rouleaux : afficherRouleaux(rouleaux) 6. Calculer les gains : gains = calculerGains(rouleaux, mise) 7. Afficher le rÃ©sultat : afficherResultat(gains, mise) 8. Ajouter les gains aux crÃ©dits : credits = credits + gains 9. Afficher le nouveau solde : System.out.printf(\"Nouveau solde : %.2fâ‚¬%n\", credits) 10. Retourner credits 11. MÃ©thode jouer (jeu principal) But : GÃ©rer le jeu complet avec boucle de jeu et menu.\nParamÃ¨tres : Aucun\nRetour : void\nAlgorithme complet :\n1. Initialiser : Scanner scanner = new Scanner(System.in); double credits = 100.0; // CrÃ©dits de dÃ©part double creditsInitiaux = credits; int toursJoues = 0; int toursGagnes = 0; 2. Afficher l'Ã©cran de bienvenue : â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•— â•‘ MACHINE Ã€ SOUS ğŸ° â•‘ â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• CrÃ©dits de dÃ©part : 100.00â‚¬ TABLE DES GAINS : ğŸ’ ğŸ’ ğŸ’ : Ã—2 ğŸ‹ ğŸ‹ ğŸ‹ : Ã—3 ğŸŠ ğŸŠ ğŸŠ : Ã—4 ğŸ”” ğŸ”” ğŸ”” : Ã—5 â­ â­ â­ : Ã—10 ğŸ’ ğŸ’ ğŸ’ : Ã—20 7 7 7 : Ã—50 JACKPOT! 2 symboles identiques : Ã—1.5 3. Boucle de jeu (tant que credits \u003e= 1) : a. Afficher le menu : \"\\nğŸ’° CrÃ©dits : X.XXâ‚¬\" \"Choisissez votre mise :\" \"1. 1â‚¬\" \"2. 2â‚¬\" \"3. 5â‚¬\" \"4. 10â‚¬ (max)\" \"0. Quitter\" \"Votre choix : \" b. Lire le choix du joueur c. Selon le choix : - 0 : sortir de la boucle - 1 : mise = 1 - 2 : mise = 2 - 3 : mise = 5 - 4 : mise = 10 - Autre : afficher \"Choix invalide\", continuer d. VÃ©rifier que la mise \u003c= credits Sinon : afficher erreur, continuer e. Jouer le tour : creditsAvant = credits credits = jouerTour(credits, mise) toursJoues++ f. Si credits \u003e creditsAvant : toursGagnes++ g. Attendre avant le prochain tour (optionnel) : System.out.println(\" Appuyez sur EntrÃ©e pour continuer...\"); scanner.nextLine(); 4. Fin du jeu : Si credits \u003c 1 : Afficher \" ğŸ’” Vous n'avez plus de crÃ©dits !\" Sinon : Afficher \" ğŸ‘‹ Merci d'avoir jouÃ© !\" 5. Afficher les statistiques finales : afficherStatistiques(toursJoues, toursGagnes, creditsInitiaux, credits); 6. Fermer le scanner : scanner.close(); 12. MÃ©thode main But : Lancer le jeu.\nCode :\npublic static void main(String[] args) { jouer(); } âœ… CritÃ¨res de validation Les symboles sont gÃ©nÃ©rÃ©s alÃ©atoirement Les trois rouleaux sont indÃ©pendants Le calcul des gains suit les rÃ¨gles exactes Les crÃ©dits sont correctement mis Ã  jour Le jeu sâ€™arrÃªte quand crÃ©dits \u003c 1 Les statistiques sont calculÃ©es correctement Le taux de rÃ©ussite est un pourcentage entre 0 et 100 Lâ€™affichage est clair et attractif ğŸ’¡ Conseils Testez dâ€™abord avec des symboles fixes pour vÃ©rifier la logique Utilisez System.out.printf(\"%.2fâ‚¬\", montant) pour formater lâ€™argent Ajoutez des Thread.sleep(1000) pour des pauses dramatiques (importer java.lang.Thread) VÃ©rifiez tous les cas : 3 identiques, 2 identiques, aucun Testez les cas limites : crÃ©dits Ã  0, mise maximale, etc. ğŸ Extensions possibles Ajouter des symboles spÃ©ciaux (Wild, Scatter) ImplÃ©menter des tours gratuits (free spins) CrÃ©er des niveaux de difficultÃ© (probabilitÃ©s diffÃ©rentes) Ajouter un systÃ¨me de jackpot progressif Sauvegarder les meilleurs scores CrÃ©er un systÃ¨me de multiplicateurs en cascade Ajouter des sons (avec des caractÃ¨res BEEP) ğŸ“Š Grille dâ€™Ã©valuation gÃ©nÃ©rale Pour chaque projet, voici comment vous serez Ã©valuÃ© :\nFonctionnalitÃ© (50 points) Toutes les mÃ©thodes demandÃ©es sont implÃ©mentÃ©es (20 pts) Les mÃ©thodes fonctionnent correctement (20 pts) Les calculs sont exacts (10 pts) QualitÃ© du code (30 points) Noms de variables et mÃ©thodes clairs (10 pts) Code bien indentÃ© et lisible (10 pts) Commentaires pertinents (10 pts) Robustesse (20 points) Validation des entrÃ©es utilisateur (10 pts) Gestion des cas limites (5 pts) Pas dâ€™erreurs Ã  lâ€™exÃ©cution (5 pts) Total : 100 points par projet\nğŸ’¡ Conseils gÃ©nÃ©raux pour tous les projets 1. MÃ©thodologie de dÃ©veloppement Lire entiÃ¨rement les instructions Planifier : liste des mÃ©thodes Ã  crÃ©er DÃ©velopper mÃ©thode par mÃ©thode (commencer par les plus simples) Tester chaque mÃ©thode individuellement IntÃ©grer progressivement DÃ©boguer en cas de problÃ¨me AmÃ©liorer le code (refactoring) 2. Techniques de dÃ©bogage Utiliser System.out.println() pour afficher les valeurs Tester avec des valeurs simples et connues Isoler le problÃ¨me (quelle mÃ©thode ne fonctionne pas ?) VÃ©rifier les types de donnÃ©es (int vs double) Attention aux divisions par zÃ©ro 3. Bonnes pratiques Java // âœ… Bon public static double calculerMoyenne(double[] notes) { if (notes == null || notes.length == 0) { return 0.0; } double somme = 0.0; for (double note : notes) { somme += note; } return somme / notes.length; } // âŒ Mauvais public static double calcul(double[] n) { double s = 0; for (int i = 0; i \u003c n.length; i++) { s = s + n[i]; } return s / n.length; // Erreur possible si n.length == 0 } 4. Checklist avant de soumettre Le code compile sans erreur Toutes les mÃ©thodes demandÃ©es sont prÃ©sentes Les tests dans main fonctionnent Le code est indentÃ© correctement Les noms de variables sont explicites Les cas limites sont gÃ©rÃ©s Des commentaires expliquent la logique complexe ğŸš€ Ordre recommandÃ© des projets Pour dÃ©butants :\nProjet 1 (Gestion de Notes) - Le plus simple Projet 4 (Calculateur de Dates) - Logique pure Projet 6 (Analyseur de Texte) - Manipulation de String Pour intermÃ©diaires : 4. Projet 5 (Compte Bancaire) - Plus de logique 5. Projet 2 (Calculateur de Salaire) - Calculs complexes\nPour avancÃ©s : 6. Projet 3 (Jeu de Devinette) - Interaction utilisateur 7. Projet 7 (Machine Ã  Sous) - Le plus complet\nğŸ“š Ressources Java utiles MÃ©thodes String importantes length() : longueur de la chaÃ®ne charAt(index) : caractÃ¨re Ã  la position substring(debut, fin) : sous-chaÃ®ne split(regex) : dÃ©couper en tableau trim() : supprimer espaces dÃ©but/fin toLowerCase() / toUpperCase() equals(autre) : comparer deux String replace(ancien, nouveau) : remplacer MÃ©thodes de tableaux array.length : taille du tableau Arrays.toString(array) : afficher un tableau Classe Math Math.abs(x) : valeur absolue Math.max(a, b) : maximum Math.min(a, b) : minimum Math.pow(x, y) : puissance Math.round(x) : arrondir Classe Random Random random = new Random(); int nombre = random.nextInt(100); // 0-99 int nombreDe = random.nextInt(6) + 1; // 1-6 Scanner Scanner scanner = new Scanner(System.in); int nombre = scanner.nextInt(); double decimal = scanner.nextDouble(); String texte = scanner.nextLine(); scanner.close(); // Important ! Bon courage pour vos projets ! ğŸ’ª\nSi vous avez des questions sur les algorithmes ou la logique, nâ€™hÃ©sitez pas Ã  demander de lâ€™aide Ã  votre professeur.",
    "description": "Mini-Projets Java - Exercices Complets Variables, OpÃ©rateurs, Structures de ContrÃ´le et MÃ©thodes ğŸ® Projet 1 : SystÃ¨me de Gestion de Notes Scolaires ğŸ“‹ Contexte Vous devez crÃ©er un systÃ¨me pour gÃ©rer et analyser les notes dâ€™une classe dâ€™Ã©tudiants. Le systÃ¨me permettra de calculer des statistiques, dâ€™attribuer des mentions et de gÃ©nÃ©rer des rapports.",
    "tags": [],
    "title": "Exercices de rÃ©vision",
    "uri": "/420-210/exo_revisions/index.html"
  },
  {
    "breadcrumb": "Programmation orientÃ©e objet",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Categories",
    "uri": "/420-210/categories/index.html"
  },
  {
    "breadcrumb": "",
    "content": "Plans de cours ğŸ“‹ Samuel FostinÃ© : Plan de cours\nHoraire et disponibilitÃ©s des enseignants âœ”ï¸ Samuel FostinÃ© : Lien vers mon horaire et mes disponibilitÃ©s\nSamuel FostinÃ© Nom de lâ€™Ã©valuation PondÃ©ration Semaine de lâ€™Ã©valuation 10 quiz (Wooclap) (Les 8 meilleures quiz) 10 % Semaine 2 Ã  14 Examen 1 15% Semaine 5 Examen 2 20 % Semaine 11 Laboratoire 10 % Semaine 8 Projet remise final 15 % Semaine 14 Examen final 30 % Semaine 15",
    "description": "Plans de cours ğŸ“‹ Samuel FostinÃ© : Plan de cours\nHoraire et disponibilitÃ©s des enseignants âœ”ï¸ Samuel FostinÃ© : Lien vers mon horaire et mes disponibilitÃ©s\nSamuel FostinÃ© Nom de lâ€™Ã©valuation PondÃ©ration Semaine de lâ€™Ã©valuation 10 quiz (Wooclap) (Les 8 meilleures quiz) 10 % Semaine 2 Ã  14 Examen 1 15% Semaine 5 Examen 2 20 % Semaine 11 Laboratoire 10 % Semaine 8 Projet remise final 15 % Semaine 14 Examen final 30 % Semaine 15",
    "tags": [],
    "title": "Programmation orientÃ©e objet",
    "uri": "/420-210/index.html"
  },
  {
    "breadcrumb": "Programmation orientÃ©e objet",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tags",
    "uri": "/420-210/tags/index.html"
  }
]
